[{"id":"01c934d5379ccbff22bb6095093f4f21","title":"iOS App and tvOS Game adapt  Game Controller framework 适配手柄","content":"","slug":"iOS-App-and-tvOS-Game-adapt-Game-Controller-framework-适配手柄","date":"2018-01-29T15:44:56.000Z","categories_index":"","tags_index":"","author_index":"William Xie"},{"id":"27c19497dff9b88e721b526696c376b0","title":"iOS ReplayKit and BroadCast Live 深入理解","content":"","slug":"iOS-ReplayKit-and-BroadCast-Live-深入理解","date":"2018-01-29T15:42:38.000Z","categories_index":"","tags_index":"","author_index":"William Xie"},{"id":"2f63acf309eef8f0669663d02a8d8231","title":"iOS UIPasteboard 粘贴板","content":"","slug":"iOS-UIPasteboard-粘贴板","date":"2017-11-09T01:24:29.000Z","categories_index":"","tags_index":"","author_index":"William Xie"},{"id":"8e3f7b9f523d3a13632956dc84783ab5","title":"iOS iCloud 开发终结攻略","content":"","slug":"iOS-iCloud-开发终结攻略","date":"2017-11-09T01:22:55.000Z","categories_index":"","tags_index":"","author_index":"William Xie"},{"id":"ead81d2ecbfec7a8bd6b16adde176d14","title":"iOS  URLSession 入门到精通","content":"","slug":"iOS-URLSession-入门到精通","date":"2017-11-09T01:20:21.000Z","categories_index":"","tags_index":"","author_index":"William Xie"},{"id":"9dadd96f8162bc01010f2033014d9962","title":"iOS Swift GCD 超级详解","content":"","slug":"iOS-Swift-GCD-超级详解","date":"2017-11-09T01:19:43.000Z","categories_index":"","tags_index":"","author_index":"William Xie"},{"id":"834d577630ee02b50ec7eb6df43a4285","title":"iOS常用图像格式转换","content":"在iOS多媒体开发时，需要经常转换图像格式以便调试。下面列了一些常用工具方法，在UIImage, CVPixelBufferRef,Texture之间完成格式转换。\n\n其他格式转为UIImage\n\n1.1 CVImageBufferRef (RGB)转为UIImage\n\n(UIImage *)imageFromRGBImageBuffer:(CVImageBufferRef)imageBuffer {  CVPixelBufferLockBaseAddress(imageBuffer, 0);  void *baseAddress = CVPixelBufferGetBaseAddress(imageBuffer);  size_t bytesPerRow = CVPixelBufferGetBytesPerRow(imageBuffer);  size_t width = CVPixelBufferGetWidth(imageBuffer);  size_t height = CVPixelBufferGetHeight(imageBuffer);  CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceRGB();  CGContextRef context = CGBitmapContextCreate(baseAddress, width, height, 8,bytesPerRow, colorSpace, kCGBitmapByteOrder32Little | kCGImageAlphaPremultipliedFirst);  CGImageRef quartzImage = CGBitmapContextCreateImage(context);  CVPixelBufferUnlockBaseAddress(imageBuffer,0);  CGContextRelease(context);  CGColorSpaceRelease(colorSpace);  UIImage *image = [UIImage imageWithCGImage:quartzImage];  CGImageRelease(quartzImage);  return (image);}\n\n1.2 CVImageBufferRef (YUV)转为UIImage\n\n(UIImage *)imageFromYUVImageBuffer:(CVImageBufferRef)imageBuffer {  CVPixelBufferLockBaseAddress(imageBuffer, 0);  size_t bytesPerRow = CVPixelBufferGetBytesPerRowOfPlane(imageBuffer, 0);  size_t width = CVPixelBufferGetWidthOfPlane(imageBuffer, 0);  size_t height = CVPixelBufferGetHeightOfPlane(imageBuffer, 0);  void *lumaAddress = CVPixelBufferGetBaseAddress(imageBuffer);  CGColorSpaceRef rgbSpace = CGColorSpaceCreateDeviceGray();  CGContextRef context = CGBitmapContextCreate(lumaAddress, width, height, 8, bytesPerRow, rgbSpace, kCGBitmapByteOrderDefault );  CGImageRef imageRef = CGBitmapContextCreateImage(context);  CGContextRelease(context);  CVPixelBufferUnlockBaseAddress(imageBuffer, 0);  UIImage *image = [UIImage imageWithCGImage:imageRef];  CGImageRelease(imageRef);  return image;}\n\n1.3 纹理 (Texture)转为UIImage\n\n(UIImage *)imageFromTextureWithwidth:(int)width height:(int)height {  // glActiveTexture(GL_TEXTURE1); 先绑定某个纹理  int size = width * height * 4;  GLubyte *buffer = malloc(size);  glReadPixels(0, 0, width, height, GL_RGBA, GL_UNSIGNED_BYTE, buffer);  CGDataProviderRef provider = CGDataProviderCreateWithData(NULL, buffer, size, NULL);  int bitsPerComponent = 8;  int bitsPerPixel = 32;  int bytesPerRow = 4 * width;  CGColorSpaceRef colorSpaceRef = CGColorSpaceCreateDeviceRGB();  CGBitmapInfo bitmapInfo = kCGBitmapByteOrderDefault;  CGColorRenderingIntent renderingIntent = kCGRenderingIntentDefault;  CGImageRef imageRef = CGImageCreate(width, height, bitsPerComponent, bitsPerPixel, bytesPerRow, colorSpaceRef, bitmapInfo, provider, NULL, NO, renderingIntent);  UIImage *image = [UIImage imageWithCGImage:imageRef];  free(buffer);  return image;}\n\n1.4 data (RGB)转为UIImage\n\n(UIImage *)imageFromRGBData:(void )data width:(int)width height:(int)height {  CGColorSpaceRef rgbSpace = CGColorSpaceCreateDeviceRGB();  CGContextRef context = CGBitmapContextCreate(data, width, height, 8, width4, rgbSpace, kCGImageAlphaPremultipliedFirst | kCGBitmapByteOrder32Little );  CGImageRef imageRef = CGBitmapContextCreateImage(context);  CGContextRelease(context);  UIImage *image = [UIImage imageWithCGImage:imageRef];  CGImageRelease(imageRef);  return image;}\n\n1.5 data (Y)转为UIImage\n\n(UIImage *)imageFromYData:(void *)data width:(int)width height:(int)height {  CGColorSpaceRef rgbSpace = CGColorSpaceCreateDeviceGray();  CGContextRef context = CGBitmapContextCreate(data, width, height, 8, width, rgbSpace, kCGBitmapByteOrderDefault );  CGImageRef imageRef = CGBitmapContextCreateImage(context);  CGContextRelease(context);  UIImage *image = [UIImage imageWithCGImage:imageRef];  CGImageRelease(imageRef);  return image;}\n\n\nUIImage转为其他格式\n\n2.1 UIImage转为CVPixelBufferRef(RGB)\n\n(CVPixelBufferRef)imageToRGBPixelBuffer:(UIImage *)image {  CGSize frameSize = CGSizeMake(CGImageGetWidth(image.CGImage),CGImageGetHeight(image.CGImage));  NSDictionary *options =  [NSDictionary dictionaryWithObjectsAndKeys:[NSNumber numberWithBool:YES],kCVPixelBufferCGImageCompatibilityKey,[NSNumber numberWithBool:YES],kCVPixelBufferCGBitmapContextCompatibilityKey,nil];  CVPixelBufferRef pxbuffer = NULL;  CVReturn status =  CVPixelBufferCreate(kCFAllocatorDefault, frameSize.width, frameSize.height,kCVPixelFormatType_32BGRA, (__bridge CFDictionaryRef)options, &amp;pxbuffer);  NSParameterAssert(status == kCVReturnSuccess &amp;&amp; pxbuffer != NULL);  CVPixelBufferLockBaseAddress(pxbuffer, 0);  void *pxdata = CVPixelBufferGetBaseAddress(pxbuffer);  CGColorSpaceRef rgbColorSpace = CGColorSpaceCreateDeviceRGB();  CGContextRef context = CGBitmapContextCreate(pxdata, frameSize.width, frameSize.height,8, CVPixelBufferGetBytesPerRow(pxbuffer),rgbColorSpace,(CGBitmapInfo)kCGBitmapByteOrder32Little | kCGImageAlphaPremultipliedFirst);  CGContextDrawImage(context, CGRectMake(0, 0, CGImageGetWidth(image.CGImage),CGImageGetHeight(image.CGImage)), image.CGImage);  CGColorSpaceRelease(rgbColorSpace);  CGContextRelease(context);  CVPixelBufferUnlockBaseAddress(pxbuffer, 0);  return pxbuffer;}\n\n2.2 UIImage转为CVPixelBufferRef(YUV)\n\n(CVPixelBufferRef)imageToYUVPixelBuffer:(UIImage *)image {  CGSize frameSize = CGSizeMake(CGImageGetWidth(image.CGImage), CGImageGetHeight(image.CGImage));  NSDictionary *options = [NSDictionary dictionaryWithObjectsAndKeys:                       [NSNumber numberWithBool:YES],kCVPixelBufferCGImageCompatibilityKey,\n                       [NSNumber numberWithBool:YES],kCVPixelBufferCGBitmapContextCompatibilityKey,nil];\n\n  CVPixelBufferRef pxbuffer = NULL;  CVPixelBufferCreate(kCFAllocatorDefault, frameSize.width, frameSize.height,kCVPixelFormatType_420YpCbCr8BiPlanarFullRange, (__bridge CFDictionaryRef)options,&amp;pxbuffer);  CVPixelBufferLockBaseAddress(pxbuffer, 0);  void *pxdata = CVPixelBufferGetBaseAddressOfPlane(pxbuffer,0);  CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceGray();  CGContextRef context = CGBitmapContextCreate(pxdata, frameSize.width, frameSize.height,8,CVPixelBufferGetBytesPerRowOfPlane(pxbuffer, 0),colorSpace,kCGImageAlphaNone);  CGContextDrawImage(context, CGRectMake(0, 0, CGImageGetWidth(image.CGImage),CGImageGetHeight(image.CGImage)), image.CGImage);  CGColorSpaceRelease(colorSpace);  CGContextRelease(context);  CVPixelBufferUnlockBaseAddress(pxbuffer, 0);  return pxbuffer;}\n\n","slug":"iOS常用图像格式转换","date":"2017-10-24T08:20:00.000Z","categories_index":"","tags_index":"","author_index":"William Xie"},{"id":"e6105bfb53c66c2464c788c0813cc873","title":"awakeFromNib 整理摘录","content":"（1）awakeFromNib和initWithCoder:差别awakeFromNib 从xib或者storyboard加载完毕就会调用initWithCoder: 只要对象是从文件解析来的，就会调用同时存在会先调用initWithCoder:\n（2）initWithCoder: &amp; initWithFrame:initWithCoder：使用文件加载的对象调用（如从xib或stroyboard中创建）initWithFrame：使用代码加载的对象调用（使用纯代码创建）注意：所以为了同时兼顾从文件和从代码解析的对象初始化，要同时在initWithCoder: 和 initWithFrame: 中进行初始化\nnib 加载结构时 发送一个awakeFromNib消息告诉每个对象重建一个nib 归档，但只有在所有的档案中的对象已加载和初始化。当一个对象接收awakefromnibmessage，这是保证其所有出口和行动连接已经建立。\n你必须调用awakefromnib super实施给父类的运行的机会去做额外的初始化工作。虽然这种方法的默认实现不执行任何操作，许多UIKit类提供非空的实现。你可以叫super 实现在任何一点你自己的awakefromnib方法里。\n实例化过程中，存档中的每个对象未归档然后初始化的方法适合于它的类型。符合nscoding协议对象（包括所有子类和处理）正在用他们的initwithcoder初始化：方法。不符合nscoding协议所有的对象都是使用init方法初始化。在所有对象被实例化和初始化，the nib 加载代码，将所有这些对象的出口和动作的连接。然后调用对象的awakefromnib方法。更详细的信息有关的步骤，然后nib在加载过程中，看到“NIB文件”在资源规划指南。\n// 先归档方法-(id)initWithCoder:(NSCoder *)aDecoder{self = [super initWithCoder:aDecoder];if (self) {}return self;}// 保证出口和行动连接已经建立 调用 awakeFromNib-(void)awakeFromNib{[super awakeFromNib];}\nNIB文件是应用程序所有对象的存档。当程序启动后，对象从文件中释放，重新赋予生命，准备接收用户触发的事件信息。这种机制有些与众不同：大多数GUI的设计都是为界面布局产生源代码；相反，Interface Builder则允许开发者编辑好页面元素的状态后，把它们保存在文件里面。在对象从文件中释放、获得生命，而没有接收到用户事件以前，所有的对象自动发送awakeFromNib消息。开发者可以添加awakeFromNib方法，用来初始化文本框的值。\nparm mark 2\n-(void)awakeFromNib;从字面上理解，就是从nib文件中唤醒对象，完成对每一个对象的实例化或与nib文件的关联。谁唤醒这个方法？\nawakeFromNib是由nib loading machinery发出的。[NSBundle loadNibFile:externalNameTable:withZone:],加载nib文件，完成初始化设置和连接，并且在所有关联的对象上唤醒awakeFromNib方法。\n谁响应这个方法？\nCunstom Controller 和Cunstom Window都会响应awakeFromNib方法。当一个nib文件已经完成所有对象的加载之后，会对每一个与nib文件关联的对象loop back。此时，如果awakeFromNib方法中有需要响应的对象，它就会在该对象上唤起awakeFromNib方法。因此，我们可以在awakeFromNib方法中操作任何甚至所有的nib中的对象。\n需要注意的问题：当使用一个controller控制多个nib文件时，awakeFromNib方法会被多次调用。因此，当不使用awakeFromNib方法来完成nib对象的初始化时，需要注意此方法的多次调用对其他nib文件造成的影响。\n","slug":"awakeFromNib-整理摘录","date":"2017-10-24T08:18:48.000Z","categories_index":"iOS SDK","tags_index":"","author_index":"William Xie"},{"id":"6753553a886a9bb3c92807f1b53f3789","title":"理解霍夫变换(Python 版本)","content":"https://alyssaq.github.io/2014/understanding-hough-transform/\nhttps://zh.wikipedia.org/wiki/霍夫变换\n","slug":"理解霍夫变换-Python-版本","date":"2017-07-21T06:22:25.000Z","categories_index":"Self-Driving Car Engieer","tags_index":"opencv,Hough Transform,python","author_index":"William Xie"},{"id":"bd608e4d5982e160f985ab34e4deb2b6","title":"swift perfect 服务器配置https证书","content":"https://medium.com/@iamjono/easily-secure-your-perfect-server-side-swift-code-with-https-3df86a8cab28\n因项目需要须使用https服务，得知阿里云可以免费申请，确实感谢。我们的前提：  1.有阿里云的服务器账号。            2.申请的域名托管在阿里云的云解析服务有了这两个前提申请就方便快捷多了。\n1.登录阿里云–&gt;安全(云盾)–&gt;CA证书服务\n2.选择购买证书\n3.在配置单中选择 “免费型DV SSL”   证书提供商品牌为:“赛门铁克”                           注意:免费数字证书,最多保护一个明细子域名,不支持通配符，一个阿云帐户最多签发20张免费证书\n4.支付 （0元）\n5.支付后会看到一条状态为“待完成”的记录，此时千万别以为就可以等待阿里云审核了，其实后面还是有资料要填写的。\n6.选择补全.\n7.填写相应信息。真实填写就可以了。包括：域名、姓名、邮箱等等。因为我的域名是托管到阿里云解析服务的，所以我的认证方式DNS解析认证。填写完成后才是“待审核”状态，等待就可以了。\n8.系统生成证书.填写完毕就是提交审核,阿里云会发生一份邮件给你填写的邮箱,邮件的内容：发送给你的 主机记录和记录值，这个应该是阿里云去做的认证审核。\n\n9.订单进度我勾选了DNS 证书绑定的域名在阿里云解析产品上,会自动帮我们添加记录.如果没有使用阿里云的DNS域名解析,那手动去添加吧.\n10.等待10分钟，此过程阿里云系统会去检测，检测到了就成功，此时你的域名证书记录状态为“已签发”\n11.下载此证书，选择对应的应用服务器，我们用的是nignx，下载后一个压缩文件，里面包含2个文件,xx.pem xx.key。\n12.安装证书,80 端口重定向到https\nlet confData = [\n    \"servers\": [\n        // Serves Port 80\n        // Configuration data for another server which:\n        //\t* Redirects all traffic back to the first server.\n        [\n            \"name\":\"localhost\",\n            \"port\":80,\n            \"routes\":[\n                [\"method\":\"get\", \"uri\":\"/**\", \"handler\":PerfectHTTPServer.HTTPHandler.redirect,\"base\":\"https://localhost\"]\n            ],    \n        ],\n        // Serves Port 443.\n        [\n            \"name\":\"localhost\",\n            \"port\":443,\n            \"routes\":[\n                [\"method\":\"get\", \"uri\":\"/\", \"handler\":PerfectHTTPServer.HTTPHandler.staticFiles],\n                [\"method\":\"get\", \"uri\":\"/**\", \"handler\":PerfectHTTPServer.HTTPHandler.staticFiles,\n                 \"documentRoot\":\"./webroot\",\n                 \"allowResponseFilters\":true]\n            ],\n            \"tlsConfig\":[\n                \"certPath\": \"./webroot/cert/21411439650856.pem\",\n                \"verifyMode\": \"peer\",\n                \"keyPath\": \"./webroot/cert/21411494650856.key\",\n                \"cipherList\":\"ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4\"\n            ],\n            \"runAs\":\"root\",\n        ]\n    ]\n]\n\n\nlocal build  test \n\n14.delopy swift perfect\n15.通过https访问，大功告成。\n16.apple ATS 测试\nnscurl --ats-diagnostics --verbose https://www.konekti-ai.com\n","slug":"swift-perfect-服务器配置https证书","date":"2017-06-02T02:59:57.000Z","categories_index":"Swift Perfect","tags_index":"Https,Swift perfect,EC2","author_index":"William Xie"},{"id":"f096cf8cc9c4e9501d76e168f45cd56c","title":"Swift 脚本编写","content":"老规矩，从 Hello World 开始。\n新建一个 Swift 文件，就叫 Hello.swift 吧。使用文本编辑器打开输入以下内容，并保存：\n#!/usr/bin/env xcrun swiftprintln(“Hello World”)\n打开终端，切换到保存 Hello.swift 文件的路径下，为该文件添加可执行权限，命令如下：chmod +x Hello.swift\n然后运行一下这个文件：./Hello.swift\n终端上输出了熟悉的 Hello World。\n执行 shell 脚本\n在Swift 脚本里，你可以尽情使用 Swift 语法特性。但有些情况下还是需要调用一些 shell 脚本的。这里就需要用到 Foundation 库中的 NSTask 类了。\n首先，在脚本中引入 Foundation 库。import Foundation调用 shell 脚本的关键代码:let shell = “pwd”let task = NSTask()task.launchPath = “/bin/bash”task.arguments = [“-c”, shell]\ntask.launch()字符串常量 shell 可以是任意能在 bash 中执行的 shell 脚本文本内容\n","slug":"Swift-脚本编写","date":"2017-04-02T14:23:30.000Z","categories_index":"","tags_index":"swift","author_index":"William Xie"},{"id":"391bdcc94651b98f450f3675b7014474","title":"发布自己的pods到CocoaPods trunk","content":"使用CocoaPods trunk之前请确认CocoaPods版本是否是0.33或以上，打开Teaminal(终端)输入pod –version即可查看，如果版本过低，请执行sudo gem install cocoapods安装最新版本！\n1.注册trunkpod trunk register &#120;&#120;&#x78;&#x40;&#99;&#111;&#x63;&#x6f;&#97;&#x70;&#111;&#100;&#x73;&#x2e;&#111;&#x72;&#x67; ‘williamxie’ –description=’williamxie’ macbook pro’ –verbose\n&#x78;&#x78;&#x78;&#x40;&#99;&#111;&#x63;&#x6f;&#x61;&#112;&#111;&#100;&#x73;&#46;&#x6f;&#x72;&#103; - 一个真实存在的邮箱,替换自己的邮箱williamxie - 用户名williamxie’s macbook pro - 描述性文字\n如果所有的步骤都能成功的话，你会受到一份邮件，需要点击验证下。\n查看trunkpod trunk me\n可以查看你已经注册的信息，其中包含你的name、email、since、Pods、sessions，其中Pods为你往CocoaPods提交的所有的Pod！\n添加其他维护者（如果你的pod是由多人维护的，你也可以添加其他维护者）pod trunk add-owner XPRACSignal &#119;&#105;&#x6c;&#108;&#105;&#x61;&#109;&#x78;&#105;&#101;&#x40;&#99;&#x6f;&#99;&#x6f;&#97;&#112;&#x6f;&#100;&#x73;&#x2e;&#111;&#x72;&#x67;\n以上所有的步骤都是准备阶段……\n进入项目级步骤\n创建podspecpod spec create DeepSwift执行完该命令之后会在工程目录生成DeepSwift.podspec文件，然后编辑这个文件！里面注释很多，应该都能看懂，就不一一讲解了。这里就贴一张图了，该文件去掉了很多注释信息，以免干扰！\n提交code到git仓库中，并打上tag版本号这一步可使用git命名行也可使用工具，最重要的是tag，因为CocoaPods是根据tag来分析的！\n提交到CocoaPods trunk执行命令pod trunk push即可完成提交，改命令会首先验证你本地的podspec文件，之后会上传spec文件到trunk，最后会将你上传的podpec文件转换为需要的json文件。提示：1.验证podspec也可手动执行命令pod spec lint DeepSwift.podspec2.提交成功之后以前需要花些时间去验证（猜测可能是跑build等），貌似现在稍等1分钟就可以。\n测试pod执行命令pod search DeepSwift\n补充\n如果你之前提交过Pod，那么trunk之后你需要去Claim your Podp[https://trunk.cocoapods.org/claims/new]认领下！\n","slug":"发布自己的pods到CocoaPods-trunk","date":"2017-03-15T14:45:58.000Z","categories_index":"","tags_index":"","author_index":"William Xie"},{"id":"e06b0538db7ceae1980a72095aa57bd5","title":"Tensorflow 在 iOS 平台的移植","content":"https://github.com/tensorflow/tensorflow/tree/master/tensorflow/contrib/makefile\n对于iOS平台下如何使用TensorFlow ，TensorFlow给出了详细的编译脚本命令，详情请查看官方文档的命令。\n工欲善其事必先利其器，在开始编译工作之前，需要准备一些编译所必须的工具：\n1.xcode安装xcode 7.3 以及以上版本, 如果你没有,那么你可以在终端使用命令行进行安装\nxcode-select --install\n\n2.库\nHomebrew: Mac os x 上包管理工具，具体使用方法可参考Doc。\n$ /usr/bin/ruby -e “$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;\nHomebrew安装好之后，依次安装三个辅助性编译工具：\n$ brew install libtool$ brew install autoconf$ brew install automake   \n三个工具的含义，请参考：https://en.wikipedia.org/wiki/GNU_Libtool\n克隆TensorFlow\nGoogle以Apache 2.0开源协议将TensorFlow开源在GitHub上，我们可以直接使用TensorFlow源码。\n在任意你想存放TensorFlow源码的地方 ，clone项目。\n$ git clone https://github.com/tensorflow/tensorflow \n\n下载graph\n\n mkdir -p ~/graphs curl -o ~/graphs/inception.zip  https://storage.googleapis.com/download.tensorflow.org/models/inception5h.zip  &amp;&amp; unzip ~/graphs/inception.zip -d ~/graphs/inception\n　\n 一键编译\n　在TensorFlow的tensorflow/contrib/makefile/目录下，有很多可使用的编译脚本，其中build_all_ios.sh脚本专门用来一键编译TensorFlow iOS静态库。\n如果你仅仅想要快速的获取以及编译完成的Tensorflow静态库,你需要在Tensorflow根文件夹上运行以下这个命令:\ntensorflow/contrib/makefile/build_all_ios.sh\n\n在最新MacBook Pro机子上,这个编译过程大概需要20多分钟.\n当编译完成之后骂你将有个单一架构的静态库和benchmark 程序,尽管能够成功的编译benchmark 程序, 但是这个程序不是一个完整的iOS 项目\n想要实现 tensorflow 运行在iOS上, tensorflow/contrib/ios_examples这个链接将要展示如何使用一个静态库\n手动编译\nThis section covers each step of building. For all the code in one place, see build_all_ios.sh.\n这个章节将要覆盖编译的每一个步骤,build_all_ios.sh 是将所有的编译命令 集中在一起\nIf you have not already, you will need to download dependencies:下载依赖库\ntensorflow/contrib/makefile/download_dependencies.sh\n\nNext, you will need to compile protobufs for iOS:\n你需要编译 protobufs 库    tensorflow/contrib/makefile/compile_ios_protobuf.sh \nThen, you can run the makefile specifying iOS as the target, along with the architecture you want to build for:然后你可以在makefile文件中指定你想要变异的iOS 架构 \nmake -f tensorflow/contrib/makefile/Makefile  TARGET=IOS  IOS_ARCH=ARM64\nThis creates a library in tensorflow/contrib/makefile/gen/lib/libtensorflow-core.a that you can link any xcode project against.\n创建的静态库 路径 tensorflow/contrib/makefile/gen/lib/libtensorflow-core.a \nAt this point, you will have a library for a single architecture and the benchmark program. Although successfully compiling the benchmark program is a sign of success, the program is not a complete iOS app.这个时候 你将要有有一个库 在的单一架构 和 benchmark 程序 ,同样成功的信号说明 这个benchmark 程序 编译完成 ,但不是一个完整的iOS 项目.\nTo see TensorFlow running on iOS, the example Xcode project in tensorflow/contrib/ios_examples shows how to use the static library in a simple app.\nUniversal binaries通用二进制\nIn some situations, you will need a universal library. In that case, you will still need to run compile_ios_protobuf.sh, but this time follow it with:在一些时候,你需要一个通用的二进制库. 这个时候 你将仍然需要先运行  compile_ios_protobuf.sh 脚步, 在执行以下脚本:\ncompile_ios_tensorflow.sh\n\nIn XCode, you will need to use -force_load in the linker flags section of the build settings to pull in the global constructors that are used to register ops and kernels.\n在xcode 你在需要build setting 中的linker flags section 设置 ‘-force_load’ \nOptimization\n优化\nThe compile_ios_tensorflow.sh script can take optional command-line arguments. The first argument will be passed as a C++ optimization flag and defaults to debug mode. If you are concerned about performance or are working on a release build, you would likely want a higher optimization setting, like so:\ncompile_ios_tensorflow.sh “-Os”For other variations of valid optimization flags, see clang optimization levels.\nhttps://github.com/tensorflow/tensorflow/tree/master/tensorflow/contrib/ios_examples\nTensorFlow iOS Examples\nThis folder contains examples of how to build applications for iOS devices using TensorFlow.\nBuilding the Examples\nYou’ll need Xcode 7.3 or later, with the command-line tools installed.\nFollow the instructions at tensorflow/contrib/makefile under “iOS” to compile a static library containing the core TensorFlow code.\nFrom the root of the Tensorflow folder, download Inception v1, and extract the label and graph files into the data folders inside both the simple and camera examples:\nmkdir -p ~/graphscurl -o ~/graphs/inception5h.zip  https://storage.googleapis.com/download.tensorflow.org/models/inception5h.zip  &amp;&amp; unzip ~/graphs/inception5h.zip -d ~/graphs/inception5hcp ~/graphs/inception5h/* tensorflow/contrib/ios_examples/benchmark/data/cp ~/graphs/inception5h/* tensorflow/contrib/ios_examples/camera/data/cp ~/graphs/inception5h/* tensorflow/contrib/ios_examples/simple/data/Load the Xcode project inside the simple subfolder, and press Command-R to build and run it on the simulator or your connected device.\nYou should see a single-screen app with a “Run Model” button. Tap that, and you should see some debug output appear below indicating that the example Grace Hopper image has been analyzed, with a military uniform recognized.\nOnce you have success there, make sure you have a real device connected and open up the Xcode project in the camera subfolder. Once you build and run that, you should get a live camera view that you can point at objects to get real-time recognition results.\nTroubleshooting\nIf you’re hitting problems, here’s a checklist of common things to investigate:\nMake sure that you’ve run the build_all_ios.sh script. This will run download_dependencies.sh,compile_ios_protobuf.sh and compile_ios_tensorflow.sh. (check each one if they have run successful.)\nCheck that you have version 7.3 of Xcode.\nIf there’s a complaint about no Sessions registered, that means that the C++ global constructors that TensorFlow relies on for registration haven’t been linked in properly. You’ll have to make sure your project uses force_load, as described below.\nCreating your Own App\nYou’ll need to update various settings in your app to link against TensorFlow. You can view them in the example projects, but here’s a full rundown:\nThe compile_ios_tensorflow.sh script builds a universal static library in tensorflow/contrib/makefile/gen/lib/libtensorflow-core.a. You’ll need to add this to your linking build stage, and in Search Paths add tensorflow/contrib/makefile/gen/lib to the Library Search Paths setting.\nYou’ll also need to add libprotobuf.a and libprotobuf-lite.a from tensorflow/contrib/makefile/gen/protobuf_ios/lib to your Build Stages and Library Search Paths.\nThe Header Search paths needs to contain:\nthe root folder of tensorflow,tensorflow/contrib/makefile/downloads/protobuf/srctensorflow/contrib/makefile/downloads,tensorflow/contrib/makefile/downloads/eigen, andtensorflow/contrib/makefile/gen/proto.In the Linking section, you need to add -force_load followed by the path to the TensorFlow static library in the Other Linker Flags section. This ensures that the global C++ objects that are used to register important classes inside the library are not stripped out. To the linker, they can appear unused because no other code references the variables, but in fact their constructors have the important side effect of registering the class.\nYou’ll need to include the Accelerate framework in the “Link Binary with Libraries” build phase of your project.\nC++11 support (or later) should be enabled by setting C++ Language Dialect to GNU++11 (or GNU++14), and C++ Standard Library to libc++.\nThe library doesn’t currently support bitcode, so you’ll need to disable that in your project settings.\nRemove any use of the -all_load flag in your project. The protocol buffers libraries (full and lite versions) contain duplicate symbols, and the -all_load flag will cause these duplicates to become link errors. If you were using -all_load to avoid issues with Objective-C categories in static libraries, you may be able to replace it with the -ObjC flag.\nReducing the binary size\nTensorFlow is a comparatively large library for a mobile device, so it will increase the size of your app. Currently on iOS we see around a 11 MB binary footprint per CPU architecture, though we’re actively working on reducing that. It can be tricky to set up the right configuration in your own app to keep the size minimized, so if you do run into this issue we recommend you start by looking at the simple example to examine its size. Here’s how you do that:\nOpen the Xcode project in tensorflow/contrib/ios_examples/simple.\nMake sure you’ve followed the steps above to get the data files.\nChoose “Generic iOS Device” as the build configuration.\nSelect Product-&gt;Build.\nOnce the build’s complete, open the Report Navigator and select the logs.\nNear the bottom, you’ll see a line saying “Touch tf_ios_makefile_example.app”.\nExpand that line using the icon on the right, and copy the first argument to the Touch command.\nGo to the terminal, type ls -lah and then paste the path you copied.\nFor example it might look like ls -lah /Users/petewarden/Library/Developer/Xcode/DerivedData/tf_ios_makefile_example-etdbksqytcnzeyfgdwiihzkqpxwr/Build/Products/Debug-iphoneos/tf_ios_makefile_example.app\nRunning this command will show the size of the executable as the tf_ios_makefile_example line.\nRight now you’ll see a size of around 23 MB, since it’s including two architectures (armv7 and arm64). As a first step, you should make sure the size increase you see in your own app is similar, and if it’s larger, look at the “Other Linker Flags” used in the Simple Xcode project settings to strip the executable.\nAfter that, you can manually look at modifying the list of kernels included in tensorflow/contrib/makefile/tf_op_files.txt to reduce the number of implementations to the ones you’re actually using in your own model. We’re hoping to automate this step in the future, but for now manually removing them is the best approach.\n","slug":"Tensorflow-在-iOS-平台的移植","date":"2017-02-21T04:49:52.000Z","categories_index":"Machine Learning","tags_index":"Tensorflow,iOS","author_index":"William Xie"},{"id":"d1eb6b3046bcdf2d58e7f3badfd9e924","title":"Ubuntu 14.04 远程登录服务器 ssh配置","content":"sudo apt-get updatesudo apt-get install openssh-server\nsudo ps -e |grep ssh”–&gt;回车–&gt;有sshd,说明ssh服务已经启动，如果没有启动，输入”sudo service ssh start\n“/etc/ssh/sshd_config”打开”终端窗口”，输入”sudo gedit /etc/ssh/sshd_config”–&gt;回车–&gt;把配置文件中的”PermitRootLogin without-password”加一个”#”号,把它注释掉–&gt;再增加一句”PermitRootLogin yes”–&gt;保存，修改成功。\nsudo ifconfig\n","slug":"Ubuntu-14-04-远程登录服务器-ssh配置","date":"2017-01-10T08:28:20.000Z","categories_index":"cloud computing","tags_index":"Cloud Computing,Ubuntu","author_index":"William Xie"},{"id":"d2e6a4ee1e2cdcc5d1116fd9ebf7e7c9","title":"Ubuntu 14.04 FTP服务器--vsftpd的安装和配置","content":"更新源列表sudo apt-get update\n安装vsftpdsudo apt-get install vsftpd判断vsftpd是否安装成功sudo service vsftpd restart\n\n新建”/home/vsftp”目录作为用户主目录sudo mkdir /home/vsftpsudo ls /home新建用户user并设置密码sudo useradd -d /home/user -s /bin/bash user\nsudo passwd uftp修改配置文件/etc/vsftpd.confsudo vim /etc/vsftpd.conf\n添加userlist_deny=NOuserlist_enable=YES userlist_file=/etc/allowed_users修改seccomp_sandbox=NO -&gt; seccomp_sandbox=YES\n新建/etc/allowed_users,输入usersudo vim /etc/allowed_users\n查看/etc/ftpusers,这个文件中记录的是不能访问FTP服务器的用户清单。sudo vim /etc/ftpusers\n","slug":"Ubuntu-14-04-FTP服务器-vsftpd的安装和配置","date":"2016-10-20T02:20:07.000Z","categories_index":"cloud computing","tags_index":"Cloud Computing,Ubuntu","author_index":"William Xie"},{"id":"53fb53cffdea48f0ac6f11fb007fc66b","title":"pili-librtmp源码分析: 握手(HandShake)","content":"","slug":"pili-librtmp源码分析-握手-HandShake","date":"2016-10-03T01:53:29.000Z","categories_index":"","tags_index":"","author_index":"William Xie"},{"id":"8dc0e43066d56f0d6869d0f3bc56b352","title":"Swift Package Manager包管理器","content":"","slug":"Swift-Package-Manager包管理器","date":"2016-09-18T02:44:46.000Z","categories_index":"","tags_index":"","author_index":"William Xie"},{"id":"c25379025e92a4dc7bbadaa323f14568","title":"Xcode 集成CocoaPods教程","content":"","slug":"Xcode-集成CocoaPods教程","date":"2016-09-18T02:18:53.000Z","categories_index":"","tags_index":"","author_index":"William Xie"},{"id":"0ff7dc01549b3268b0d4156ecaf4c266","title":"Xcode 集成Carthage教程","content":"","slug":"Xcode-集成Carthage教程","date":"2016-09-18T02:18:17.000Z","categories_index":"","tags_index":"","author_index":"William Xie"},{"id":"1acfe8485ebcb89a9ff92dc76b528910","title":"iOS 直播推流端: 软编码视频H.264和音频AAC","content":"","slug":"iOS-直播推流端-软编码视频H-264和音频AAC","date":"2016-09-08T09:53:29.000Z","categories_index":"","tags_index":"","author_index":"William Xie"},{"id":"65b1423852a0fa523adf6becd9cc334f","title":"iOS 直播推流端: 硬编码视频H.264和音频AAC","content":"https://zh.wikipedia.org/zh-cn/網路抽象層#NAL_units\n公司项目原因，接触了一下视频流H264的编解码知识，之前项目使用的是FFMpeg多媒体库，利用CPU做视频的编码和解码，俗称为软编软解。该方法比较通用，但是占用CPU资源，编解码效率不高。一般系统都会提供GPU或者专用处理器来对视频流进行编解码，也就是硬件编码和解码，简称为硬编解码。苹果在iOS 8.0系统之前，没有开放系统的硬件编码解码功能，不过Mac OS系统一直有，被称为Video ToolBox的框架来处理硬件的编码和解码，终于在iOS 8.0后，苹果将该框架引入iOS系统。\n由此，开发者便可以在iOS里面，调用Video Toolbox框架提供的接口，来对视频进行硬件编解码的工作，为VOIP视频通话，视频流播放等应用的视频编解码提供了便利。\n（PS：按照苹果WWDC2014 513《direct access to media encoding and decoding》的描述，苹果之前提供的AVFoundation框架也使用硬件对视频进行硬编码和解码，但是编码后直接写入文件，解码后直接显示。Video Toolbox框架可以得到编码后的帧结构，也可以得到解码后的原始图像，因此具有更大的灵活性做一些视频图像处理。）\n一，VideoToolbox基本数据结构。\nVideo Toolbox视频编解码前后需要应用的数据结构进行说明。\n（1）CVPixelBuffer：编码前(编码流程)和解码后(解码流程)的图像数据结构,其实就是像素数据。\n（2）CMTime、CMClock和CMTimebase：时间戳相关。时间以64-bit/32-bit的形式出现。\n（3）CMBlockBuffer：编码后，结果图像的数据结构。\n（4）CMVideoFormatDescription：图像存储方式，编解码器等格式描述。\n（5）CMSampleBuffer：存放编解码前后的视频图像的容器数据结构。\n图1.1视频H264编解码前后数据结构示意图\n如图1.1所示，编解码前后的视频图像均封装在CMSampleBuffer中，如果是编码后的图像，以CMBlockBuffe方式存储；解码后的图像，以CVPixelBuffer存储。CMSampleBuffer里面还有另外的时间信息CMTime和视频描述信息CMVideoFormatDesc。\n二，硬解码使用方法。\n通过如图2.1所示的一个典型应用，来说明如何使用硬件解码接口。该应用场景是从网络处传来H264编码后的视频码流，最后显示在手机屏幕上。\n图2.1 H264典型应用场景\n1，将H264码流转换成解码前的CMSampleBuffer。\n由图1.1所示，解码前的CMSampleBuffer = CMTime + FormatDesc + CMBlockBuffer。需要从H264的码流里面提取出以上的三个信息。最后组合成CMSampleBuffer，提供给硬解码接口来进行解码工作。\nH264的码流由NALU单元组成，NALU单元包含视频图像数据和H264的参数信息。其中视频图像数据就是CMBlockBuffer，而H264的参数信息则可以组合成FormatDesc。具体来说参数信息包含SPS（Sequence Parameter Set）和PPS（Picture Parameter Set）。图2.2显示一个H264码流的结构。\n图2.2 H264码流结构\n（1）提取sps和pps生成format description。\na，每个NALU的开始码是0x00 00 01，按照开始码定位NALU。\nb，通过类型信息找到sps和pps并提取，开始码后第一个byte的后5位，7代表sps，8代表pps。\nc，CMVideoFormatDescriptionCreateFromH264ParameterSets函数来构建CMVideoFormatDescriptionRef。具体代码可以见demo。\n（2）提取视频图像数据生成CMBlockBuffer。\na，通过开始码，定位到NALU。\nb，确定类型为数据后，将开始码替换成NALU的长度信息（4 Bytes）。\nc，CMBlockBufferCreateWithMemoryBlock接口构造CMBlockBufferRef。具体代码可以见demo。\n（3）根据需要，生成CMTime信息。（实际测试时，加入time信息后，有不稳定的图像，不加入time信息反而没有，需要进一步研究，这里建议不加入time信息）\n根据上述得到CMVideoFormatDescriptionRef、CMBlockBufferRef和可选的时间信息，使用CMSampleBufferCreate接口得到CMSampleBuffer数据这个待解码的原始的数据。见图2.3的H264数据转换示意图。\n图2.3 H264码流转换CMSampleBuffer示意图\n2，硬件解码图像显示。\n硬件解码显示的方式有两种：\n（1）通过系统提供的AVSampleBufferDisplayLayer来解码并显示。\nAVSampleBufferDisplayLayer是苹果提供的一个专门显示编码后的H264数据的显示层，它是CALayer的子类，因此使用方式和其它CALayer类似。该层内置了硬件解码功能，将原始的CMSampleBuffer解码后的图像直接显示在屏幕上面，非常的简单方便。图2.4显示了这一解码过程。\n图2.4 AVSampleBufferDisplayLayer硬解压后显示图像\n显示的接口为[_avslayer enqueueSampleBuffer:sampleBuffer];\n（2）通过VTDecompression接口来，将CMSampleBuffer解码成图像，将图像通过UIImageView或者OpenGL上显示。\na，初始化VTDecompressionSession，设置解码器的相关信息。初始化信息需要CMSampleBuffer里面的FormatDescription，以及设置解码后图像的存储方式。demo里面设置的CGBitmap模式，使用RGB方式存放。编码后的图像经过解码后，会调用一个回调函数，将解码后的图像交个这个回调函数来进一步处理。我们就在这个回调里面，将解码后的图像发给control来显示，初始化的时候要将回调指针作为参数传给create接口函数。最后使用create接口对session来进行初始化。\nb，a中所述的回调函数可以完成CGBitmap图像转换成UIImage图像的处理，将图像通过队列发送到Control来进行显示处理。\nc，调用VTDecompresSessionDecodeFrame接口进行解码操作。解码后的图像会交由a，b步骤设置的回调函数，来进一步的处理。\n图2.5显示来硬解码的过程步骤。\n图2.5 VTDecompression硬解码过程示意图\n三，硬编码使用方法。\n硬编码的使用也通过一个典型的应用场景来描述。首先，通过摄像头来采集图像，然后将采集到的图像，通过硬编码的方式进行编码，最后编码后的数据将其组合成H264的码流通过网络传播。\n1，摄像头采集数据。\n摄像头采集，iOS系统提供了AVCaptureSession来采集摄像头的图像数据。设定好session的采集解析度。再设定好input和output即可。output设定的时候，需要设置delegate和输出队列。在delegate方法，处理采集好的图像。\n注意，需要说明的是，图像输出的格式，是未编码的CMSampleBuffer形式。\n2，使用VTCompressionSession进行硬编码。\n（1）初始化VTCompressionSession。\nVTCompressionSession初始化的时候，一般需要给出width宽，height长，编码器类型kCMVideoCodecType_H264等。然后通过调用VTSessionSetProperty接口设置帧率等属性，demo里面提供了一些设置参考，测试的时候发现几乎没有什么影响，可能需要进一步调试。最后需要设定一个回调函数，这个回调是视频图像编码成功后调用。全部准备好后，使用VTCompressionSessionCreate创建session。\n（2）提取摄像头采集的原始图像数据给VTCompressionSession来硬编码。\n摄像头采集后的图像是未编码的CMSampleBuffer形式，利用给定的接口函数CMSampleBufferGetImageBuffer从中提取出CVPixelBufferRef，使用硬编码接口VTCompressionSessionEncodeFrame来对该帧进行硬编码，编码成功后，会自动调用session初始化时设置的回调函数。\n（3）利用回调函数，将因编码成功的CMSampleBuffer转换成H264码流，通过网络传播。\n基本上是硬解码的一个逆过程。解析出参数集SPS和PPS，加上开始码后组装成NALU。提取出视频数据，将长度码转换成开始码，组长成NALU。将NALU发送出去。\n图2.6显示了整个硬编码的处理逻辑。\n图2.6硬编码处理流程示意图\n四，硬编解码的一些编码说明。\n由于Video Toolbox是基础的core Foundation库函数，C语言写成，和使用core Foundation所有的其它功能一样需要适应，记得Github有个同志，将其改成了OC语言能方便调用的模式，但是地址忘了，以后有缘找到，就会提供下链接。\n文／Ethan_Struggle（简书作者）原文链接：http://www.jianshu.com/p/a6530fa46a88著作权归作者所有，转载请联系作者获得授权，并标注“简书作者”。\n","slug":"iOS-直播推流端-硬编码视频H-264和音频AAC","date":"2016-09-08T09:53:14.000Z","categories_index":"","tags_index":"","author_index":"William Xie"},{"id":"f7d4fe327521718ef855a7b5e57fec96","title":"iOS 直播推流端:采集音视频数据","content":"OS上使用AVFoundation.framework框架来调用系统相机并获取视频数据。视频数据可以根据设定的参数，可采集到RGB或YUV数据，一般使用的是GBRA32，420v，420f，下面演示相机的调用和视频数据的获取。a)引入框架的头文件#import &lt;AVFoundation/AVFoundation.h&gt;b)调用的类遵守协议AVCaptureVideoDataOutputSampleBufferDelegatec)声明变量AVCaptureSession            *captureSession;AVCaptureDevice             *captureDevice;AVCaptureDeviceInput        *captureDeviceInput;AVCaptureVideoDataOutput    *captureVdieoDataOutput;d)实现e)demo地址 https://github.com/depthlove/STMCamera\nAVFoundation 是 iOS系统上可以捕捉iPhone／iPad／iPod摄像头的一个库，这个库采集输出的是YUV/RGB。跟编码h264没有关系，AVFoundation只是作为一个视频输入源而已，要将它的数据采用编码器编码才能得到h264 数据。具体可参看我的博文《利用FFmpeg+x264将iOS摄像头实时视频流编码为h264文件》http://depthlove.github.io/2015/09/18/use-ffmpeg-and-x264-encode-iOS-camera-video-to-h264/ ， 《利用x264将iOS摄像头实时视频流编码为h264文件》http://depthlove.github.io/2015/09/17/use-x264-encode-iOS-camera-video-to-h264/ ， 《在iOS上硬编码推流－硬编码h264（四）》http://depthlove.github.io/2016/03/20/hw-encode-and-transfer-in-ios-platform-videotoolbox-encode-h264-part4/\nAVFoundation: 音视频数据采集需要用AVFoundation框架.\nAVCaptureDevice：硬件设备，包括麦克风、摄像头，通过该对象可以设置物理设备的一些属性（例如相机聚焦、白平衡等）\nAVCaptureDeviceInput：硬件输入对象，可以根据AVCaptureDevice创建对应的AVCaptureDeviceInput对象，用于管理硬件输入数据。\nAVCaptureOutput：硬件输出对象，用于接收各类输出数据，通常使用对应的子类AVCaptureAudioDataOutput（声音数据输出对象）、AVCaptureVideoDataOutput（视频数据输出对象）\nAVCaptionConnection:当把一个输入和输出添加到AVCaptureSession之后，AVCaptureSession就会在输入、输出设备之间建立连接,而且通过AVCaptureOutput可以获取这个连接对象。\nAVCaptureVideoPreviewLayer:相机拍摄预览图层，能实时查看拍照或视频录制效果，创建该对象需要指定对应的AVCaptureSession对象，因为AVCaptureSession包含视频输入数据，有视频数据才能展示。\nAVCaptureSession: 协调输入与输出之间传输数据\n系统作用：可以操作硬件设备工作原理：让App与系统之间产生一个捕获会话，相当于App与硬件设备有联系了， 我们只需要把硬件输入对象和输出对象添加到会话中，会话就会自动把硬件输入对象和输出产生连接，这样硬件输入与输出设备就能传输音视频数据。\n现实生活场景：租客（输入钱），中介（会话），房东（输出房），租客和房东都在中介登记，中介就会让租客与房东之间产生联系，以后租客就能直接和房东联系了。\n捕获音视频步骤:官方文档\n1.创建AVCaptureSession对象\n2.获取AVCaptureDevicel录像设备（摄像头），录音设备（麦克风），注意不具备输入数据功能,只是用来调节硬件设备的配置。\n3.根据音频/视频硬件设备(AVCaptureDevice)创建音频/视频硬件输入数据对象(AVCaptureDeviceInput)，专门管理数据输入。\n4.创建视频输出数据管理对象（AVCaptureVideoDataOutput），并且设置样品缓存代理(setSampleBufferDelegate)就可以通过它拿到采集到的视频数据\n5.创建音频输出数据管理对象（AVCaptureAudioDataOutput），并且设置样品缓存代理(setSampleBufferDelegate)就可以通过它拿到采集到的音频数据\n6.将数据输入对象AVCaptureDeviceInput、数据输出对象AVCaptureOutput添加到媒体会话管理对象AVCaptureSession中,就会自动让音频输入与输出和视频输入与输出产生连接.\n7.创建视频预览图层AVCaptureVideoPreviewLayer并指定媒体会话，添加图层到显示容器layer中\n8.启动AVCaptureSession，只有开启，才会开始输入到输出数据流传输。\n\n\n\n\n\n\n\n\n","slug":"iOS-直播推流端-采集音视频数据","date":"2016-09-08T09:40:42.000Z","categories_index":"音视频开发","tags_index":"AVCaptureSession,AVFoundation,直播推流","author_index":"William Xie"},{"id":"11588d060f7bd3137137343430b3d020","title":"iOS 直播推流端: 实时图像滤镜","content":"","slug":"iOS-直播推流端-实时图像滤镜","date":"2016-09-08T05:41:56.000Z","categories_index":"","tags_index":"","author_index":"William Xie"},{"id":"af194cf772338e5ab2861d3ce9297882","title":"音视频编解码中常用的编译脚本","content":"FFmpegiOS：https://github.com/kewlbear/FFmpeg-iOS-build-scriptx264iOS：https://github.com/kewlbear/x264-iosfdk-aaciOS：https://github.com/verybigdog/fdk-aac-ios或 https://github.com/kewlbear/fdk-aac-build-script-for-iOS，不支持iOS arm64，但是可以借鉴librtmpiOS：https://github.com/saiten/ios-librtmpOpenSSLiOS：https://github.com/x2on/OpenSSL-for-iPhone\n","slug":"音视频编解码中常用的编译脚本","date":"2016-09-08T02:24:33.000Z","categories_index":"音视频开发","tags_index":"","author_index":"William Xie"},{"id":"09b66e066b45ce5ea1b53698890ec7ad","title":"使用fdk-aac将iOS麦克风实时音频流编码为aac文件","content":"　　iOS系统上的音频硬编码器，可实现将pcm音频数据编码为aac格式的数据。但是，对于低码率下的音频编码，就是它的软肋了。通过函数扫描iOS各系统上音频硬编码支持的情况发现，aac-lc编码都是支持的，苹果的官方文档也说的很清楚。对于aac-he-v2编码，iOS现在所有的系统都不支持，aac-he编码需要iOS9.0以上系统才支持音频硬编码。　　做直播的时候，利用iOS的音频硬编码器可以将码率降到80Kb/s，用128Kb/s虽然可以让音质更好，但有点浪费带宽，当主播的网络状况不好时，这就成了一个影响观众流畅观看的一个负面因子，一般选用96Kb/s的码率，这个码率在现今国内网络条件下，还是显得有那么点大。为降低码率同时保证音频音质的情形下，选择合适的编码器才是在有限带宽下优化直播体验的最好武器。　　音频编码器有很多，比如常见的有faac，vo_aacenc，fdk-aac，以及ffmpeg自带的音频编码器。ffmpeg3.0及之后的版本都已经移除了对faac，vo_aacenc的支持，对于ffmpeg3.0之后版本音频编码器的支持情况可以看看它的官网说明，从官网上看，ffmpeg组织建议使用他们的原生native音频编码器，可见，ffmpeg自带的编码器还是不错的。但是，为了一个音频编码功能引入一个这么强壮且庞大的库，有点不划算，虽然可裁剪ffmpeg，也可以将fdk-aac编译进ffmpeg中，但是如果应用中引入了基于ffmpeg开发的播放器的时候，ffmpeg库冲突的情形可能会出现。再说，有比ffmpeg原生音频编码器更好的fdk-aac音频编码器存在，就不需要考虑ffmpeg了，即便用ffmpeg做编码很方便。因为我们是用ffmpeg时间长了，就习惯依赖于ffmpeg了。　　fdk-aac音频编码器用起来也很简单，跟单独用faac差不多，但比faac编码效果好。使用fdk-aac实现了aac-lc，aac-he，aac-he-v2 采样率为44.1KHz，通道数为2（立体声），码率为32Kb/s的aac编码。\nhttp://depthlove.github.io/2016/07/08/use-fdk-aac-encode-iOS-mic-pcm-to-aac/\n","slug":"使用fdk-aac将iOS麦克风实时音频流编码为aac文件","date":"2016-09-07T16:58:20.000Z","categories_index":"音视频开发","tags_index":"fdk-aac,aac","author_index":"William Xie"},{"id":"d5c815160e8fec6a4b0bd832cd6d3ef9","title":"移动端直播应用的开发流程","content":"#推流端\n推流,就是将采集到的音频,视频数据通过流媒体协议发送到流媒体服务器。\n##一、选择流媒体协议\n现在直播应用，采用RTMP协议居多，也有部分使用HLS协议。\n采用RTMP协议，就要看下它与流媒体服务器交互的过程，RTMP协议的默认端口是1935，采用TCP协议。并且需要了解FLV的封装格式。\n采用HLS协议，因为涉及到切片，延时会比较大，需要了解TS流。\n##二、采集音视频数据\n做直播，数据的来源不可缺少，就是采集摄像头，麦克风的数据。iOS平台上采集音视频数据，需要使用AVFoundation.Framework框架，从captureSession会话的回调中获取音频,视频数据。\n##三、硬编码,软编码音视频数据\n软编码利用CPU资源来压缩音视频数据，硬编码与之相反。\n软编码的话，现在广泛采用FFmpeg库结合编码库来实现，FFmpeg+X624来编码视频数据YUV/RGB输出H.264数据,FFmpeg+fdk_aac来编码音频数据PCM输出AAC数据。\n硬编码的话,iOS可以使用VideoToolBox.framework 和 AudioToolBox.framework.\n##四、根据所选流媒体协议封包音视频数据\n将音频编码流,视频编码流打包成packet.\n##五、与服务器交互发送封包数据\n根据所选流媒体协议，发送相应指令连接服务器，连接服务器成功后，就可以发送packet数据了。\n#拉流端\n拉流,就是从流媒体服务器获取音频,视频数据。\n##一、解析协议\n播放器端根据URL解析所用的流媒体协议（RTMP，HLS）。\n##二、解封装\n解封装，就是demux的过程，从容器格式（FLV，TS）中，分离出音视频数据。\n##三、解码\n解码，就是把获取到的数据解压缩，恢复成原始数据。解码就是将H.264变成YUV，AAC变成PCM。\n解码可以使用软解码,硬解码两种方式.\n软解码:\n\n利用CPU资源去解压缩数据，采用的方式是FFmpeg解码。\n\n硬解码:\n\n对于iOS平台来说，可以使用VideoToolbox.Framework（该框架只能在iOS 8.0及以上系统使用）硬解码视频数据。\n\nAndroid平台上，可以使用MediaCodec来硬解码视频数据。\n\n\n##四、渲染数据\n采用OpenGL渲染YUV数据，呈现视频画面。将PCM送入设备的硬件资源播放，产生声音。iOS播放流式音频，使用Audio Queue 的方式，即，利用AudioToolbox.Framework 框架。\n也可以使用Apple 2014年发布的 Metal来渲染 YUV数据.\n原文\n","slug":"移动端直播应用的开发流程","date":"2016-09-07T12:01:52.000Z","categories_index":"音视频开发","tags_index":"","author_index":"William Xie"},{"id":"99c5f55389acbd9de2b2a8aa78d3843c","title":"什么是I帧,P帧,B帧","content":"H.264是新一代的编码标准，以高压缩高质量和支持多种网络的流媒体传输著称，在编码方面，我理解的他的理论依据是：\n参照一段时间内图像的统计结果表明，在相邻几幅图像画面中，一般有差别的像素只有10%以内的点,亮度差值变化不超过2%，而色度差值的变化只有1%以内。所以对于一段变化不大图像画面，我们可以先编码出一个完整的图像帧A，随后的B帧就不编码全部图像，只写入与A帧的差别，这样B帧的大小就只有完整帧的1/10或更小！B帧之后的C帧如果变化不大，我们可以继续以参考B的方式编码C帧，这样循环下去。这段图像我们称为一个序列（序列就是有相同特点的一段数据），当某个图像与之前的图像变化很大，无法参考前面的帧来生成，那我们就结束上一个序列，开始下一段序列，也就是对这个图像生成一个完整帧A1，随后的图像就参考A1生成，只写入与A1的差别内容。\n在H.264协议里定义了三种帧:\n\n完整编码的帧叫I帧，I帧是关键帧；\n参考之前的I帧生成的只包含差异部分编码的帧叫P帧，P帧是前向差别帧；\n还有一种参考前后的帧编码的帧叫B帧，B帧是双向差别帧。\n\nH.264采用的核心算法是帧内压缩和帧间压缩，帧内压缩是生成I帧的算法，帧间压缩是生成B帧和P帧的算法。\n\n#三种帧的说明\nI帧:帧内编码帧 ，I帧表示关键帧，你可以理解为这一帧画面的完整保留；解码时只需要本帧数据就可以完成（因为包含完整画面）\nI帧特点:1.它是一个全帧压缩编码帧。它将全帧图像信息进行JPEG压缩编码及传输;2.解码时仅用I帧的数据就可重构完整图像;3.I帧描述了图像背景和运动主体的详情;4.I帧不需要参考其他画面而生成;5.I帧是P帧和B帧的参考帧(其质量直接影响到同组中以后各帧的质量);6.I帧是帧组GOP的基础帧(第一帧),在一组中只有一个I帧;7.I帧不需要考虑运动矢量;8.I帧所占数据的信息量比较大。\nP帧:前向预测编码帧。P帧表示的是这一帧跟之前的一个关键帧（或P帧）的差别，解码时需要用之前缓存的画面叠加上本帧定义的差别，生成最终画面。（也就是差别帧，P帧没有完整画面数据，只有与前一帧的画面差别的数据）\nP帧的预测与重构:P帧是以I帧为参考帧,在I帧中找出P帧“某点”的预测值和运动矢量,取预测差值和运动矢量一起传送。在接收端根据运动矢量从I帧中找出P帧“某点”的预测值并与差值相加以得到P帧“某点”样值,从而可得到完整的P帧。\nP帧特点:1.P帧是I帧后面相隔1~2帧的编码帧;2.P帧采用运动补偿的方法传送它与前面的I或P帧的差值及运动矢量(预测误差);3.解码时必须将I帧中的预测值与预测误差求和后才能重构完整的P帧图像;4.P帧属于前向预测的帧间编码。它只参考前面最靠近它的I帧或P帧;5.P帧可以是其后面P帧的参考帧,也可以是其前后的B帧的参考帧;6.由于P帧是参考帧,它可能造成解码错误的扩散;7.由于是差值传送,P帧的压缩比较高。\nB帧:双向预测内插编码帧。B帧是双向差别帧，也就是B帧记录的是本帧与前后帧的差别（具体比较复杂，有4种情况，但我这样说简单些），换言之，要解码B帧，不仅要取得之前的缓存画面，还要解码之后的画面，通过前后画面的与本帧数据的叠加取得最终的画面。B帧压缩率高，但是解码时CPU会比较累。\nB帧的预测与重构\nB帧以前面的I或P帧和后面的P帧为参考帧,“找出”B帧“某点”的预测值和两个运动矢量,并取预测差值和运动矢量传送。接收端根据运动矢量在两个参考帧中“找出(算出)”预测值并与差值求和,得到B帧“某点”样值,从而可得到完整的B帧。\nB帧特点1.B帧是由前面的I或P帧和后面的P帧来进行预测的;2.B帧传送的是它与前面的I或P帧和后面的P帧之间的预测误差及运动矢量;3.B帧是双向预测编码帧;4.B帧压缩比最高,因为它只反映丙参考帧间运动主体的变化情况,预测比较准确;5.B帧不是参考帧,不会造成解码错误的扩散。\n注:I、B、P各帧是根据压缩算法的需要，是人为定义的,它们都是实实在在的物理帧。一般来说，I帧的压缩率是7（跟JPG差不多），P帧是20，B帧可以达到50。可见使用B帧能节省大量空间，节省出来的空间可以用来保存多一些I帧，这样在相同码率下，可以提供更好的画质。\n#序列的说明\n在H.264中图像以序列为单位进行组织，一个序列是一段图像编码后的数据流，以I帧开始，到下一个I帧结束。\n一个序列的第一个图像叫做 IDR 图像（立即刷新图像），IDR 图像都是 I 帧图像。H.264 引入 IDR 图像是为了解码的重同步，当解码器解码到 IDR 图像时，立即将参考帧队列清空，将已解码的数据全部输出或抛弃，重新查找参数集，开始一个新的序列。这样，如果前一个序列出现重大错误，在这里可以获得重新同步的机会。IDR图像之后的图像永远不会使用IDR之前的图像的数据来解码。\n一个序列就是一段内容差异不太大的图像编码后生成的一串数据流。当运动变化比较少时，一个序列可以很长，因为运动变化少就代表图像画面的内容变动很小，所以就可以编一个I帧，然后一直P帧、B帧了。当运动变化多时，可能一个序列就比较短了，比如就包含一个I帧和3、4个P帧。\n视频压缩中，每帧代表一幅静止的图像。而在实际压缩时，会采取各种算法减少数据的容量，其中IPB就是最常见的。\n简单地说，I帧是关键帧，属于帧内压缩。就是和AVI的压缩是一样的。 P是向前搜索的意思。B是双向搜索。他们都是基于I帧来压缩数据。\n从上面的解释看，我们知道I和P的解码算法比较简单，资源占用也比较少，I只要自己完成就行了，P呢，也只需要解码器把前一个画面缓存一下，遇到P时就使用之前缓存的画面就好了，如果视频流只有I和P，解码器可以不管后面的数据，边读边解码，线性前进，大家很舒服。\n但网络上的电影很多都采用了B帧，因为B帧记录的是前后帧的差别，比P帧能节约更多的空间，但这样一来，文件小了，解码器就麻烦了，因为在解码时，不仅要用之前缓存的画面，还要知道下一个I或者P的画面（也就是说要预读预解码），而且，B帧不能简单地丢掉，因为B帧其实也包含了画面信息，如果简单丢掉，并用之前的画面简单重复，就会造成画面卡（其实就是丢帧了），并且由于网络上的电影为了节约空间，往往使用相当多的B帧，B帧用的多，对不支持B帧的播放器就造成更大的困扰，画面也就越卡。\n一般平均来说，I的压缩率是7（跟JPG差不多），P是20，B可以达到50，可见使用B帧能节省大量空间，节省出来的空间可以用来保存多一些I帧，这样在相同码率下，可以提供更好的画质。\n下面举例说明：\n在如上图中，GOP (Group of Pictures)长度为13，S0S7 表示 8个视点，T0T12 为 GOP的 13个时刻。每个 GOP包含帧数为视点数 GOP 长度的乘积。在该图中一个 GOP 中，包含94 个 B帧。B 帧占一个 GOP 总帧数的 90.38%。GOP 越长，B 帧所占比例更高，编码的率失真性能越高。下图测试序列 Race1 在不同 GOP 下的率失真性能对比。\n\n率失真理论是用信息论的基本观点和方法研究数据压缩问题的理论，又称限失真信源编码理论。率失真理论的基本问题可以归结如下：对于一个给定的信源分布与失真度量，在特定的码率下能达到的最小期望失真；或者为了满足一定的失真限制，最小描述码率可以是多少。\n率失真理论的名称来源于信息速率失真函数，率失真理论包含两个中心内容：一是率失真函数或失真率函数，二是限失真编码定理。这就是针对不同的信源．不同的失真量度和不同信源概率分布计算率失真函数和证明相应的限失真编码定理。\n#压缩算法的说明\nh264的压缩方法:\n1.分组:把几帧图像分为一组(GOP，也就是一个序列),为防止运动变化,帧数不宜取多。\n2.定义帧:将每组内各帧图像定义为三种类型,即I帧、B帧和P帧;\n3.预测帧:以I帧做为基础帧,以I帧预测P帧,再由I帧和P帧预测B帧;\n4.数据传输:最后将I帧数据与预测的差值信息进行存储和传输。\n帧内（Intraframe）压缩也称为空间压缩（Spatial compression）。当压缩一帧图像时，仅考虑本帧的数据而不考虑相邻帧之间的冗余信息，这实际上与静态图像压缩类似。帧内一般采用有损压缩算法，由于帧内压缩是编码一个完整的图像，所以可以独立的解码、显示。帧内压缩一般达不到很高的压缩，跟编码jpeg差不多。　　帧间（Interframe）压缩的原理是：相邻几帧的数据有很大的相关性，或者说前后两帧信息变化很小的特点。也即连续的视频其相邻帧之间具有冗余信息,根据这一特性，压缩相邻帧之间的冗余量就可以进一步提高压缩量，减小压缩比。帧间压缩也称为时间压缩（Temporal compression），它通过比较时间轴上不同帧之间的数据进行压缩。帧间压缩一般是无损的。帧差值（Frame differencing）算法是一种典型的时间压缩法，它通过比较本帧与相邻帧之间的差异，仅记录本帧与其相邻帧的差值，这样可以大大减少数据量。\n顺便说下有损（Lossy ）压缩和无损（Lossy less）压缩。无损压缩也即压缩前和解压缩后的数据完全一致。多数的无损压缩都采用RLE行程编码算法。有损压缩意味着解压缩后的数据与压缩前的数据不一致。在压缩的过程中要丢失一些人眼和人耳所不敏感的图像或音频信息,而且丢失的信息不可恢复。几乎所有高压缩的算法都采用有损压缩,这样才能达到低数据率的目标。丢失的数据率与压缩比有关,压缩比越小，丢失的数据越多,解压缩后的效果一般越差。此外,某些有损压缩算法采用多次重复压缩的方式,这样还会引起额外的数据丢失。\nhttp://blog.csdn.net/abcjennifer/article/details/6577934\nhttp://blog.sina.com.cn/s/blog_8fb8cd4801018yyo.html\n","slug":"什么是I帧-P帧-B帧","date":"2016-09-07T05:53:44.000Z","categories_index":"音视频开发","tags_index":"H.264","author_index":"William Xie"},{"id":"f98bfd8cdd720319e10a130f228835a6","title":"硬编码和软编码","content":"一、软编码和硬编码如何区分\n   软编码：使用CPU进行编码\n\n   硬编码：使用非CPU进行编码，如显卡GPU、专用的DSP、FPGA、ASIC芯片等\n\n二、软编码和硬编码比较\n   软编码：实现直接、简单，参数调整方便，升级易，但CPU负载重，性能较硬编码低，低码率下质量通常比硬编码要好一点。\n\n   硬编码：性能高，低码率下通常质量低于硬编码器，但部分产品在GPU硬件平台移植了优秀的软编码算法（如X264）的，质量基本等同于软编码。\n\n三、目前的主流GPU加速平台\n   Intel、AMD、NVIDIA\n\n四、目前主流的GPU平台开发框架\n   CUDA：NVIDIA的封闭编程框架，通过框架可以调用GPU计算资源\n\n   AMD APP：AMD为自己的GPU提出的一套通用并行编程框架，标准开放，通过在CPU、GPU同时支持OpenCL框架，进行计算力融合。\n\n   OpenCL：开放计算语言，为异构平台编写程序的该框架，异构平台可包含CPU、GPU以及其他计算处理器，目标是使相同的运算能支持不同平台硬件加速。\n\n   Inel QuickSync：集成于Intel显卡中的专用视频编解码模块。\n\n","slug":"硬编码和软编码","date":"2016-09-07T03:52:41.000Z","categories_index":"音视频开发","tags_index":"","author_index":"William Xie"},{"id":"e063fda3f88056271b7d1721268262c4","title":"音视频知识汇总","content":"\n","slug":"音视频知识汇总","date":"2016-09-07T03:49:46.000Z","categories_index":"","tags_index":"","author_index":"William Xie"},{"id":"9bc13655b85b118e29cc3bcc05240638","title":"深入理解iOS开发中的BitCode功能","content":"#前言\n做iOS开发的朋友们都知道,目前最新的Xcode7,新建项目默认就打开了bitcode设置.而且大部分开发者都被这个突如其来的bitcode功能给坑过导致项目编译失败,而这些因为bitcode而编译失败的的项目都有一个共同点,就是链接了第三方二进制的库或者框架,而这些框架或者库恰好没有包含bitcode的东西(暂且称为东西),从而导致项目编译不成功.所以每当遇到这个情况时候大部分人都是直接设置Xcode关闭bitcode功能,全部不生成bitcode.也不去深究这一开关背后隐藏的原理.中枪的请点个赞.\nLLVM是目前苹果采用的编译器工具链,Bitcode是LLVM编译器的中间代码的一种编码,LLVM的前端可以理解为C/C++/OC/Swift等编程语言,LLVM的后端可以理解为各个芯片平台上的汇编指令或者可执行机器指令数据,那么,BitCode就是位于这两者直接的中间码. LLVM的编译工作原理是前端负责把项目程序源代码翻译成Bitcode中间码,然后再根据不同目标机器芯片平台转换为相应的汇编指令以及翻译为机器码.这样设计就可以让LLVM成为了一个编译器架构,可以轻而易举的在LLVM架构之上发明新的语言(前端),以及在LLVM架构下面支持新的CPU(后端)指令输出,虽然Bitcode仅仅只是一个中间码不能在任何平台上运行,但是它可以转化为任何被支持的CPU架构,包括现在还没被发明的CPU架构,也就是说现在打开Bitcode功能提交一个App到应用商店,以后如果苹果新出了一款手机并CPU也是全新设计的,在苹果后台服务器一样可以从这个App的Bitcode开始编译转化为新CPU上的可执行程序,可供新手机用户下载运行这个App.\n\n#历史回顾\n在iPhone出来之前,苹果主要的编译器技术是用经过稍微改进的GCC工具链来把Objective-C语言编写的代码编译出所指定的机器处理器上原生的可执行程序.编译器产生的可执行程序叫做”Fat Binaries”–类似于Windows下PE格式的exe和Linux下的ELF格式的二进制,不同的是,一个”Fat Binary”可以包含同一个程序的很多版本,所以同一个可执行文件可以在不同的处理器上运行.主要就是这个技术让苹果的硬件很容易的从PowerPC迁移到PowerPC64的处理器,以及后来再迁移到Intel和Intel64处理器.这个方案带来的负面影响就是同一个文件中存了多份可执行代码,除了当前机器可执行的那一份之外其他都是无用的,白占空间. 这个在市场上被称为”Universal Binary”,在苹果从PowerPC迁移到Intel处理器的事情开始存在的(一个二进制文件既包含一份PowerPC版本和一份Intel版本).慢慢的后来又支持同时包含Intel 32bit和Intel 64bit. 在一个Fat binary中,又操作系统运行时根据处理器类型动态选择正确的二进制版本来运行,但是应用程序要支持不同平台的处理器的话,应用程序本身要多占用一些空间.当然也有一些瘦身的工具,比如lipo,可以用来移除fat binary中那些当前机器中不被支持的或者多余的可执行代码达到瘦身目的,lipo不会改变程序执行逻辑,仅仅只是文件的大小瘦身.\n#编译器现状\n随着移动设备移动互联网的深入发展,现在移动设备中的程序大小变得越来越重要了,主要是因为移动设备中不会有电脑上那么大的一个硬盘驱动器.还有就是苹果早就从原始的ARM处理器迁移到自家设计的A4,A5,A5X,A6,A7,A8,A8X,A9,A9X以及后续的A10处理器,他们的指令集已经发生了改变和原始ARM设计的有所区别,所有的这些变化都被iOS操作系统底层以及Xcode/LLVM编译工具向上层程序员一定程度的透明了,编译出来的程序会包含很多执行代码版本.当面对这个问题后,苹果投入大量成本迁移到LLVM编译器架构并使用bitcode的必要性越来越大.从最开始的把OPENGL编译为特定的GPU指令到把Clang编译器(LLCM的C/OC编译前端)支持Objective-C的改进并作为Xcode的默认编译器.\nLLVM提供了一个虚拟指令集机制,它可以翻译出指定的所支持的处理器架构的执行代码(机器码).这个就使得为iOS应用程序的编译开发一个完全基于LLVM架构的工具链成为可能.而LLVM的这个虚拟的通用的指令集可以用很多种表示格式:\n\n叫做IR的文本表示的汇编格式(像汇编语言);\n转换为二进制数据表示的格式(像目标代码),这个二进制格式就是我们所说的bitcode.\n\nBitcode和传统的可执行指令集不同,他维护的是函数功能的类型和签名,比如,传统可执行指令集中,一系列(&lt;=8)的布尔值可以压缩存储到单个字节中,但是在bitcode中他们是各自独自表示的.此外,逻辑运算操作(比如寄存器清零操作)也由他们对应的逻辑表示方法($R=0);当这些BitCode要转换为特定机器平台的指令集时,他可以用经过针对特定机器平台优化过的汇编指令来代替:xor eax, eax.(这个汇编指令同样是寄存器清零操作).\n然而bitcode他也不是完全独立于处理器平台和调用约定的.寄存器的大小在指令集中是一个相当重要的特性,众所周知,64bit寄存器可以比32bit寄存器存储更多的数据,生成64bit平台的bitcode和32bit平台的bitcode是明显不同的,还有,调用约定可以根据函数定义或者函数调用来定义,这些可以确定函数的参数传递是传寄存器值呢还是压栈. 一些编程语言还有一些像sizeof(long)这样的预处理指令,这些将在bitcode生成之前前被翻译.一般情况下,对于支持fastcc(fast calling convention)调用的64bit平台会生成与其一致的bitcode代码.\n#苹果的要求\n到此,让我们思考一下,为什么苹果默认要求watchOS和tvOS的App要上传bitcode? 因为把bitcode上传到他自己的中心服务器后,他可以为目标安装App的设备进行优化二进制,减小安装包的下载大小,当然iOS开发者也可以上传多个版本而不是打包到单个包里,但是这样会占用更多的存储空间. 最重要的是允许苹果可以在后台服务器对应用程序进行签名,而不用导出任何密钥到终端开发者那.\n上传到服务器的bitcode给苹果带来更好处是: 以后新设计了新指令集的新CPU,可以继续从这份bitcode开始编译出新CPU上执行的可执行文件,以供用户下载安装. 但是bitcode给开发者带来的不便之处就是: 没用bitcode之前,当应用程序奔溃后,开发者可以根据获取的的奔溃日志再配上上传到苹果服务器的二进制文件的调试符号表信息可以还原程序运行过程到奔溃时后调用栈信息,对问题进行定位排查.但是用了bitcode之后,用户安装的二进制不是开发者这边生成的,而是苹果服务器经过优化后生成的,其对应的调试符号信息丢失了,也就无法进行前面说的还原奔溃现场找原因了.\n目前,watchOS和tvOS应用发布必须上传带bitcode版本的包.iOS应用发布对bitcode的要求是可选的,用户可以在Xcode的项目设置中关闭. 相当于在编译的时候加一个标记:embed-bitcode-marker(调试构建) embed-bitcode(打包/真机构建).这个在clang编译器的参数是-fembed-bitcode,swift编译器的参数是-embed-bitcode.\n#实践出真知\n我们还是应该实际弄两个测试代码进行实践和检验一下比较好.做两次测试,第一次准备两个C语言源代码继续测试;第二次把其中一个转变为汇编语言源代码后再一个C代码和一个汇编代码一起重复之前的测试步骤进行对比校验差异.\n1 . 如下两个全部是Objective-C代码:test.m :\n#import &lt;Foundation&#x2F;Foundation.h&gt;\nvoid greeting(void)\n&#123;\nNSLog(@&quot;hello world!&quot;);\n&#125;\n\ndemo.m :\n#import &lt;Foundation&#x2F;Foundation.h&gt;\nvoid demo(void)\n&#123;\nNSLog(@&quot;demo func&quot;);\n&#125;\n\n用Clang编译成 ARM64 格式且带bitcode的目标文件test.o demo.o:\nwuqiong: apple$ xcrun -sdk iphoneos clang -arch arm64 -fembed-bitcode -c test.m demo.m\n\n然后把两个目标文件打包为一个静态库文件:\nwuqiong: apple$ xcrun -sdk iphoneos ar  -r libTest.a test.o demo.o\nar: creating archive libTest.a\n\n用Shell命令otool查看目标文件中是否包含bitcode段:\nwuqiong: apple$ otool -l test.o |grep bitcode\n  sectname __bitcode\n  sectname __bitcode\n\n如果看到输出了2行sectname __bitcode,就是说明这静态库中的两个目标文件包含了bitcode.\n2.下面把其中一个demo.m换成汇编语言再参与编译:用下面的命令把demo.m的C代码转换为ARM64汇编语言格式demo.s:\nwuqiong: apple$ xcrun -sdk iphoneos clang -arch arm64 -S demo.m\nwuqiong: apple$ cat demo.s\n.section    __TEXT,__text,regular,pure_instructions\n.ios_version_min 9, 2\n.globl  _demo\n.align  2\n_demo:                                  ; @demo\n.cfi_startproc\n; BB#0:\nstp x29, x30, [sp, #-16]()!\nmov  x29, sp\nLtmp0:\n.cfi_def_cfa w29, 16\nLtmp1:\n.cfi_offset w30, -8\nLtmp2:\n.cfi_offset w29, -16\nadrp    x0, L__unnamed_cfstring_@PAGE\nadd x0, x0, L__unnamed_cfstring_@PAGEOFF\nbl  _NSLog\nldp x29, x30, [sp](), #16\nret\n.cfi_endproc\n\n.section    __TEXT,__cstring,cstring_literals\nL_.str:                                 ; @.str\n.asciz  \"demo func\"\n\n.section    __DATA,__cfstring\n.align  4                       ; @_unnamed_cfstring_ L__unnamed_cfstring_:\n.quad   ___CFConstantStringClassReference\n.long   1992                    ; 0x7c8\n.space  4\n.quad   L_.str\n.quad   9                       ; 0x9\n\n.section    __DATA,__objc_imageinfo,regular,no_dead_strip\nL_OBJC_IMAGE_INFO:\n.long   0\n.long   0\n\n\n.subsections_via_symbol\n\n然后删除demo.m这个C源代码,仅留下test.m和demo.s:\nwuqiong: apple$ rm demo.m\n\n现在,我们来把test.m这个C源代码和dmeo.s这个汇编源代码来一起带着-fembed-bitcode参数来生成目标代码并打包为一个静态库:\nwuqiong: apple$ xcrun -sdk iphoneos clang -arch arm64 -fembed-bitcode -c test.m demo.s\nwuqiong: apple$ xcrun -sdk iphoneos ar -r libTest.a test.o demo.o\n然后我们再运行otool工具来检查这个新的静态库中包含的2个目标文件是否都带有bitcode段:\nwuqiong: apple$ ar -t libTest.a\n__.SYMDEF SORTED\ntest.o\ndemo.o\nwuqiong: apple$ otool -l libTest.a | grep bitcode\n  sectname __bitcode\n很意外,这一次,只有一行sectname __bitcode输出,这就说明这两个目标文件,有一个不带有bitcode段,哪怕我们在编译的时候指定了参数-fembed-bitcode也没有用.至于具体是哪一个不带bitcode段,我们肯定知道就是那个从ARM64汇编语言编译过来的目标文件不带.\n那么就得出一个结论,bitcode的生成,是由汇编语言以上的上层语言编译而来,和最前面所说的那样,他是上层语言与汇编语言(机器语言)之间的一个中间码.\n目前我们日常的iOS应用开发中,一般不会需要用到汇编层面去优化的代码.所以我们主要关注第三方(开源)C代码,尤其是音视频编码解码这些计算密集型项目代码,关键计算的代码针对特定平台都有对应平台的汇编版本实现,当然也有C的实现,但是默认编译一般都是用的汇编版本,这样就会导致我们在编译这个开源代码的时候哪怕你带了-fembed-bitcode参数也仅仅只是让项目中的部分C代码的目标文件带了bitcode段,而那小数的汇编代码的目标文件一样不带bitcode段,这样编译出这个库交给上层开发者使用的时候,就会出现在打包上传或者真机调试的时候因为Xcode默认开了bitcode功能而链接失败,导致不能真机调试或者不能上传应用到AppStore.\n#此文之初衷\n最近在辅导我戴维营战友们做手机音视频直播的App,调试的时候手机采集音视频,视频用h264编码,音频采用aac编码,通过RTMP协议往斗鱼直播频道发布媒体流,项目需要用FFMPEG和libx264两个开源项目,在编译为iOS框架库提供给学生用的时候,他们遇到了bitcode的问题,虽然可以采取直接关闭bitcode来避免错误,但是战友的求知欲必须满足,格物致知,必须让其知其究竟.\nlibx264是VideoLan基金会管理的一个视频编解码的开源项目,其大量使用了各个平台的多媒体汇编指令进行了优化,在编译为不带bitcode的库的时候,完全按官方autotools编译方法是没有任何问题的;编译全带bitcode的库的时候我们不得不关闭汇编优化,在执行./configure阶段可以加上--disable-asm参数来禁用汇编.但是,这个选项在configure脚本中的实现机制有问题.导致其仍然调用了汇编的函数,但是汇编的代码却没有编译进去,从而会导致项目为真机构建和打包的链接阶段会爆出找不到符号的错误,这样就不能做到两全其美.出于轻微程度的强迫症影响,故把之前的FFMPEG和libx264项目的编译脚本进行了改进和打补丁.目前已经可以做到一键编译出带全部bitcode的FFMPEG和libx264的框架了.\nFFmpeg需要依赖libx264.\n\n自动编译脚本项目位置放在github: https://github.com/Diveinedu-CN/FFmpeg-iOS-build-script.git\n由于时间和篇幅原因,关于其他更多详细的信息就不细细道来了.\n戴维营教育Slogan: Dive in education!\n更多iOS开发精品文章：戴维营技术博客\n","slug":"深入理解iOS开发中的BitCode功能","date":"2016-09-06T10:16:31.000Z","categories_index":"iOS SDK","tags_index":"","author_index":"William Xie"},{"id":"ca65ea460ee6b214bff2c8c575c2c6e9","title":"从零开始搭建Cydia软件源","content":"http://bbs.feng.com/read-htm-tid-669283.html\n\n\n\nCydia中的软件源地址保存在 /etc/apt/sources.list.d/ 目录下，分为两种： \n\n以软件包形式安装的软件源，如Cydia默认的软件源，Modmyi、BigBoss等，该类软件源是以独立的.list文件记录软件源地址。 \n由用户在Cydia里输入地址添加的软件源，该类软件源全部保存在 cydia.list中。 \n\n以上两种形式的软件源本质没有差别，但只软件源的文件存放位置上是有不同的。以Saurik自己的软件源为例。打开 saurik.list文件， 可以看到有以下内容 （以#开头的行属于注释，没有实际用途）deb http://apt.saurik.com/ tangelo-3.7 main\n那么，软件源的 Release 文件的地址是 http://apt.saurik.com/dists/tangelo-3.7/ReleaseCydia就是通过或许Release文件进而检测软件源的存在，然后再下载记录软件包相关信息的 Packages 文件。 \n而对于在Cydia中输入软件源地址进行添加的这种源，方法有些不同。因为默认情况下，输入地址以后，Cydia会认为Release文件存放于输入的地址所在的目录下。在list文件中的记录信息为：deb http://www.xxx.com ./\n并不会继续往子目录里检测Release文件。 \n因此，搭建Cydia软件源首先需要配置服务器上相关目录和文件的存放位置。 \n取决于软件源的添加方式，文件/目录的路径设置可以分为以下两种情况： \n\n 只公布软件源的地址，让用户手动输入地址来添加。这种方式的文件/目录设置最为简单。以威锋源为例，威锋源的地址为http://app.weiphone.com/cydia那么在郁闷app.weiphone.com下，存在目录cydia。目录cydia即使软件源所在的目录。将文件Release放置在cydia目录下即完成了软件源的搭建。要注意，搭建软件源，必须保证至少有Release和Packages两个文件。 \n\n以软件包的形式安装，即直接在 /etc/apt/source.list.d/ 目录以文件的形式添加，那么这个就没有什么固定的位置了。基本上仿照Saurik和BigBoss的list文件的格式即可。list文件格式：\ndo not edit this file to add your own custom sourcesthis file is subject to be upgraded as part of a packageeither add your own .list file to /etc/apt/sources.list.dor add your entry to the global /etc/apt/sources.list filedeb 软件源地址 项目名 类型复制代码\n\n\n文件名任意 \n其中，Release文件应放置于 软件源地址/项目名/ 这个目录下，Packages文件放置位置由Release文件来决定（详情见后文）。 \n之前提到过，搭建软件源必须要有Release和Packages两个文件。前者的作用是记录软件源本身的相关信息，而后者的作用则是记录具体软件包的存放位置和安装信息等数据。 \n以下是Release文件的格式：Origin: BigBossLabel: BigBossSuite: stableVersion: 1.0Codename: BigBossSupport: http://cydia.saurik.com/support/*Architectures: darwin-arm iphoneos-armComponents: mainDescription: Apps &amp; Themes! We host your apps. Email me.MD5Sum:be8806290d5904cdf45b542706f6a3ad 165020 main/binary-darwin-arm/Packages  03026ac993187b0eecae50466f64fb3c 35049 main/binary-darwin-arm/Packages.gz  93091f5ca485e066d5fc32ca1327830c 3031061 main/binary-iphoneos-arm/Packages  d7aec18dee5b627339b77a9d91e3f*** 368222 main/binary-iphoneos-arm/Packages.bz2\n其中红字部分是必填内容，紫色部分是可选内容。 \n每项的作用：\n必须Origin: 软件源名称，可以使用中文（Cydia的软件源列表中显示的标题）Label:  同上，也可以使用中文Suite: 软件源的类型，比如正式源，测试源等，可以分别用stable, beta, unstable等来表示，一般填stable就可以了Version: 版本号，这个其实不重要，随便填，一般都是写1.0Codename: 代码代号，比如BigBoss的就写BigBoss，威锋的就写WeiPhone，也没什么限制，只能用英文Architectures: 结构。iPhone平台统一写iphoneos-armComponents: mainDescription: 软件介绍，可以使用中文和html代码，具体能使用哪些代码在下面会介绍。可选Support: 支持，没什么作用，除非特别需要，否则可以不要这个。MD5Sum: 不是必须的，但如果Packages文件位置不与Release文件在同一目录下，则必须有此项。另外，如果需要签名Release文件，也必须有这个。关于MD5Sum的格式，在下文也会介绍。 \nDescription格式显示在Cydia中每个软件页面最下方。不能直接换行，如果要实现显示换行显示，可以使用&lt;br&gt;代码。要加粗显示，可以使用&lt;strong&gt;&lt;/strong&gt;代码可以使用html代码设置字体颜色。不能使用超链接代码。 \n代码：Description: WeiPhone-威锋网为您提供iPhone所需软件/补丁。&lt;br&gt;&lt;br&gt;联系我们: &lt;strong&gt;weip.com@ gmail.com&lt;/strong&gt;实际显示效果如下：\nMD5Sum格式MD5Sum是用来记录Packages即相关文件的文件大小，存放路径和MD5值。 \nMD5Sum: 之后另起一行，开头要空一格（论坛里用quote或code代码之后都不显示开头的空格） \n每行格式是：空格+文件MD5值+空格+文件大小(以字节为单位)+文件路径 （全部没有+） \n而文件路径的格式则有文件存放位置来决定。 \n如果是没有设置Release文件的路径，那么Release和Packages同在根目录，则路径为 Packages，直接就是文件名，没有其它路径。 \n如果在之前设置了Release文件的路径，如Saurik和BigBoss，那么Packages 的路径为 main/binary-iphoneos-arm/Packages，起始文件夹，即main，要与Release文件同在一个目录下。main和binary-iphoneos-arm要与Releases中的对应信息相匹配。 \n对于Packages.gz和Packages.bz2，格式相同，也记得要另起一行。 \n因此，Packages文件的保存位置就是 软件源地址/dists/main/Codename（与Release文件中一致）/main/binary-iphoneos-arm下。 \nRelease文件的示例可以参看以下几个地址：http://app.weiphone.com/cydia/Releasehttp://apt.saurik.com/dists/tangelo-3.7/Releasehttp://apt.bigboss.us.com/repofiles/cydia/dists/stable/Release\n以下是生成Packages文件的方法：Packages文件格式Package: 3proxyVersion: 0.5.3k-2Architecture: iphoneos-armMaintainer: Jay Freeman (saurik) &lt;&#x73;&#97;&#117;&#114;&#105;&#x6b;&#x40;&#115;&#x61;&#117;&#x72;&#105;&#107;&#46;&#x63;&#x6f;&#109;&gt;Installed-Size: 1208Filename: debs/3proxy_0.5.3k-2_iphoneos-arm.debSize: 416318MD5sum: f84cb6764a9df30ab326c17f51de15fdSection: NetworkingPriority: optionalHomepage: http://3proxy.ru/download/Description: tiny free proxy serverName: 3proxyDepiction: http://cydia.saurik.com/info/3proxy/Tag: purpose::daemon, role::hacker复制代码\nPackages实质上是deb文件的control信息集合，另外多了deb文件本身的信息。（control文件是记录软件包本身的信息，但没有deb文件本身） \n多出的deb文件信息为：[li]Filename（deb文件位置与文件名）[/li][li]Size（deb文件大小，字节为单位）[/li][li]MD5sum（deb文件MD5值）[/li]\n要保证Cydia能正确获取deb的相关数据，除了以上3个deb文件信息以为，还必须保证至少有以下两项：[li]Package（软件标识符，相当于***号码，用于识别唯一的软件）[/li][li]Version（软件版本号）[/li]\n这里重点关注的是Filename。Filename项决定了在服务器上deb文件的存放位置。如果没有上级目录，即deb文件和Packages文件处于同一目录，那么只需要一个单独的文件名就可以了，不需要加上目录名，即xxxx.deb。但这样在软件数量多的时候会导致管理上的混乱。假设deb文件存放在debs目录下，那么Filename就应该是 debs/xxx.deb 这样的格式。 \n其余项会在二楼deb制作教程中介绍。 \n一个软件包的全部信息在Packages文件中是以连续的一段存在，每一行是不同的信息。不同软件之间以空行做分隔。 \n如何生成Packages文件 \n方法一：\n环境：任何支持dpkg命令的unix系统 \n工具：dpkg及相关组件。[li]iPhone OS（已越狱）：自带dpkg-deb命令，无dpkg-scanpackages命令[/li][li]Debian/Ubuntu：自带dpkg-deb和dpkg-scanpackages命令[/li][li]Fedora: 无dpkg相关命令[/li][li]Mac OS X：无任何dpkg相关命令[/li][li]Windows：非unix系统，无dpkg相关命令[/li]\n以上系统中，Fedora不支持dpkg，也无法通过安装系统组件来支持dpkg，因此Fedora系统不能用于生成Packages文件。 \n而对于Mac OS X系统，本身虽然不支持dpkg，但可以通过安装一个叫 Fink 的软件来获得dpkg命令。Fink 下载页面：http://www.finkproject.org/download/如何安装请见官网说明。 \n对于Windows系统，可以通过安装 Cygwin + dpkg 来获取dpkg命令。Cygwin下载地址： http://www.cygwin.com/setup.exedpkg命令可以直接在Cygwin中获取。但个人不推荐在Windows下使用dpkg，因为Cygwin体积很大，与其安装这个，还不如直接安装个Ubuntu来的简单。 \n各个系统下生成Packages的方法基本一样。 \n最简单的方法是利用dpkg-scanpackages命令来制作Packages文件。 \niPhone OS 不适用（因为没有这个命令） \n[li]将需要发布的deb文件放在一个目录，比如说debs下[/li][li]命令行里进入到debs目录的上级目录[/li][li]执行命令dpkg-scanpackages debs &gt; Packages复制代码，其中debs为deb存放目录。运行该命令可能需要root权限，可以使用root帐户登录，login root 或 su root 或使用sudo[/li][li]Packages存放于当前目录[/li]\n如图所示\n如果指定的文件夹不存在，则提示  dpkg-scanpackages: error: Binary dir ebs not found如果在指定的文件夹内没有deb文件，则提示 Wrote 0 entries to output Packages file. \n注意：Debian/Ubuntu系统下的dpkg-scanpackages命令不会输出Name，Author，Sponsor，Depiction等信息不会自动添加进去，所以需要手动加入这些数据。Mac OS X下无此问题。 \n以dpkg-scanpackages命令来生成Packages文件有一个很大的限制，就是必须保留全部要发布的和已经发布的deb文件，在deb数量多的情况下会浪费大量磁盘空间。 \n因此可以使用改进命令：dpkg-scanpackages debs &gt;&gt; Packages复制代码，这样不会每次都重新生成Packages文件，而是将debs目录下的deb信息添加到已有的Packages文件末尾。在新增软件的时候没什么问题，但如果是软件更新，那么就会出现重复条目的问题，这时候需要手动删除旧的软件包信息。\n方法二\n上面的方法里也提到过，可以直接编辑Packages文件，因此用文本编辑器将相关数据写入Packages也是可以的，只是这样工作量会比较大，但这种方法没有系统的限制，任何系统下，不管有没有dpkg相关命令都可以使用。格式也是一样的，每项之间只要把Packages放在第一个就可以了，其余项没有顺序要求。 \n由于绝大部分数据可以从control里直接复制，需要自己获取的就只有Filename，Size和MD5sum。 \n在Unix系统下，包括Mac OS X和Linux，以及iPhone OS，获取文件大小可以使用命令 ls -l ；获取MD5值可以使用命令 md5sum \n另外，在Windows下要解包deb文件可以使用7-zip，control 文件位于 control.tar.gz 下\n方法三 （2010/03/23更新scandebs脚本）\n生成Packages和Release文件只是最基础的步骤，实际还需要压缩Packages文件，有时候还需要签名Release文件，为了简化操作，我自己写了一个脚本，具有以下功能： \n[li]自动从服务器上获取 Packages 文件，不需要每次都事先准备 [/li][li]自动生成Release文件 [/li][li]自动生成Packages，Packages.bz2和Packages.gz [/li][li]在生成Packages文件之后无需保留deb文件 [/li][li]保留control里的全部信息 [/li][li]不会出现重复条目[/li][li]自动签名Release文件[/li]\nhttp://app.weiphone.com/files/scandebs.tar.gz\n更新记录 (8/11 v1.3)：        1. 修正grep命令精确匹配问题        2. 若不存在debs目录或debs目录下无deb文件，退出        3. 现在可以在Linux和BSD（iPhone和Mac）系统下使用了        4. 其它优化\n更新记录 (5/13 v1.2)：        1. 针对mac系统下无md5sum命令的问题，用openssl md5 FILE来获取文件MD5值        2. 规范control文件格式（强制将Package项放在第一行）        3. 完全自动模式，无需用户在签名Release时输入密码（需自行修改一下脚本，方法见下文）\n更新记录 (3/23 v1.1)：        1. 修正了Release中Packages.gz项的拼写错误        2. 增加参数功能，可以显示帮助，版本号，自选是否签名Release        3. 每次生成Packages时会按Package标识排序\n使用之前需要先修改下脚本（只需修改一次即可）【因为更新过，所以图片所示的行数已不匹配了，但是内容基本还是一样的。】[li]第46行，将wget后的地址改为自己源的Packages的地址\n另外，因为iPhone OS本身没有wget这个命令，可以去Cydia安装一个wget。使用此命令需要联网，否则请事先准备好Packages文件。[/li][li]第132，136，140这三行，将Packages，Packages.bz2和Packages.gz根据需要自己修改（如果需要指定这几个文件的存放位置）\n[/li][li]第151-158行，引号内的内容根据需要自己来修改（此部分用于生成Release文件）  \n[/li][li]第166行，引号内的内容修改为自己的私匙的用户名和密码  \n[/li][li]Ubuntu 用户请注意：Ubuntu下的 GPG 默认开启了use-agent功能，所以在签名Release的时候会弹出一个提示框，而这个提示框根本就没用，所以要禁用。[/li][li]禁用方法：打开 /.gnupg/gpg.conf （表示当前用户）或者直接用命令gedit ~/.gnupg/gpg.conf复制代码搜索 use-agent，将其注释掉（即修改为 #use-agent）[/li]\n使用方法：[li]将scandebs文件放置在任意位置[/li][li]准备debs文件夹，需在scandebs同级目录下[/li][li]将要更新的deb文件放置在debs目录下[/li][li]【可选】将Packages文件放置在scandebs同级目录下（如果需要修改Packages文件中的已有数据）[/li][li]以命令 sh scandebs + 参数 来执行脚本；或 将文件属性设为0755，命令 chmod 0755 scandebs，之后可以直接使用命令 ./scandebs + 参数[/li][li]【可选】如果提示要你输入签名Release文件的密码，输入之[/li][li]得到Packages，Packages.bz2，Packages.gz，Release和Release.gpg【可选】这5或4个文件[/li]\n显示帮助./scandebs -h或./scandebs –help复制代码\n显示版本号./scandebs -v或./scandebs –version复制代码\n不签名Release（无参数）./scandebs复制代码\n使用签名Release功能./scandebs -s或./scandebs –sign复制代码\n手动修改Packages注意事项前面说过，Packages文件可以手动编辑，有时候仅仅需要更改一些字段的内容，如果因为这个要重新打包deb，不一定合算，因此手动编辑Packages可以省下一些工作量。以下是一些注意事项：[li]以下字段不可修改：Package，Version，Size，MD5Sum，Depends，Pre-Depends，Provides，Conflicts，Replaces[/li][li]其余字段可以任意修改，无需与deb里的control一致，因为Cydia本身不是读取的control的数据，而是从Packages中获取数据。[/li][li]修改字段以后，如果以dpkg-scanpackages重新生成Packages，那么修改过的部分会被还原成control里的原始数据。[/li]\n签名Release的方法[li]获取用于签名的GPG密匙（方法见下文）[/li][li]运行命令gpg -abs -r &quot;HuangRui&quot; -o Release.gpg Release复制代码其中引号内的字符串为用于签名的密匙的用户名（用于区分不同的签名密匙）[/li][li]输入密码[/li][li]完成[/li]\n为什么要签名Release虽然不签名Release文件也没什么大的问题，但是签名Release有以下几个用途：[li]解决Cydia刷新出现的  Wrong language code zh-Hans 或 Wrong language code zh-Hant  的问题（当然如果别的源有这个问题的话还是会报错）[/li][li]所有源内的数据均经过验证，确保安全（见图）\n[/li]\n上传至服务器\n[li]将Packages文件压缩为Packages.bz2（压缩格式 bzip2）和Packages.gz（压缩格式：gz） （如果是用的我写的脚本则可省略自己压缩的这一部）[/li][li]修改Release文件（主要是MD5值和文件大小）[/li][li]【可选】签名Release文件，生成Release.gpg[/li][li]将Release，Release.gpg，Packages，Packages.bz2和Packages.gz以及要更新的deb文件上传到服务器指定位置。[/li][li]以上所有文件的属性需设为0755（在ftp上设置）[/li]\n用于签名Release的密匙生成密匙可以看看这个页面 http://keyring.debian.org/creating-key.html\n生成密匙的操作是在命令行下完成，其中还需要有人机交互，所以WinSCP的命令行是不能用的，如果需要使用iPhone来生成密匙，请使用Putty或者其它SSH终端工具来连接。\n运行命令gpg –gen-key复制代码提示Please select what kind of key you want:   (1) DSA and Elgamal (default)   (2) DSA (sign only)   (5) RSA (sign only)Your selection?一般就是1，默认\n回车后RSA keys may be between 1024 and 4096 bits long.What keysize do you want? (2048)输入1024～4096之间的一个数值，数值越大，加密强度越高，但每次加密和解密需要的时间更多。\n我这里输入的是2048Requested keysize is 2048 bits\nPlease specify how long the key should be valid.         0 = key does not expire        = key expires in n days      w = key expires in n weeks      m = key expires in n months      y = key expires in n yearsKey is valid for? (0)Key does not expire at allIs this correct? (y/N) y\n密匙有效时间，一般选0，不会过期。\n问你确认，输入y+回车（小写y，如果要重新做则是大写N）\nReal name:\n输入该密匙所有者的名称，例如 WEIP Tech Team\nEmail address: \n密匙所有者邮件地址，自己输入\nComment： \n注释，怕分不清楚的话可以加点内容进去You are using the `utf-8′ character set.You selected this USER-ID:    “WEIP Tech Team &lt;weip.com@gmail,com&gt;\n继续Change (N)ame, (C)omment, (E)mail or (O)kay/(Q)uit?\n上面输错的话，名字错了就输入N，加上注释就输入C，邮件错误就输入E，不保存退出输入Q，确定输入OYou need a Passphrase to protect your secret key.\n设置密码，该密码在每次使用加密时都要使用，必须牢记。输入时不会明文显示，回车后会要你再输一遍以匹配。\n设完密码之后就自动执行了。\n注意，在结果里面有一句gpg: key 0A02728F marked as ultimately trustedpublic and secret key created and signed.\n这串字符就是所谓的密匙标识了\n如果需要为这个密匙添加另外的使用者，可以用以下命令gpg –edit-key 0x0A02728F复制代码\n密匙前面要加上数字0和字母x\ncommand&gt; 后输入adduid复制代码之后的操作跟前面的一样，不过在要输密码的时候只是要验证身份，不是创建密码。\n最后在command&gt;后输入save复制代码\n假设创建了两个用户，A和B，原本是A拥有最高权限，要改为B拥有最高权限\n执行以下命令：gpg –edit-key 0x0A02728F复制代码\ncommand&gt; 后输入uid 2复制代码\n然后输入Command&gt; primary复制代码\n输入密码后在command&gt;后输入save复制代码\n经过以上操作就成功生成了一个可以用于签名的密匙。\n导出公匙用于加密/签名的是刚刚申请到的私人密匙（Private Key），而要发布的是公匙（Public Key）运行命令gpg –export 0A02728F &gt; weiphone-keyring.gpg复制代码文件名自己决定之后将生成的公匙发布就可以了。导入公匙需要导入公匙的是软件源的用户，下载公匙文件以后，让用户自己运行命令apt-key add weiphone-keyring.gpg复制代码导出私人密匙有时候软件源不是一个人在维护，如果是多个人维护的话可能需要导出私人密匙以共其他人加密/签名。运行命令gpg –export-secret-key -a &quot;User Name&quot; &gt; private.key复制代码User Name是自己在生成密匙的时候输入的用户名，最后生成的文件，文件名随意，但切记，这个密匙不要泄漏出去。导入私人密匙得到私人密匙之后就是导入了，运行命令gpg –allow-secret-key-import –import private.key复制代码密匙管理查看公匙列表apt-key list复制代码或gpg –list-keys复制代码\n当密匙不再使用时，可以删除密匙。删除公匙apt-key del 0A02728F复制代码或gpg –delete-key &quot;User Name&quot;复制代码\n查看私人密匙列表gpg –list-secret-keys复制代码\n删除私人密匙gpg –delete-secret-key &quot;User Name&quot;复制代码\n关于GPG密匙的更多命令，可以看看这个网页（英文）http://irtfweb.ifa.hawaii.edu/~lockhart/gpg/gpg-cs.html\n关于公匙和私匙的介绍：http://www.hudong.com/wiki/\n关于源的搭建，也可以看看Saurik的文章 http://www.saurik.com/id/7\n最后再附送点其它东西。\n要在Cydia中显示源的图标或者分类图标，只要将图标文件放到Cydia的目录下即可。\n源的图标文件名为 域名.png，比如威锋源的地址为http://app.weiphone.com/cydia，那么图标文件名应为app.weiphone.com.png，该文件需位于 /Applications/Cydia.app/Sources/ 下，图标分辨率为60 × 60\n分类图标需位于 /Applications/Cydia.app/Ssctions/ 下，文件名有一定要求。一般来说文件名跟分类名一致就可以了，但也有例外。以威锋源为例，分类 [2.x] 所对应的图标文件名应为 2.x.png，没有方括号，但其它的就要有方括号。另外，一定要注意大小写的匹配，文件名编码须为UTF-8。\n制作软件源的安装包，这里就直接提供威锋源的安装包了。  com.weiphone.source_1.2_iphoneos-arm.deb (78 KB, 下载次数: 838) \n重点：\n\nlist文件 /etc/apt/sources.list.d/weiphone.list\ndo not edit this file to add your own custom sourcesthis file is subject to be upgraded as part of a packageeither add your own .list file to /etc/apt/sources.list.dor add your entry to the global /etc/apt/sources.list filedeb http://app.weiphone.com/cydia/ ./复制代码\n\n公匙，其实放在哪里不重要，但Cydia的所有源的公匙都是放在 /usr/share/keyrings/ 下，所以尽量随主流吧\n\n安装公匙的脚本 postinst或者extrainst_都行，只不过通常都用extrainst_#!/bin/shif [[ $1 == install || $1 == upgrade ]]; then /usr/bin/apt-key add /usr/share/keyrings/weiphone-keyring.gpgfi复制代码记得修改文件名\n\n卸载时删除公匙的脚本，prerm或者postrm都行#!/bin/shif [[ $1 == remove ]]; then /usr/bin/apt-key del BB7EB3EDfi复制代码\n\n\n服务器上文件存放位置，最简单的cydia–           |–debs–*.deb           |–Packages           |–Packages.bz2           |–Packages.gz           |–Release           |–Release.gpg\nCydia Wrong language code zh-Hans 或 Wrong language code zh-Hant 的解释\n其实这个不是错误，而是Cydia本身对中文的支持有问题。而且，这个提示并非是错误提示，实际是属于警告的性质，因为Cydia本身在中文支持上有些问题，但不影响使用，所以会出现警告。该警告的出现与Cydia软件源中是否存在中文无关，而是和系统语言设置有关，该问题只出现在简体中文和繁体中文系统下（不信把系统语言改成非中文的看还会不会出现错误）。\n","slug":"从零开始搭建Cydia软件源","date":"2016-08-26T02:41:41.000Z","categories_index":"iOS逆向工程","tags_index":"Cydia","author_index":"William Xie"},{"id":"24fefc02fc3e261ce5e03d9f1548a430","title":"GitHub Pages 配置域名","content":"可以填www也可以不填也可以填其他你想要的词例如主机记录填 www意思就是访问 www.jianfeiyizhan.com是有效的指向你设置的记录值的.主机记录不填或者填@意思就是访问 jianfeiyizhan.com是指向你记录值的.你也可以设置泛解析 主机记录填 *这样 任何值.jianfeiyizhan.com都指向你设置的记录值#Github Page种类\n\nUserPage: 用户的整个站点, 这个是最出github支持的类型, 创建一个形如username.github.com的项目就可以\n\nProjectPage: 用户创建出来的项目也可以创建站点, 创建一个项目后, 在建立一个名叫gh-pages的branch, 这个branch里的文件就是page的站点文件#UserPage默认域名\n用户站点的默认域名是username.github.io, 比如笔者的站点就是liang8305.github.io\n#ProjectPage默认域名\n项目的默认域名, 是使用UserPage域名加上二级目录实现的, 比如笔者有个项目叫cydia, 那么该项目的站点就是访问 liang8305.github.io/cydia\n#UserPage自定义域名\n我有自己的域名, 如何绑定到UserPage? 比如用www.zhaoxiaodan.com替代liang8305.github.io他是使用CNAME技术来实现的\n具体步骤:\n去域名注册商那里, 做一个CNAME指向, 将www.zhaoxiaodan.com 指向 liang8305.github.io,\n在liang8305/liang8305.github.com这个项目(也就是page项目)根目录下建一个CNAME文件, 里面填写www.zhaoxiaodan.com, 然后提交到仓库;\n等10分钟\nCNAME指向之后, 当浏览器访问www.zhaoxiaodan.com的时候浏览器就知道实际上是访问liang8305.github.io添加CNAME 文件之后, 当GithubPage服务器接收到访问www.zhaoxiaodan.com的http请求, 就知道, 对应的是这个工程了\n#ProjectPage自定义域名\n比如用cydia.zhaoxiaodan.com替代liang8305.github.io/cydia\n同样的, 去域名注册商那里, 做一个CNAME指向, 将cydia.zhaoxiaodan.com 指向 liang8305.github.io, 如果以后会有很多二级域名都指过来, 其实可以做一个模糊二级指过来, 比如*.zhaoxiaodan.com\n在liang8305/cydia这个项目(也就是page项目)根目录下建一个CNAME文件, 里面填写cydia.zhaoxiaodan.com, 然后提交到仓库;\n等10分钟\nhttp://www.zhaoxiaodan.com/其他/如何配置GithubPage的二级域名.html\n","slug":"GitHub-Pages-配置域名","date":"2016-08-25T04:37:31.000Z","categories_index":"","tags_index":"","author_index":"William Xie"},{"id":"8e9cdb3c593732dd87e3620e5e53c7aa","title":"iOS集成ijkplayer播放器框架","content":"","slug":"iOS集成ijkplayer播放器框架","date":"2016-08-24T12:24:45.000Z","categories_index":"音视频开发","tags_index":"ijkplayer","author_index":"William Xie"},{"id":"be9c948da683d2b10fcb2164adbb9d8b","title":"Mac 系统上编译 iOS 可用的FFmpeg 库","content":"原文转载\n1、gas-preprocessor2、yasm 1.2.03、FFmpeg-iOS-build-script（ps:这个脚本真是业界良心呀，帮我们省下了不少心。）\n好了，已经有了，但是怎么优雅的使用出招式呢？慢慢来，博主力求详细的为大家分解每个步骤。\n#1、下载gas-preprocessor\n那么 gas-preprocessor 是什么呢？\ngas-preprocessor 其实就是我们要编译 FFmpeg 的所需脚本文件。\n\n1）我们将其解压后，发现内部只有简单的 4 个文件，如下图：\n\n不难发现其中的 gas-preprocessor.pl，没错，这就是我们要找的刀了，恭喜，你获取了小木剑一把，继续往坑里走少年。\n2）继续将 gas-preprocessor.pl 文件复制到 /usr/sbin/ 目录下（ps：应该会有很多小伙伴发现这个目录是根本没法修改的，那么这种情况下，小伙伴们可以将文件复制到 /usr/local/bin/ 目录下），然后为文件开启可执行权限，打开终端并输入以下命令行：\nchmod 777 /usr/sbin/gas-preprocessor.pl\n\n或\nchmod 777 /usr/local/bin/gas-preprocessor.pl\n\n#2、安装 yasmyasm 又是什么呢？\n\n\n\n\n\n\n\n\n\nYasm是一个完全重写的 NASM 汇编。目前，它支持x86和AMD64指令集，接受NASM和气体汇编语法，产出二进制，ELF32 ， ELF64 ， COFF ， Mach - O的（ 32和64 ），RDOFF2 ，的Win32和Win64对象的格式,并生成STABS 调试信息的来源，DWARF 2 ，CodeView 8格式。\n1）下载yasm上一篇文章博文带大家下载了一个好东西 homebrew，既然是优雅的编译，我们就用最像程序员的东西，命令行了，打开终端，输入如下：\nbrew install yasm\n\n2）检测是否已安装 yasm\nbrew install yasm\n\n如果你成功安装了 yasm，输出如下图：\n\n好了，你获得了隔壁老王内裤一条。额。。让我们继续前进。\n#3、编译FFmpeg-iOS-build-script\n编译FFmpeg-iOS-build-script,得到我们需要的iOS能用的ffmpeg库\n这个脚本有神马用呢？\n不难看出，这个脚本是转为 iOS 编译出可用的 ffmpeg 的库，这个业界良心，我们称之为神的内裤\n好吧，不搞笑，有了这个脚本，我们根本就不用下载 ffmpeg 了，脚本会帮我们下载好最新版本的 ffmpeg，\n并打包成一个 iOS 可用的 ffmpeg 库提供给我们了，当然，前提是你必须要跟着博主一步一步入坑才行喔。\n1）进入我们的 gitHub 网站，把 FFmpeg-iOS-build-script 下载好压缩包。\n2）编译脚本，打包出我们需要的 iOS 的 ffmpeg 库解压 FFmpeg-iOS-build-script 得到的文件如下：\n\n我们目标不是开发 tvos 吧。。那么我们的目标脚本就只剩下 build-ffmpeg.sh 了。打开终端，进入解压后的 FFmpeg-iOS-build-script 文件夹，命令行如下：\ncd 小伙伴们的FFmpeg-iOS-build-script文件夹路径\n\n执行 build-ffmpeg.sh 脚本：\n./build-ffmpeg.sh\n\n当然，官方是有说明的：To build everything:\n./build-ffmpeg.sh\n\nTo build arm64 libraries:\n./build-ffmpeg.sh arm64\n\nTo build fat libraries for armv7 and x86_64 (64-bit simulator):\n./build-ffmpeg.sh armv7 x86_64\n\nTo build fat libraries from separately built thin libraries:\n./build-ffmpeg.sh lipo\n\n好了，执行完命令行后，终端就会拿着这条内裤，在啪啪啪了（编译）。。。这段时间里，你可以去喝杯咖啡慢慢等待，最后得到的文件如下：\n\n小伙伴们不难看到，FFmpeg-iOS 就是我们所需要的文件夹了，看到内部的各种 .a 文件，也就是我们熟悉的静态库了。\n4、集成FFmpeg 库开发工程当中\n1）把 FFmpeg-iOS 直接复制到你的工程目录下\n2）把 FFmpeg-iOS 从你的工程目录下拖到工程当中，最后得到的结果如下图：\n\n3）编译一下，你会发下有错误，哈哈，原因是你没有链接编译文件好，我们进入 Build Setting ，修改 header search Path 链接到工程的 include 文件当中 操作如下：\n\nOK，我们可以在工程当中引入 #import “avformat.h” 文件了，编译 Success\n好了，至此，我们已经成功编译并集成了 ffmpeg 了，但是怎么使用呢？怎么压缩视频，视频压缩视频？怎么实现 h264 编码？怎么将视频/音频推送到流媒体服务器呢？这些都是我们将要说的。\n","slug":"Mac-系统上编译-iOS-可用的FFmpeg-库","date":"2016-08-24T07:32:07.000Z","categories_index":"","tags_index":"FFmpeg","author_index":"William Xie"},{"id":"a8f837f695eb86dad5d7620558fa20f8","title":"iOS 定位以及地图应用","content":"#定位服务\n现在的移动设备大多都提供定位服务功能，使用iOS系统的iPhone,iPod touch和iPad都可以提供位置服务，iOS设备能提供3种不同途径进行定位:\n\nWiFi定位：通过査饰一个wiFi路th器的地理位置的信息，比较省电。iPhoneiPod touch和ipad都可以采用。 \n\n蜂窝式移动电活基站定位：通过移动运用商基站定位。只有iPhone,3G版本的iPod touch和iPad可以采用。 \n\nGPS卫星定位：通过3〜4颗GPS卫星定位，最为准确，但是耗电量大，不能遮挡。 iPhone,iPod Touch和iPad都可以采用。 \n\niBeacon微定位：苹果公司在iOS 7开始支持iBeacon技术，iBeacon技术是苹果研发,它使用低功耗蓝牙技术，通过多个iBeacon基站可以创建一个信号区域（地理围栏) 设备进入该区域时，相应的应用程序便会提示用户进入了这个地理围栏。 \n\n\n\n\n\n\n\n\n\n\n\niOS不像Android系统在定位服务编程时候，可以指定采用哪种途径进行定位。iOS的API把底层这些细节屏蔽掉了，开发人员和用户并不知道现在设备采用哪种方式进行定位,iOS系统会根据设备的情况和周圃的环境，采用一套最佳的解决方案。这个方案是这样:如果能够接收GPS信息，那么设备优先采用GPS定位，否则采用WiFi或蜂窝基站定位。在WiFi和蜂窝基站之间优先使用WiFi，如果无法连接WiFi才使用蜂窝基站定位。\n\n\n##CoreLocation \n#地图服务\n##MapKit\n#Xcode Resource \n##GPX File \nGPX档案格式（GPS Exchange Format）是XML格式的一种，专门用来储存地理资讯。 一个GPX档案当中可能包含一些路点（waypoint）及一些轨迹点（trackpoint）。 以全球定位系统（GPS装置）所产生的GPX档为例， 路点可能是各自独立互不相干的重要标记点， 例如照相的地点或使用者手动标记的休息站或路口等等；至于GPS装置自动定时记录的则是轨迹点。 有顺序的一串轨迹点构成一个轨迹（track）或者路程（route）。轨迹是一个人曾经走过的记录，可能包含走错的路等等；路程则经常是建议未来用路人可以走的路径。所以，一般来讲，轨迹里的点，包含时间信息，路程里的点，则没有时间信息。\nGPX文件内的点，至少要包含经纬度座标两项资讯；其它字段都是可有可无的。\n&lt;?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\" ?>\n&lt;gpx xmlns=\"http://www.topografix.com/GPX/1/1\" creator=\"MyGeoPosition.com\" version=\"1.1\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.topografix.com/GPX/1/1 http://www.topografix.com/GPX/1/1/gpx.xsd\">\n  &lt;wpt lat=\"23.0920790\" lon=\"113.3010790\">\n    &lt;name>中国广州市海珠区滨江路中山大学 邮政编码: 510305&lt;/name>\n    &lt;src>MyGeoPosition.com&lt;/src>\n    &lt;link>http://mygeoposition.com&lt;/link>\n  &lt;/wpt>\n&lt;/gpx>\n\n&lt;wpt&gt;标签中的lat属性设置纬度,lon属性设置经度。一般使用www.mygeoposition.com网站提供的GPX工具.这个网站免费提供地理信息编码和反编码,生成KML和GPX文件等服务.\n可以在KML/GPX 标签下载KML文件或者GPX文件.\n\n\n\n\n\n\n\n\n\n使用方法:\n\n选择Shceme&gt; Run &gt;Options&gt;Default Location &gt; Add GPX File tp Project \n运行项目&gt; Debug Area &gt; Arrow &gt; Add GPX File tp Project \n\n##GeoJSON File\nGeoJSON是一种对各种地理数据结构进行编码的格式。GeoJSON对象可以表示几何、特征或者特征集合。GeoJSON支持下面几何类型：点、线、面、多点、多线、多面和几何集合。GeoJSON里的特征包含一个几何对象和其他属性，特征集合表示一系列特征。\n一个完整的GeoJSON数据结构总是一个（JSON术语里的）对象。在GeoJSON里，对象由名/值对–也称作成员的集合组成。对每个成员来说，名字总是字符串。成员的值要么是字符串、数字、对象、数组，要么是下面文本常量中的一个：”true”,”false”和”null”。数组是由值是上面所说的元素组成。\nGeoJSON格式规范说明\n###Geojson使用\n最近AppStore在上传新应用的时候对于地图类的应用需要上传一个.geojson格式的文件，该文件是对区域作限制的文件，只有在该文件中规定的区域范围内才能下载该应用，否则是不能下载该应用的。\n\n那问题来了，如何才能生成该格式的问价呢?下面我们来看一下如何生成该格式的文件和创建viewcontroller文件方式相同，右键new File 选择Resource第一个就是我们需要的文件如下图。\n\n创建完成后需要在文件中设置支持下载的区域的经纬度坐标，如下：\n&#123;\n   \"type\": \"MultiPolygon\",\n   \"coordinates\": [\n                  [[ [55.06, 55.67], [152.51, 55.67], [152.51, 8.2], [55.06, 8.2], [55.06, 55.67] ]]\n                  ]\n&#125;\n　　注意：　　(1)坐标位置第一个和最后一个必须相同，在这些坐标围成的区域是有效部分。\n\n　　(2)创建geojson文件的时候，文件名必须使用系统默认创建的文件名\n","slug":"iOS-定位以及地图应用","date":"2016-08-21T11:18:05.000Z","categories_index":"iOS SDK","tags_index":"MapKit,CoreLocation","author_index":"William Xie"},{"id":"1199814c7a99dde10c071bb5aa7837b1","title":"iOS 软件测试之 UI Testing","content":"\n\n\n\n\n\n\n\n\n本文译自:iOS9 Day-by-Day :: Day 2 :: UI Testing\n 在任何软件的开发中，自动化UI测试都是很重要的。它能快速发现你应用中的问题，在发布之前进行一次成功的配套测试能减少许多问题。在iOS平台目前是通过UIAutomation来完成自动化测试，它的用例是用JavaScript写的。这需要打开Instruments，在其中编写和运行脚本。这个流程实在是慢得出奇而且要花很长时间来适应。\n#UI Testing\n在Xcode 7 中，Apple引入了一种新的方式来在你的应用中进行UI测试。UI testing允许你找到UI元素并与之交互，还能检查属性和状态。UI testing已经完全集成进Xcode 7 的测试报告了，可以和单元测试一起执行。在Xcode 5 中XCTest就已经集成到Xcode 的测试框架了，而在Xcode 7 中，XCTest已经拥有进行UI测试的能力了。这样你就能在检查UI状态的时候执行断言了。\n\n#Accessibility为了让UI Testing能够工作，框架需要能够访问UI中的各个元素，这样才能执行它们的动作。你可以定义测试要在哪个特定的点进行点击和轻扫，但是这在不同屏幕大小的设备上就不那么好使了，又或者你换算出UI中元素在不同设备上的位置。\n这时候accessibility就派上用场了。Accessibility是Apple很早之前构建的一个框架，它能帮助一些行动不便的用户来更好地使用你的应用。它为你的UI提供了丰富的语义数据，这能让不同的Accessibility功能给行动不便的用户展现你的应用。有很多功能都是现成的，直接就能在你的应用中使用，但是你可以（也应该）使用Accessibility的API来改进Accessibility关于UI的数据。在很多场景下这都是必需的，比如对一些自定义的控件，Accessibility就不清楚你的API要做什么。\nUI Testing可以通过你的应用提供的Accessibility功能来与你的应用连接，这样就解决了设备大小不一的问题。如果你重新调整了UI中的某些元素，你也不用重写整套测试。实现Accessibility不仅是为了使用UI Testing，也能帮助行动不便的用户更好地使用你的应用。\n#UI Recording当设置好可以访问的UI之后，你可能就想创建一些UI测试了。编写UI测试耗时又无聊，如果你的UI比较复杂，那这还有些难度。多亏在Xcode 7中，Apple引入了UI Recording，它能让你创建新的测试，并扩展原有的测试。当UI Recording打开之后，当你在真机或模拟器上与应用交互时，代码会自动生成。现在我们已经大概了解了UI Testing是怎么回事，是时候开始使用它了。\n#创建 UI 测试我们会使用新的UI测试工具构建一个demo来展示UI Testing是怎么工作的。如果你想一起做并看到结果，这有最终完成的demo（Swift 或者Objective-C）。\n##Setup当你在Xcode 7中创建新工程时，可以选择是否要包含UI测试。这会为你设置一个占位的UI Test target，并且配置好了所需的内容。\n\ndemo中的项目设置很简单，但是足够我们展示在Xcode 7中UI Testing是如何工作的了。\n \nmenu view controller 包含一个switch和一个button，button连接到detail view controller。当switch“关闭”时，button应该不可点击，跳转也就不可能发生。detail view controller包含一个button，点击button会增加label中的值。\n#使用 UI Recording当设置好UI并且可用时，我们就可以编写一些UI测试来确保代码的改动不会影响功能。\nThe XCTest UI Testing API\n在我们开始录制动作之前，必须要决定需要断言什么内容。我们可以使用XCTest框架来对UI中的某些内容进行断言，现在框架中已经包含下面三个新API。\n\nXCUIApplication。这是你正在测试的应用的代理。它能让你启动应用，这样你就能执行测试了。它每次都会新起一个进程，这会多花一些时间，但是能保证测试应用时的状态是干净的，这样你需要处理的变量就少了些。\n\nXCUIElement。这是你正在测试的应用中UI元素的代理。每个元素都有类型和标识符，结合二者就能找到应用中的UI元素。所有的元素都会嵌套在代表你的应用的树中。\n\nXCUIElementQuery。 当你想要找到某个元素时，就会用到 element query。每个 XCUIElement 里都包含一个query。这些query搜索 XCUIElement 树， 必须要找到一个匹配的。否则当你视图访问该元素时，测试就会失败。 例外是exists 属性，你可以使用这个属性来检查一个元素是否展示在树中。 这对于断言很有用。 更一般地你可以使用 XCUIElementQuery 来找到对accessibility可见的元素。Query会返回结果的集合。\n\n\n现在我们已经了解了API，可以开始编写一些测试了。\nTest 1 – 确保当switch关闭时不会发生跳转\n首先我们必须要定义一个方法来写测试。\nfunc testTapViewDetailWhenSwitchIsOffDoesNothing() &#123;\n \n&#125;​﻿​\n\n当定义好方法之后，我们把光标移到方法的括号里，然后点击Xcode 窗口下方的录制按钮。\n\n应用会马上启动。点击关闭switch，然后点击“View Detail” 按钮。在testTapViewDetailWhenSwitchIsOffDoesNothing﻿​方法里应该会出现下面的内容。\nlet app = XCUIApplication()\napp.switches[\"View Detail Enabled Switch\"].tap()\napp.buttons[\"View Detail\"].tap()​﻿​\n\n现在再点击录制按钮，录制应该就会停止了。我们可以看到应用没有显示detail view controller，但是目前测试没有办法知道。我们必须加一个断言来判断没有发生跳转。我们可以检测导航栏的title。这可能不适合所有情况，但对我们这个例子来说足够了。\nXCTAssertEqual(app.navigationBars.element.identifier, \"Menu\")\n\n在添加完这行代码之后再次执行测试，应该是能通过的。试着将“Menu”字符串改成“Detail”，应该就失败了。下面就是这个测试的完整代码了，其中添加了一些注释来解释每一步的操作。\nfunc testTapViewDetailWhenSwitchIsOffDoesNothing() &#123;\n    let app = XCUIApplication()\n \n    // Change the switch to off.\n    app.switches[\"View Detail Enabled Switch\"].tap()\n \n    // Tap the view detail button.\n    app.buttons[\"View Detail\"].tap()\n \n    // Verify that nothing has happened and we are still at the menu screen.\n    XCTAssertEqual(app.navigationBars.element.identifier, \"Menu\")\n&#125;﻿​\n\nTest 2 – 确保当switch打开时发生跳转\n第二个测试和第一个类似，所以就不详细讲了。唯一的区别是，当switch打开时，应用应该加载detail页面，XCTAssertEqual会检查这个。\nfunc testTapViewDetailWhenSwitchIsOnNavigatesToDetailViewController() &#123;\n    let app = XCUIApplication()\n \n    // Tap the view detail button.\n    app.buttons[\"View Detail\"].tap()\n \n    // Verify that navigation occurred and we are at the detail screen.\n    XCTAssertEqual(app.navigationBars.element.identifier, \"Detail\")\n&#125;\n\nTest 3 – 确保“Increment Value”按钮会增加label中的值\n在这个测试中，我们要检查当用户点击“Increment Value”按钮，label中的值会增加1。测试中的前两行代码和之前的类似，所以我们可以直接从之前的测试中复制粘贴。\nlet app = XCUIApplication()\n \n  // Tap the view detail button to open the detail page.\n  app.buttons[\"View Detail\"].tap()\n\n下一步我们需要能访问这个button。我们之后要点击几次button，所以我们把它作为一个变量保存下来。与其我们手动输入代码找到这个button，而且还需要调试，不如直接使用录制功能，点击“Increment Value”按钮即可。这样就得到了下面的代码。\napp.buttons[\"Increment Value\"].tap()﻿​\n\n现在我们可以停止录制，把代码改成下面这样的：\nlet incrementButton = app.buttons[\"Increment Value\"]﻿​\n\n这样我们就不用手动输入代码来找这个button了。我们使用同样的方法来找到显示值的label。\nlet valueLabel = app.staticTexts[\"Number Value Label\"]﻿​\n\n现在我们已经有UI元素，就可以和它们交互了。在这个测试中我们会检查点击button十次之后，label的值是否也相应地更新了。我们可以录制十次点击，但是我们之前已经保存这些元素了，所以可以在循环中完成。\nfor index in 0...10 &#123;\n    // Tap the increment value button.\n    incrementButton.tap()\n \n    // Ensure that the value has increased by 1.\n    XCTAssertEqual(valueLabel.value as! String, \"\\(index+1)\")\n&#125; \n\n这三个测试根本算不上全面，但它们应该给你开了一个好头，你可以在这之上很轻松地扩展。你可以自己写一个测试来检查当button可点击时，你能跳转，如果关闭switch，又是否能跳转。\n##录制出错怎么办？\n某些时候，在录制时，当你点击了一个元素，你可能会注意到生成的代码看上去不太对。这通常是因为你正在交互的元素对Accessibility不可见。你可以使用Xcode的Accessibility Inspector来检查是不是这种情况。\n\n当打开Accessibility Inspector之后 ，如果你按下CMD+F7，并把鼠标悬停在模拟器中的元素上，就能看到鼠标指针下面元素的详细信息。这应该能帮助你解决为什么Accessibility找不到你的元素。\n当你解决了问题之后，打开interface builder，在 identity inspector你可以找到Accessibility面板。在这你能打开Accessibility，设置hints,、labels 、identifiers和 traits。这些都是很有用的工具来让Accessibility访问你的界面。\n \n##测试失败怎么办？\n如果一个测试失败了，而你不是很清楚为什么，有一些方法能帮助你解决问题。首先你可以在Xcode的Report Navigator中找到测试报告。\n\n当打开这个界面，鼠标悬停在测试中的某一步，你会在测试事件的右边看到一个小眼睛图标。点击图标，会弹出你的应用在特定步骤的截图。这能让你可视化查看UI的状态，找到到底是哪里出了问题。\n和单元测试一样，在UI测试中你也可以添加断点，这样你就能调试并找到问题。你可以输出view的层级，检测accessibility属性来查看为什么测试会失败。\n#为什么你应该使用 UI Testing？自动化UI测试是提升应用质量的一种很好的方式。我们已经看到了在Xcode中设置、执行UI Testing是多简单，为你的应用添加Accessibility功能不仅能帮助测试你的应用，而且也能帮助行动不便的用户更好地使用你的应用。\nXcode中的UI Testing的最好的新功能之一，是能在持续集成服务器中执行测试。Xcode bots提供对此的支持，而且command line支持当UI测试失败时会立即发出通知。\n#更多关于Xcode中新的UI Testing的更多内容，我建议你观看WWDC session 406， UI Testing in Xcode。还推荐阅读  Testing in Xcode Documentation和 Accessibility for Developers Documentation。\n","slug":"iOS-软件测试之-UI-Testing","date":"2016-08-19T09:27:25.000Z","categories_index":"iOS SDK","tags_index":"软件测试,UI Testing","author_index":"William Xie"},{"id":"57c222edf3fd4d08f933646c87ec3116","title":"iOS app性能优化系十八: Zombies","content":"","slug":"iOS-app性能优化系列十八-Zombies","date":"2016-08-19T06:28:16.000Z","categories_index":"iOS app性能优化","tags_index":"iOS app性能优化,instruments","author_index":"William Xie"},{"id":"25ee8bbebcad830d4b389739cd515f1f","title":"iOS app性能优化系十七: Time Profiler","content":"","slug":"iOS-app性能优化系列十七-Time-Profiler","date":"2016-08-19T06:28:01.000Z","categories_index":"iOS app性能优化","tags_index":"iOS app性能优化,instruments","author_index":"William Xie"},{"id":"fb1f6da4b881e7c86a225846c3899603","title":"iOS app性能优化系十六: System Usage","content":"","slug":"iOS-app性能优化系列十六-System-Usage","date":"2016-08-19T06:27:35.000Z","categories_index":"iOS app性能优化","tags_index":"iOS app性能优化,instruments","author_index":"William Xie"},{"id":"ea21952bbe4371feb85734471eba496b","title":"iOS app性能优化系十五: System Trace","content":"","slug":"iOS-app性能优化系列十五-System-Trace","date":"2016-08-19T06:26:56.000Z","categories_index":"iOS app性能优化","tags_index":"iOS app性能优化,instruments","author_index":"William Xie"},{"id":"3ac802d4f88595874e382af97e2452f2","title":"iOS app性能优化系十四: OpenGL ES Analysis","content":"","slug":"iOS-app性能优化系列十四-OpenGL-ES-Analysis","date":"2016-08-19T06:26:07.000Z","categories_index":"iOS app性能优化","tags_index":"iOS app性能优化,instruments","author_index":"William Xie"},{"id":"748295de4e68f42ae28bbc6f25b36bf2","title":"iOS app性能优化系十三: Network","content":"","slug":"iOS-app性能优化系列十三-Network","date":"2016-08-19T06:25:44.000Z","categories_index":"iOS app性能优化","tags_index":"iOS app性能优化,instruments","author_index":"William Xie"},{"id":"a3b29b50864b28e83452f139ad40a297","title":"iOS app性能优化系十二: Metal System Trace","content":"","slug":"iOS-app性能优化系列十二-Metal-System-Trace","date":"2016-08-19T06:25:32.000Z","categories_index":"iOS app性能优化","tags_index":"iOS app性能优化,instruments","author_index":"William Xie"},{"id":"c3e281f4ad3bfd41019e4f62582bd287","title":"iOS app性能优化系十一: Leaks","content":"","slug":"iOS-app性能优化系列十一-Leaks","date":"2016-08-19T06:25:11.000Z","categories_index":"iOS app性能优化","tags_index":"iOS app性能优化,instruments","author_index":"William Xie"},{"id":"8a90e85f3da8ef8d614eccd84c0a08b5","title":"iOS app性能优化系十: GPU Driver","content":"","slug":"iOS-app性能优化系列十-GPU-Driver","date":"2016-08-19T06:24:46.000Z","categories_index":"iOS app性能优化","tags_index":"iOS app性能优化,instruments","author_index":"William Xie"},{"id":"103b8f62e3a290b159db9b1c2b009417","title":"iOS app性能优化系九: File Activity","content":"","slug":"iOS-app性能优化系列九-File-Activity","date":"2016-08-19T06:24:28.000Z","categories_index":"iOS app性能优化","tags_index":"iOS app性能优化,instruments","author_index":"William Xie"},{"id":"77437c7fc5340f2a54b47d55c6097b94","title":"iOS app性能优化系八: Energy Log","content":"","slug":"iOS-app性能优化系列八-Energy-Log","date":"2016-08-19T06:24:06.000Z","categories_index":"iOS app性能优化","tags_index":"iOS app性能优化,instruments","author_index":"William Xie"},{"id":"f10931155ea75a1a4e3f5e44913972e1","title":"iOS app性能优化系七: Counters","content":"","slug":"iOS-app性能优化系列七-Counters","date":"2016-08-19T06:23:44.000Z","categories_index":"iOS app性能优化","tags_index":"iOS app性能优化,instruments","author_index":"William Xie"},{"id":"b995fe3ffe67f98dd4535ebb1f497aa7","title":"iOS app性能优化系六: Core Data","content":"","slug":"iOS-app性能优化系列六-Core-Data","date":"2016-08-19T06:23:24.000Z","categories_index":"iOS app性能优化","tags_index":"iOS app性能优化,instruments","author_index":"William Xie"},{"id":"9515370eee77f58de95c3e820f8e1fc8","title":"iOS app性能优化系五: Core Animation","content":"","slug":"iOS-app性能优化系列五-Core-Animation","date":"2016-08-19T06:23:08.000Z","categories_index":"iOS app性能优化","tags_index":"iOS app性能优化,instruments","author_index":"William Xie"},{"id":"84861ac7d95dcf6b25d033bc99447ec8","title":"iOS app性能优化系四: Cocoa Layout","content":"","slug":"iOS-app性能优化系列四-Cocoa-Layout","date":"2016-08-19T06:22:41.000Z","categories_index":"iOS app性能优化","tags_index":"iOS app性能优化,instruments","author_index":"William Xie"},{"id":"e181fe404cc9f0bea8ac8b1d96557a79","title":"iOS app性能优化系列三: Automation自动化","content":"","slug":"iOS-app性能优化系列三-Automation自动化","date":"2016-08-19T06:21:40.000Z","categories_index":"iOS app性能优化","tags_index":"iOS app性能优化,instruments","author_index":"William Xie"},{"id":"97a2dac7e69ff8e29acf006c8ec1041e","title":"iOS app性能优化系列二: Activity Monitor活动监视器","content":"","slug":"iOS-app性能优化系列二-Activity-Monitor活动监视器","date":"2016-08-19T06:21:17.000Z","categories_index":"iOS app性能优化","tags_index":"iOS app性能优化,instruments","author_index":"William Xie"},{"id":"4dc896d7a59383baffa315f4498bf870","title":"iOS app性能优化系列二: Analyze静态分析","content":"#Analyze静态分析\n在App进行Build或Archive时，会产生很多编译警告，这些警告是编译时产生的，静态分析的过程也类似，在XCode Product菜单下，点击Analyze对App进行静态分析。\n\n\nAnalyze主要分析以下四种问题：\n\n\n\n\n\n\n\n\n\n1、逻辑错误：访问空指针或未初始化的变量等；2、内存管理错误：如内存泄漏等；3、声明错误：从未使用过的变量；4、API调用错误：未包含使用的库和框架。\n##Analyze内存泄漏分析\n声明错误、逻辑错误、Api调用错误基本在编译时都会有警告，Analyze的主要优势在于静态分析内存泄漏及代码逻辑错误。\n比如在开启arc的环境下，输入以下一段代码：\n//截取部分图像\n+(UIImage*)getSubImage:(unsigned long)ulUserHeader\n&#123;\n    UIImage * sourceImage = [UIImage imageNamed:@\"header.png\"];\n    CGFloat height = sourceImage.size.height;\n    CGRect rect = CGRectMake(0 + ulUserHeader*height, 0, height, height);\n     \n    CGImageRef imageRef = CGImageCreateWithImageInRect([sourceImage CGImage], rect);\n    UIImage* smallImage = [UIImage imageWithCGImage:imageRef];\n    //CGImageRelease(imageRef);\n     \n    return smallImage;\n&#125;\n\n用注释注释掉CGImageRelease(imageRef)这行，虽然开起了arc，不过仍然会导致imageRef对象泄漏。\n使用Analyze进行分析，在导航栏Analyze选择Analyzer查看分析结果：\n\nAnalyze已经分析出imageRef对象有内存泄漏，这种情况在编译时是无法发现的。\n如果你没有使用ARC，那么Analyze更有用。\nAnalyze的其他三种分析也可以使用，相比编译器给出的信息更明确。\n##Analyze逻辑错误监测\n\n这种情况在codereview时也较难发现，可以借助Analyze。\n如上代码，当Tag不等于1、2和3的时候，就会出现很问题了。\nAnalyze还给出了箭头提示：len is a garbage value。建议在声明变量时，同时进行初始化。\n","slug":"iOS-app性能优化系列二-Analyze静态分析","date":"2016-08-19T06:20:45.000Z","categories_index":"iOS app性能优化","tags_index":"iOS app性能优化,instruments","author_index":"William Xie"},{"id":"1cbcb76715126955837c5dfa9e5a18a7","title":"iOS app性能优化系列一: instruments","content":"","slug":"iOS-app性能优化系列一-instruments","date":"2016-08-19T06:20:14.000Z","categories_index":"iOS app性能优化","tags_index":"iOS app性能优化,instruments","author_index":"William Xie"},{"id":"9bbc749f72537f23c7e17a92be8a0a0e","title":"iOS连接外设的几种方式","content":"一般iOS开发者做APP开发大部分时候都是通过Http(s)请求跟后台服务器打交道，做一些信息展示和用户交互。很少涉及到去跟外部硬件设备连接的开发。随着近年来车联网和物联网的兴起，智能家居和智能硬件的逐步火热，越来越多的app被开发出来，用来跟硬件设备进行来连接，获取硬件相关信息展示或者发送指令控制硬件来提供服务。故本文就针对iOS的app如何跟外部设备进行连接通信这个问题跟大家交流一下。本文原创，欢迎转载，转载请注明出处，如有不正确的地方恳请各位看官指正。\n\n\n可以分为三大类：\n第一类是通过网络端口，建立Socket使用TCP/IP协议族进行通信，天然支持多通道，想要几个通道就建几个socket就行了。它主要有三种方式，第一种方式是Wi-Fi连接，优点是：简单，不需要集成MFi芯片，只要对应的硬件有无线网卡，然后手机和硬件连接到同一个局域网中就可以使用socket通过网络协议通信了。缺点也很明显：（1)无线连接信号容易受到干扰，不太稳定，容易断开；（2）如果硬件使用的场合没有公共wifi，就需要手机自建热点共享，硬件进行热点接入，操作步骤较多，对用户来说学习使用成本较高，并且热点共享要求手机本身的数据移动网络是稳定的，在没有移动数据网络信号的地方，热点无法建立。\n需要先打开个人热点共享；\n使用网络端口的第三种方式是NCM，就是把USB端口虚拟成标准的网络端口，然后手机和外设就能通过有线网络直连了，可以理解成手机和外设通过一跟网线连起来了，然后就可以用socket通过TCP，UDP进行通信了。它的优点是：有线连接，非常稳定，带宽足够；也不依赖移动网络信号；但是它的缺点就是：需要集成MFI芯片并进行MFI认证，有一定门槛。更变态的是这么好的一种方式，目前苹果只提到可以在它自己的CarPlay使用，其他硬件并没有说禁止或者允许使用。如果硬件使用NCM跟iOS系统的App通信，可能通过MFI认证是有风险的。\n关于如何使用Socket进行TCP、UDP连接，推荐github上的开源项目CocoaAsyncSocket。\niOS App连接外部硬件的第二大类是EAP，全拼是External Accessory Protocol，外部设备协议。这个是苹果推荐使用的外设连接方式。需要外设集成MFI芯片进行MFI认证。手机端开发相对简单，只要集成 iOS系统提供的一个框架ExternalAccessory.framework，并且在info.plist中配置好协议字符串(Supported external accessory protocols），当iOS 设备通过USB线或者蓝牙连接到对应硬件时，iOS系统会把符合MFI认证要求的外设抽象成了一个流对象，App通过指定的协议字符串来创建一个EASession类的实例来访问到该流对象，就能通过NSInputStream和NSOutputStream跟硬件件进行通信了。它有两种模式，一种是叫EASession的模式，它带宽相对较低，但是允许同时通过多个协议字符串创建多个会话，也就是说直接支持多个通道；另外一种是Native Transport的模式，这种模式的优点是带宽足够大，理论值是100MB以上，但是不支持多通道，如果业务层需要支持多数据通道的话需要App自己进行通道的复用与拆分，并且Native Transport需要iPhone工作在USB host模式，硬件需要支持USB 模式切换。\n关于如何使用EAP跟外部设备进行通信，可以参考苹果官方的Demo进行入门和学习。\n第三大类就是BLE，低功耗蓝牙，是iOS7.0以后才支持的连接方式。它的优点是不需要集成MFI芯片做认证，功耗低，手机端开发也相对简单，集成iOS系统提供的CoreBluetooth.framework就行。缺点是：带宽很低，一般适合于只需要传输少量数据的场景。比如前两年非常火爆的各种所谓智能硬件，像智能水杯，智能体重计，运动手环等，都是采用这种连接方式。\n关于如何使用BLE进行硬件连接，可以参考本人在github的一个小开源项目（https://github.com/luoxubin/BlueTooth4.0）。另外本人自己业余时间也做过一个BLE连接外设的App-裤宝（名字有创意吧，裤子里的宝贝，是跟我另外两个小伙伴一起做的创业项目，目前该项目黄了， 不过app还在线上，AppStore里搜索“裤宝”可以下载。\n总结一下，图中带MFI字样的表示该连接方式需要硬件集成MFi芯片，做MFi认证。关于苹果的MFI认证，对iOS开发中来说其实是一个比较陌生并且繁琐的topic，原因如下：\n（1）网上鲜有资料，Google基本上查不到。 因为MFi认证是由硬件生产商主导进行的，苹果首先对硬件生产商的实力（质量，信誉，生产规模）有很苛刻的要求，满足要求的才有进行MFI认证的资格。满足MFi认证资格要求的硬件生产商，提交了MFi产品计划后才能得到苹果MFi开发的官方文档，这个文档是带水印的，不允许外泄；\n（2）MFi认证周期很长，过程也很复杂；\n（3）苹果官方沟通渠道很窄，电话打不通，邮件回复不及时。\nusbmuxd  iDevice通过USB与桌面系统通信原理小科普\nos x上，苹果有一个服务，叫usbmuxd，这个服务主要用于在USB协议上实现多路TCP连接，将USB通信抽象为TCP通信。苹果的iTunes, XCode，都直接或者间接地用到了这个服务。\n那么问题来了，如何让iDevice通过苹果的数据线和mac通信？其实不止是mac，只要pc上提供usbmuxd服务，就可以和iDevice通信，通过TCP.\nlibimobiledevice，可以在github上找到它。已经将苹果的usbmuxd服务和其他iTunes相关的服务实现跨平台并且开源了。\n另外，peerTalk，一个基于usbmuxd服务的开源代码，作为iDevice和OS X通信的一个很好的例子，可以迅速拿来参考，用到自己的app里。既然用到苹果私有（没公开）的协议，那么app能否上架呢？答案是肯定的。并没有用到私有API。某些知名软件比如duet，利用这个usbmuxd上的peerTalk和VNC技术，实现了将iPad作为Mac的显示器的功能，并且在AppStore上架。\n另外，树莓派也已经实现了peerTalk。\nhttp://www.cocoachina.com/ios/20160804/17239.htmlhttp://bbs.iosre.com/t/usbmuxd-idevice-usb/1482\n","slug":"iOS连接外设的几种方式","date":"2016-08-18T06:24:31.000Z","categories_index":"iOS SDK","tags_index":"MFI,WiFi,Socket,EAP","author_index":"William Xie"},{"id":"ba5bb03605262eb5cd9725f996529571","title":"Handoff：沟通iOS应用和网页","content":"转载自卢克的博客\n#Handoff的基本常识\niOS 8以及Mac OS X Yosemite之后引入了一个新的功能特性：Handoff。Handoff也就是Continuity特性，连续互通，比如你用iPhone写邮件写到一半想在Mac上继续写，或者Mac上看到一个网页想在手机上浏览，这些便是Handoff的使用场景了。\n\nHandoff的支持有一些硬性的要求：\n\n\n\n\n\n\n\n\n\n1.互通的所有设备必须支持 Buletooth LE 4.0，Handoff使用BLE信号来传递用户活动数据。2.设备处于联网状态，有时候有些数据还是会通过互联网来传递的，比如Mail App的邮件内容的同步。3.所有设备必须连到同一个iCloud账户。4.当然你还得保证当前设备的Handoff功能打开了(iOS:设置-&gt;通用-&gt;Handoff 与建议的应用程序。5.Mac:系统偏好设置-&gt;通用,倒数第二栏有个选项,”允许这台Mac和iCloud设备之间使用Handoff”)\nBLE并不像传统的蓝牙，并不需要人工手动进行配对，只要打开就行了，所有的配对数据传输都是自动完成的；设备并不一定需要连在同一个WIFI网络中，Handoff的活动数据通过BLE进行传递，保证及时性以及数据的安全性，你可以在使用过程中尝试将WIFI或者网络关闭，设备还是可以接受到Handoff的通知的。\n苹果已经对很多内置的App做了Handoff支持，如Safari浏览器，邮件，电话，消息，提醒事项等都是支持的，在你开始Handoff编程之前可以先使用这些App进行Handoff功能的体验。\n#iOS App 到 Web Browser\nHandoff编程的核心类便是NSUserActivity了，代表着一个用户的活动，每一个Activity都有一个activityType，用来标识Activity的类型。当App 到 App之间进行Handoff的话，那么接受方需要满足几个条件\nApp必须是通过发布证书或者开发者证书进行打包的和发布Activity的App拥有相同的TeamID\ninfo.plist中声明了接受的Activity的activityType(key 为 NSUserActivityTypes)\n不过很多应用其实也只是在移动设备上有App，在Mac上绝大多数还是走的浏览器，所以iOS App和浏览器的Handoff的需求就变的很常见了。这个时候Activity的另一个叫做webpageURL的属性便有用武之地了，当没有合适的App能够处理当前的Activity的话，系统会转给默认的浏览器进行处理（当然你的这个默认的浏览器的info.plist的NSUserActivityTypes数组中必须声明了 NSUserActivityTypeBrowsingWeb这个type，目前Mac版本的Chrome已经支持了)\nself.myActivity = [[NSUserActivity alloc] initWithActivityType: @\"com.taobao.handoff.act.home\"];\nself.myActivity.webpageURL = [NSURL URLWithString:@\"http://www.taobao.com\"];\n[self.myActivity becomeCurrent];\n当上面的代码执行之后，Activity便会进行分发，接受者接受后，若没有App能够处理当前类型的Activity的话便转交给默认的浏览器去处理了，这里需要特别注意的就是activity的生命周期，当activity被invalidate或者被释放了，那么这个Handoff消息也就消失了，相关设备的Handoff消息就会消失。\n关于Handoff的调试，由于到目前为止模拟器还是没有支持Handoff的，所以你必须使用开发者证书进行真机调试。\n#Web Browser 到 iOS App\n相比于App到Web Browser，Web Browser到iOS App的Handoff实现起来就复杂一些了。 首先先描述下大体的流程：\n\n\n\n\n\n\n\n\n\n1.首先在Mac上使用Safari浏览器浏览目标网站，Handoff消息会通过BLE进行分发 2.iOS设备接收到Handoff消息后，检查对应的webpageURL，看是否有某个App的associated-domains （entitlement中的一项）中包含了这个webpageURL, associated-domains对应的Handoff的配置URL样式为 activitycontinuation:example.com 3.如果某个App的associated-domains存在相应的webpageURL,那么iOS会去这个网站的固定的一个URL（地址为https://example.com/apple-app-site-association）获取一个签名过的文件（源文件为一个JSON文件）,如果解密后文件中的App IDs中包含了 之前匹配的App的App ID，那么这个Activity便交给这个匹配的App进行处理。\n下面讲解详细的操作步骤\n1.客户端\n首先当然还是折腾客户端工程，当你创建好工程，创建好App ID，XCode中设置好自己的Developer账户之后，你便可以设置编译的Code Sign的相关东西了，配置都得选自动的，这样就可以通过XCode来管理配置 App ID 以及相应的 Provisioning Profiles了，当你通过developer后台网站就可以看到Provisioning Profiles中有一堆所谓的Managed by Xcode的条目了。\n你需要在XCode工程对应的Target的Capabilities这个Tab中开启Associated Domains，这个时候时候你可能会遇到错误提示“You must be a team admin or agent in order to enable this capability.”,其实即使账户是admin还是会报错，这个可能是XCode的bug吧，你需要切换到General这个tab中将Team先选None，然后再切换到你对应的Team，这个时候Team下方显示错误了，其实就是你更改了Entitlements，而这个和Provisioning Profiles有关联，所以你的Provisioning Profiles也需要重新更新，点击Team下方的Fix Issue按钮，等待重新下载新的Provisioning Profiles，然后回到Capabilities这个tab你会发现刚才的错误已经不见了。\n其实Capabilities中的操作除了会在本地生成entitlements文件，还会同步到developer后台去，会修改app对应的App ID的配置，以及在developer后台生成新的Provisioning Profiles。这些东西都和打包签名息息相关。\n接着在Associated Domains下加上所需要支持handoff的domains\nactivitycontinuation:taobao.com\n\nactivitycontinuation是服务名，taobao.com是支持的域名 当Mac上的浏览器访问一个网站的时候，此网站的域名如果被某个App的Associated Domains包含了，那么Handoff底层会去这个域名一个指定的路径下访问一个文件，这个指定的路径便是 : https://taobao.com/apple-app-site-association ,这个路径需要返回一个签名过的文件数据，里面指定了当前网站所支持Handoff的App ID们，这个下面会提及到\n2.服务器端\n需要进行Handoff的网站，需要在https的特定的路径下放一个签名过的文件，这个文件里面指明了Handoff支持哪些App（Domain-approved apps IDs），这个文件的明文为JSON格式,在对JSON文件签名前最好去掉所有无用的空格以及检测下JSON格式的正确性，避免后面带来问题\n&#123;&quot;activitycontinuation&quot;:&#123;&quot;apps&quot;:[&quot;XN6U3EV979.com.taobao.handoff&quot;]&#125;&#125;\n\n签名则是使用网站的ssl的私钥以及证书进行签名（如果不存在中级证书，那么中级证书可以去掉）\ncat json.txt | openssl smime -sign -inkey taobao.com.key\n                             -signer taobao.com.pem\n                             -certfile intermediate.pem\n                             -noattr -nodetach\n                             -outform DER > apple-app-site-association\n生成的文件放到网站根目录下以及确保可以通过指定的路径进行访问。\n3.如何进行本机调试要想在开发机器上进行网站的Handoff的调试则首先的问题就是SSL证书，你需要自己搞一个CA证书，在Mac上可以通过Keychain Access(钥匙串访问)这个App中的证书助理来生成 。\n首先是CA证书,这里生成的是自签名的根证书，CA证书的作用就是给网站的SSL的证书进行签名用的，然后创建网站的SSL证书,一步一步走下去，然后通过刚才的CA证书进行签发，这样生成的证书就可以直接用于网站的SSL证书了。\n然后选择一个Web Server，我这里选用的Jetty，直接下载下来然后就可以直接使用自带的demo了，主要是需要自己配置下SSL。\n将默认的ssl配置拷贝到demo工程相应的目录下 Luke@LukesMac:~/Workspace/jetty » cp etc/jetty-ssl.xml demo-base/etc/\n从Keychian Access中导出之前生成的证书文件，导出格式为p12，这样就会包含私钥了。假设导出文件为 lukesmac.p12,导出时候 需要你设置一个密码，你就将其设置为 keypwd 然后需要将这个p12文件导入demo工程的keystore文件中，默认在demo工程的etc目录下已经存在一个keystore文件，直接导入这个keystore\nkeytool -importkeystore -srckeystore lukesmac.p12 -srcstoretype PKCS12 -destkeystore keystore\n\n默认keystore的密钥库口令为storepwd,导入的过程中你还需要输入你上面设置的私钥密码（因为jetty-ssl.xml中配置的私钥密码以及默认keystore中的私钥密码默认为keypwd ,所以为了方便上面导出私钥所设置的私钥密码保持一致为keypwd）。最后你还需要在demo工程的根目录下的start.ini中加入一行\netc/jetty-ssl.xml\n\n然后你就可以开开心心的启动了，\nLuke@LukesMac:~/Workspace/jetty/demo-base » java -jar ../start.jar\n\n然后我便可以通过https://lukesmac.local:8443/ 进行访问了\n下面需要将json.txt进行签名，\n首先你需要从上面导出的p12文件中搞出私钥文件，再从Keychain Access中导出一份证书的cer文件\nopenssl pkcs12 -in lukesmac.p12 -nocerts -out privateKey.pem\ncat json.txt | openssl smime -sign -inkey privateKey.pem -signer lukesmac.cer -noattr -nodetach -outform DER > apple-app-site-association\n将生成的apple-app-site-association文件放到 demo工程的ROOT目录下，然后重启以及在浏览器中对这个文件进行访问测试。\n这个时候你以为一切就绪了，发现手机上handoff的图标依然是safari，打开后发现，网页根本无法打开，其原因就是自己生成的自签名的CA证书不被信任，这个时候你可以讲CA证书按照cer的格式导出，然后通过邮件发送，在iPhone上的邮箱App中点击这个cer的附件，系统会跳转到设置的描述文件的界面去，你需要进行安装证书，之后这个CA证书签发的SSL证书对于这台设备都是可信任的了。\n最后就是客户端添加处理逻辑了，可以在Appdelegate中添加如下方法，就可以对传递过来的userActivity进行处理\n- (BOOL)application:(UIApplication *)application continueUserActivity:(NSUserActivity *)userActivity restorationHandler:(void(^)(NSArray *restorableObjects))restorationHandler NS_AVAILABLE_IOS(8_0);\n\n","slug":"Handoff：沟通iOS应用和网页","date":"2016-08-18T04:30:41.000Z","categories_index":"iOS SDK","tags_index":"Handoff","author_index":"William Xie"},{"id":"ab6c85c0c4edf3086fcd0cfa75df8403","title":"Xcode Server 教程4: 证书和描述文件","content":"原文翻译地址\nhonza dvorskyXcode Server Tutorials: 4. Certificates &amp; Provisioning Profiles21. october 2015\nThis article is Part 4 of a whole series called Xcode Server Tutorials. Check out Part 3 first if you haven’t already. New posts are always tweeted by me (@czechboy0) on Twitter.\nWelcome back! Today we’ll cover the last piece of making Xcode Server a viable CI tool for shipping apps: code signing. Code signing is an important part of the outstanding security of iOS, Mac, Watch and now TV apps on Apple’s platforms. However, managing code signing is still an involved process for beginners, even though Apple has been working hard to abstract away many of the details with recent releases of Xcode. Unfortunately, those improvements haven’t really trickled down to Xcode Server yet, so we’ll need to get our hands dirty to make it archive apps for us and let us test on real iOS devices. Shall we?\n\nObjective of this article\nWe will add a connected iOS device as a test device, which will require us to tackle code signing of our app with a development provisioning profile. This won’t be enough for us, because after an app is tested and ready, we want to ship it! This will bring us to archiving our app for testing on TestFlight or deployment to the App Store. Not there yet? We’ll also see how to install our apps on our device over Wi-Fi directly from Xcode Server. During this whole process we’ll make a good use of sigh, a great tool from the fastlane family, so make sure to install that first.\nEnvironment\nXcode 7 has been released, but since my iPhone is on iOS 9.1 Beta, I’ll use Xcode 7.1 Beta 3 and OS X Server 5 in this tutorial. But feel free to use the latest stable Xcode 7. Everything is running on OS X 10.11 El Capitan now.\nProject setup\nI’ll be working on our XCSTutorialProject1 that you got familiar with in my previous posts, but today you’ll have to make changes to your own Xcode project, because the sample project’s app ID cannot be registered under all of us. Whenever you’re not sure about something, however, feel free to take a look in the sample repo (and choose the right branch - today we’ll use step5).\nHow to use code signing in Xcode is out of scope of this article, but I recommend this quick guide on code signing with fastlane, because that’s what we’ll set up today. Unfortunately, we won’t be able to use the “Best Solution” mentioned in that article (using environment variables), because as far as I can tell, there is no way to pass environment variables to Xcode Server’s build command. Thus we’ll use the last solution where we’ll let fastlane download our provisioning profiles, change them in our project and we’ll save them in git, to be later copied on Xcode Server.\nThis means that we will not be using the automatically managed provisioning profiles in Xcode. If you want to have a good setup with Xcode Server that includes archiving apps for distribution, I recommend you switch to manually managed profiles, like I have in the sample project.\n⚠️ Again, you might be tempted to use the button titled “Add Team…” in Xcode Server’s configuration screen in OS X Server. DO NOT do that. That would create a new certificate for the server, which you can only add to the automatic provisioning profiles (which you can’t use for archiving apps for distribution) and is very difficult to clean up later.TL;DR? Too much magic that doesn’t lead to the right results.\n\nProvisioning Profiles\n\nOk, let’s get back to how we will set things up today. In order to allow Xcode Server to build, test and archive for both testing and distribution, we need to somehow ensure that the respective provisioning profiles are available there. The folder which Xcode Server scans for provisioning profiles is, as you’d expect,\n/Library/Developer/XcodeServer/ProvisioningProfilesand that’s where we need to ensure our profiles are before each build.\nAs I said, I’ll walk you through a workflow which has worked for me very well, but in no way it’s the only possible one. With that disclaimer out of the way, I tried many ways to do this and this is the least painful one.\n1.1 Storing Provisioning Profiles in your repo\nThe best way to get your profiles over is by actually storing them in your source repository. You don’t have to worry about security here, because provisioning profiles are useless to anyone without your certificate (and a private key). So let’s do that.\nAs I mentioned in the beginning of this article, we’ll use sigh, a tool from the fastlane family to achieve this by adding a new lane to our Fastfile, which we’ll call provision. For my project it looks like this:\n  lane :provision doENV[‘SIGH_APP_IDENTIFIER’] = ‘com.honzadvorsky.XCSTutorialProject1’ENV[‘SIGH_OUTPUT_PATH’] = ‘./ProvisioningProfiles’ENV[‘SIGH_USERNAME’] = “#{ENV[‘USER’]}@icloud.com”ENV[‘SIGH_SKIP_CERTIFICATE_VERIFICATION’] = ‘true’ # https://github.com/KrauseFx/sigh/issues/141ENV[‘FL_PROJECT_PROVISIONING_PROJECT_PATH’] = ‘XCSTutorialProject1.xcodeproj’ENV[‘FL_PROJECT_PROVISIONING_PROFILE_TARGET_FILTER’] = ‘^XCSTutorialProject1$’ # exact match in regex, we don’t want e.g. XCSTutorialProject1Tests\ncreate a folder for our provisioning profiles if not exists  sh &quot;cd .. &amp;&amp; mkdir -p ProvisioningProfiles&quot;\n\ngenerate development profile  profile_name = &#39;tutorial_app_dev&#39;\n  profile_file = &quot;#&#123;profile_name&#125;.mobileprovision&quot;\n  profile_path = &quot;./ProvisioningProfiles/#&#123;profile_file&#125;&quot;\n  udid_dev = sigh(\n\nprovisioning_name: profile_name,filename: profile_file,development: true          )\nset the development profile in the project  update_project_provisioning(\n\nprofile: profile_path,build_configuration: ‘Debug’          )\ngenerate appstore profile  profile_name = &#39;tutorial_app_appstore&#39;\n  profile_file = &quot;#&#123;profile_name&#125;.mobileprovision&quot;\n  profile_path = &quot;./ProvisioningProfiles/#&#123;profile_file&#125;&quot;\n  udid_appstore = sigh(\n\nprovisioning_name: profile_name,filename: profile_file          )\nset the appstore profile in the project  update_project_provisioning(\n\nprofile: profile_path,build_configuration: ‘Release’          )endview rawfastlane_provision_lane.rb hosted with ❤ by GitHubDon’t let the 45 lines of code fool you, it’s not complicated. I just tried to write in in a readable way. Basically, at the top (lines 3-9), we’re just telling sigh who we are and where we want to store the downloaded provisioning profiles. Then, on line 12, we make sure we have a folder called ProvisioningProfiles in our repository. And then, on lines 15-28 we first call sigh, which downloads (and creates if necessary) the appropriate provisioning profile for development (note the development: true on line 21). And we repeat the same thing for the appstore provisioning profile, this time with no development flag.\nYou add this to your Fastfile and then just run fastlane provision whenever your provisioning profiles might have changed (new team member, new device added to the profile etc.) This will download the provisioning profiles into your repository, in the ProvisioningProfiles folder and modifies your Xcode project to use them in the app target. Needless to say, you need to adapt this lane to work for your project/target/configuration names, but I hope the example is self-explanatory.\nAfter you run fastlane provision, make sure to commit your changes. This is a requirement so that we can go to the next step, using these profiles on Xcode Server.\n1.2 Copying Provisioning Profiles on Xcode Server\nWe just made sure that all our provisioning profiles are stored in our repository, but how do we make sure they appear in\n/Library/Developer/XcodeServer/ProvisioningProfileson our Xcode Server? Well, we’ll use our prebuild scripts again, just like we did in the previous tutorial.\nLuckily, we already have a prebuild lane in our Fastfile, which our Bot calls before every build. Currently, we just install our CocoaPods there, but there’s nothing preventing us from adding more actions to it. So that’s exactly what we’ll do now. As I mentioned multiple times, all we need to do is copy the provisioning profiles from our repository to the right folder on Xcode Server.\nsh “cd .. &amp;&amp; cp ./ProvisioningProfiles/* /Library/Developer/XcodeServer/ProvisioningProfiles/“That’s it! Just add this to the lane called prebuild and you should end up with a lane like this.\nLet’s give our new setup a whirl! (Spoiler alert: we’re not done!)\n\nTesting on your iPhone\n\nYou might remember that in Part 1 we created our first Bot. In that process, one screen allowed us to select devices and simulators to test our app on. I asked you to select only simulators back then, but now it’s time to unleash the full power of tests. If you’re wondering why you’d want to test on real devices instead of just simulators, take a look at this post. Also, in my experience at SwiftKey (where we only tested on real devices), there are enough performance, memory and behavioral differences that justify running tests on real devices.\nLet’s use our usual approach - try to add our device and see what happens. You already know how to edit your Bot from the previous article, so in the Schedule tab only select the Test action and then switch to the Devices tab. Have a development iOS device handy and connect it to your Xcode Server now. You should see it pop up in the list in a matter of seconds (if it doesn’t, running sudo xcrun xcscontrol –restart to restart Xcode Server has fixed it for me).\nSave your Bot and re-Integrate. You might be rightfully suspicious - this will not work yet, but let’s look at the error we got.\nFair enough - “No code signing identities found” is a pretty sensible error. We are trying to run our app on a real iPhone without providing all the required resources to code sign our app. So why did it work on the Simulator? Well, because code signing is optional for testing on the Simulator, so in our case, Xcode just fell back to not code signing the app before testing, which works just fine. However, that’s not enough for testing on real iOS devices.\nThat missing resource is called a certificate - and that’s what we’ll fix now.\n\nCertificates\n\nJust provisioning profiles are useless without a proper signing certificate. In order to allow our Xcode Server to sign apps for testing on devices and archiving, we first need to have a certificate ready there (which is a piece of crypthographic data proving that it was you who created this app and nobody else). From my experience, I would recommend you transfer both your distribution and development certificates to the server, instead of creating new ones. Let’s look at how we do that!\nYour certificates need their private keys to be useful for code signing. Both are stored in your OS X Keychain. Open Keychain Access\nopen “/Applications/Utilities/Keychain Access.app”and switch to your login keychain at the top left. Then, under Category choose My Certificates. Choose both your development and distribution certificates, right click and select “Export 2 Items…”. Export the certificates (with their private keys inside) as a secure .p12 container and set up a password for the file.\nNow send this file over to your Xcode Server machine (or add it to your repo, in which case make sure to keep your password safe), where you’ll open Keychain Access as well. Now, this time, however, switch to the System keychain (that’s the one that _xcsbuildd can actually look into for certificates) and go to File -&gt; Import Items…. Select the .p12 file you just transfered from your development Mac and make sure you’re importing the certificates into the System keychain. Go through the process, type your passwords when asked and at the end you should see your two new certificates appear in the System keychain.\nOne more thing you have to do to be done with certificates, however. By default, the private keys we just added to our build machine’s System keychain are not readable by /usr/bin/codesign. We easily fix that by expanding the certificate to show the private key inside, right-clicking on the key and selecting Get info. There, switch to Access Control and click on the little plus sign at the bottom left.\nThis will present you with a file selection dialog, where you’ll need to select /usr/bin/codesign. How do you show hidden files in this dialog, however? CMD+SHIFT+.. Then go to the root of your hard drive and find usr, inside it bin and finally codesign. After hitting Add, make sure to click on Save changes on the bottom right.\nWhat if we didn’t do this? Well, from my experience, you’d probably get your build hanging on trying to sign your code. And then it would time out after a couple of minutes. So if you’re seeing that, make sure your private keys are accessible by codesign.\nNow, your certificates are ready to be used. 👍\n\nPutting it all together\n\nLet’s recap - we set up our provisioning profiles to be copied from our repository before every build and we just made sure our Xcode Server has access to our certificates that we just transfered there. What’s left? Nothing!\nGive it a try, kick off an integration on your Bot and observe how your connected iOS device comes alive, runs tests and the integration succeeds! 🎉 (Make sure your device is unlocked/has no passcode.)\nDisclaimer: When upgrading my Xcode Server on an old machine, I had to wipe Xcode Server there before I got this working. This hopefully won’t be necessary for you, but if it’s not working (most likely hanging on tests) and you’ve made sure you followed all the steps above, please resort to resetting your Xcode Server as I described in a hack article focused on xcscontrol.\n\nArchiving\n\nSince we did all the hard work already, our distribution certificate and provisioning profile are where they need to be, adding the archiving step in your Bot is all you need to do! So again, edit your Bot, go to Schedule and select Perform Archive action, together with Create user-installable product. Re-run your Bot.\nYou can now see a new section in the Integration result, which contains the created Archive and an exported .ipa. This archive is ready to be downloaded or submitted directly to the App Store 🚀 (very neat!) Or, if you want to go further with fastlane and download this archive from Xcode Server and submit with fastlane, take a look at this fastlane action (created by yours truly.)\nAlso, check out all other deployment options (Crashlytics Beta, Hockey App, …) with fastlane. These can be plugged in in a postbuild script (previous tutorial, remember?) - you can use the environment variable XCS_ARCHIVE, which gives the path to the archive.\nConclusion\nAs you can see, once you tackle code signing on Xcode Server, a whole new world of opportunities opens up, where you can go from a mere commit to having your app submitted to a beta testing service, all completely automagically. fastlane brings an extremely simple way to plug all these actions together, making deployment of your app a matter of one line of code. By connecting it with the best Xcode-integrated CI solution, Xcode Server, you can really achieve an automation Zen, where you focus on your code and let computers perform the boilerplate tasks for you. Take advantage of all that. And dedicate the saved time to creating more things.\nExtra Credit\nOh, I almost got away with it. You’d like to know how to install your app over Wi-Fi, huh? Here you go:\nApp Installation over Wi-Fi\nXcode Server takes care of all the difficult parts of this process, all you need to know is that to prepare your app, you need to have an Xcode scheme, which in its archiving action uses a configuration which allows installation on devices. Such as Debug (most likely) signed with a development profile. Or other configuration signed with an Ad Hoc profile. Or an Enterprise profile. You need to select that scheme when creating your Bot and Xcode Server will automatically create the .ipa for you (assuming you select Create user-installable product when setting up the Bot).\nLet’s go through this step-by-step. In my sample app, I’ll just create a new Xcode scheme, which will use the Debug configuration for Archiving. In Xcode, go to Product - Scheme - Manage Schemes. There duplicate your existing scheme, and rename it (make sure it’s also shared). I named mine XCSTutorialProject1-ArchiveDebug. When you have it selected, click Edit and on the left, in Archiving, select the Debug configuration.\nCommit all these changes, edit your Bot and in Info (first tab), change the scheme to your new scheme, in my case XCSTutorialProject1-ArchiveDebug. Save and rerun your Bot.\nYou should see a screen identical to the one we saw in Archiving earlier. On the surface, not much has changed. However, grab your iPhone now and make sure you’re on the same Wi-Fi as your Xcode Server. Open Safari on your phone and go to the canonical hostname of your server.\nHow to get the canonical hostname of your Xcode Server: In Terminal, run\ncurl -k https://YOUR_XCODE_SERVER_IP:20343/api/hostnameand you’ll get a JSON response with the hostname. That’s what you have to type into your phone, otherwise the installation will fail. For security reasons, you can’t access the server from your phone just by its IP address.\nYou’ll see a dashboard of your Xcode Server, listing all your Bots.\nTap on the Bot that just created the archive for you and click Install. If this is the first time, you’ll be asked to install a profile to allow installation from this Xcode Server. Go through the process carefully and make sure you install it, at the end you’ll get automatically redirected back to Safari. The Install button should now turn green and after tapping it, you’ll be asked to confirm the installation. Once you do and close Safari, you’ll see your app installing on your home screen. Sweet, nah? ⛵️\nThis is very useful when your team makes nightly releases, because it allows your non-technical colleagues to install the build every morning without ever touching Xcode.\nNote that you can change permissions of who can connect to your Xcode Server over Wi-Fi, but here I was assuming you had open access for everyone. See the OS X Server app for restricting access to this dashboard.\nTroubleshooting: If, after tapping Install, you’re getting a popup saying that installation failed, it’s likely that you had the profile installed and later deleted it (and a bug with a browser cookie is confusing Xcode Server). To force a reinstallation of the profile, on your phone visit\nhttps://YOUR_SERVER_CANONICAL_HOSTNAME:20343/api/profiles/ota.mobileconfigReal Conclusion\nNow, this is really it for today. I hope you learned something or that this will be useful to you at some point in the future. Please keep the feedback coming, I’ve received many nice emails and tweets - I’m really glad these articles help some of you to get XCS set up faster.\nThis part concludes the Xcode Server basics that you really needed to know to deploy Xcode Server in the wild. Ping me with ideas of what you’d like to learn about next!\nI hope you found this useful or interesting. For criticism, praise and future articles, I’m @czechboy0 on Twitter.\n« Part 3: Prebuild &amp; Postbuild ScriptsAll Xcode Server Tutorials &amp; Hacks« Full blog© 2016 honza dvorsky — powered by Wintersmith\n","slug":"Xcode-Server-教程4-证书和描述文件","date":"2016-08-17T05:14:41.000Z","categories_index":"Mac OS Server","tags_index":"Xcode Server","author_index":"William Xie"},{"id":"69bfbeae20c3bc5474ab179e8765cf8b","title":"Xcode Server 教程3: 预编译以及编译后脚本","content":"原文翻译地址\nhonza dvorskyXcode Server Tutorials: 3. Prebuild &amp; Postbuild Scripts17. august 2015\nThis article is Part 3 of a whole series called Xcode Server Tutorials. Check out Part 2 first if you haven’t already. New posts are always tweeted by me (@czechboy0) on Twitter.\nGreat to see that you’re hungry for more Xcode Server goodies! And boy, do I have plenty of them for you today. We’ll talk all about prebuild and postbuild scripts. These might initially sound boring, but soon you’ll see that they are in fact very interesting - they allow you to plug in tools like CocoaPods and fastlane, which can easily revolutionize your complete testing and deployment workflow. From messaging you on Slack when your build finishes to automatically uploading builds to the App Store, nothing is impossible. So let’s get started!\n\nEnvironment\nTime has passed since Part 1, so from now on, all tutorials are using Xcode 7 Beta 5 and OS X Server 5 Beta 4. Please make sure to upgrade if at all possible. Take your time, I’ll be waiting here whenever you’re ready. 👍\nObjective of this article\nToday we’ll discover the full power of prebuild and postbuild scripts in Xcode Server by adding fastlane and CocoaPods to our project. In the process, we’ll learn about the _xcsbuildd user and how to make sure it does what we need. We’ll encounter several common issues, which we’ll fix together. Then we’ll try to add a private CocoaPod, which will make us figure out how to add SSH keys for _xcsbuildd to make it work.\nFrom the feedback I’ve received, this has been the most anticipated topic, so let’s get right into it.\n\nUsing CocoaPods\n\nCocoaPods is a great dependency manager for Xcode projects. It allows you to integrate other people’s (or your own) code in your project easily. I regularly split my own projects into multiple “Pods”, to make logical modules of my code reusable. Now, let’s say our app will want to use the XcodeServerSDK project to make a cool Bot-aware iOS app (excuse the shameless self-promotion, but I needed a Pod written in Swift 2). Let’s use CocoaPods to add it as a dependency of our project.\nI already added the Podfile to our project, so please switch to step3 of the tutorial by, in the XCSTutorialProject1, running\ngit checkout step3which will magicly create a Podfile in your project! Then we just need to actually have CocoaPods install the dependencies and start using the workspace instead of the project. So please run\nkillall Xcodepod installopen XCSTutorialProject1.xcworkspaceGood! Now our project uses CocoaPods and we’re able to use XcodeServerSDK. Let’s switch our Bot to the new branch (above we only switched our local checkout) and see if it can rebuild our project with the new shiny Pod in it!\nTo do that, let’s right-click on the Bot in Xcode and select Edit Bot, which will show the configuration sheet that we saw in Part 1.\nLet’s go to Repositories and switch our Bot to the step3 branch, which will tell it which branch to pull from now on. Previously we were on master. (Also, to save time, feel free to quickly switch to Devices and make sure you only have one Simulator selected for testing.) Then click Done to save it.\nLet’s kick off another Integration by right-clicking on the Bot again, but this time selecting Integrate.\nOnce that Integration finishes, let’s look at its results like we did in Part 2. Oh, what is that? Seems like we got an error! 😧\nThe sandbox is not in sync with the Podfile.lock. Run ‘pod install’ or update your CocoaPods installation.Of course, silly me! Since we don’t commit our Pods directory (where the code pulled by CocoaPods lives) into our git repo, our Bot can’t find it. We need to run pod install before every Integration to make things right.\nbefore every Integration\nThis should sound familiar, because we already covered a way to run something before or after every Integration. That’s what Triggers are for! Script triggers, in our case, are going to help us run CocoaPods before every Integration. Let’s add one now!\n\nPrebuild script: run CocoaPods\n\nLet’s edit our Bot again and add a new prebuild script trigger, just like we saw in Part 1 (feel free to go there and see how exactly how we did it and please re-read the ⚠️ Weirdness Alert to understand why we first have to cd into our project directory.)\nSince we ran pod install on our local machine, let’s just add a simple prebuild script like this\ncd XCSTutorialProject1pod installAgain, save the Bot and re-Integrate it.\n2.1 Search Path Issues\nYou might (but you probably won’t) get a Trigger Error now that says something like\nTrigger script exited with code: 127 /var/folders…: line 3: pod: command not foundthis means that the build user can’t find CocoaPods. This might happen if you’re using a homebrew-installed version of Ruby (like I am), in which case, your tools get installed into /usr/local/bin (which is not included in the build user’s PATH variable) instead of /usr/bin (which is). I’ve been asked about this issue and I came up with four solutions (so far). Which is the best one for you depends on whether the machine on which you’re going to be running Xcode Server is your development machine or a separate build machine. Here I sorted them from the simplest workarounds to more robust solutions:\n\nspecify the full path to your tool: /usr/local/bin/pod install in our case\nmanually add the extra search path by adding a line export PATH=”/usr/local/bin:$PATH” at the beginning of the script\ncreate a symbolic link by running the following command:\n\nsudo ln -s /usr/local/bin/pod /usr/bin/podjust once, which would make pod available in /usr/bin, but actually point to the executable in /usr/local/bin4) combine the solutions above, e.g. 1) + 2) run fastlane from a fully qualified path /usr/local/bin/fastlane and as the first step of your Fastfile, add sh “export PATH=&quot;/usr/local/bin:$PATH&quot;“. From that point you should be able to call e.g. CocoaPods by just pod instead of /usr/local/bin/pod. Or 3) + 2), where you only create a symlink for fastlane.\nPersonally, I’d use 3) if there is only a few tools I need to trigger. If there are more, I’d go for 1) + 2). Feel free to ping me with more solutions that you come up with. Ideally, if you can come up with a way to modify PATH of the _xcsbuildd user permanently, definitely let me know and I’ll add it here. That would be the best solution.\nUpdate (14th Sep, 2015): I’ve heard that the symbolic link solution doesn’t seem to work with El Cap anymore, plus it makes using multiple versions of Ruby with rvm very difficult. See this article I wrote about fixing this issue.\nBut again, if you’re using the system installation of Ruby (and you’re not using any homebrew-installed tools), you won’t encounter this issue. Either way, make sure to re-Integrate if you had to apply one of these fixes. Once it finishes, take a look at the full script output by going to Logs -&gt; Show -&gt; Before Trigger #1.\n\nThe famous _xcsbuildd user is here\n\nLet’s say you did want to do this properly for your dedicated build server and chose to use solution 4. How would you go about doing it? Let me introduce you to the _xcsbuildd user.\nIn Under the Hood of Xcode Server I mentioned that Xcode Server runs many daemons on your machine plus an extra user called _xcsbuildd which does all the building. Don’t believe me? Run users in your Terminal right now and you should see yourself and the _xcsbuildd user being logged in. It’s there, ready for your Bots.\nSince _xcsbuildd is a completely separate user, it doesn’t share state with your user, specifically your home folder (/Users/honzadvorsky in my case). Instead, _xcsbuildd‘s home folder is at /var/_xcsbuildd. The reason why this is important is because many tools, Ruby Gems and CocoaPods being one of them, rely on your home folder having some of their data set up (if you don’t install gems globally).\n3.1 Logging in as _xcsbuildd\nIn order to make these tools available to our build user, we need to log in as the _xcsbuildd user now. Macs, being Unix-based machines, have preinstalled tools called su and sudo to switch users and gain root permissions. Since we don’t know _xcsbuildd‘s password, we’ll need to use sudo for our login command - which will be su - _xcsbuildd (the dash is so that the whole environment is switched to the new user). Combining these, to log in as _xcsbuildd, we need to run\n$ sudo su - _xcsbuilddsu: /bin/false: No such file or directoryDoesn’t work. Turns out that _xcsbuildd doesn’t have a shell set up (a way to have an interactive login session), currently it has it set as /bin/false, which is just a glorified way of saying nope. Let’s set a shell for our friend then! We’ll use another preinstalled tool called dscl.\n$ sudo dscl localhost -change /Local/Default/Users/_xcsbuildd UserShell /bin/false /bin/bashDon’t feel intimidated - you only need to run this once to be forever able to login as _xcsbuildd. What we’re saying here is:\n“Hey directory service, on this computer, please change the shell of the user _xcsbuildd from /bin/false to /bin/bash.”\nIf it prints nothing, that’s a good sign. (There is also a way to change the shell in OS X Server. See this Tweet, where in OS X Server -&gt; Users you can show System Accounts, right click on _xcsbuildd and change the shell in Advanced Options. Thanks, @pm_kowal!)\nLet’s try to log in as _xcsbuildd again…\n$ sudo su - _xcsbuilddhonza-dvorskys-mbpr-14:~ _xcsbuildd$Success! 🎉 Let’s verify that we did the right thing by running\n$ whoami_xcsbuildd$ pwd ~/var/_xcsbuilddPerfect. We’re now logged in as _xcsbuildd whose home directory is /var/_xcsbuildd!\n\nPrivate CocoaPod\n\nNow, I usually use this newly-found power to show people how to add SSH keys to the _xcsbuildd user. The reason why that’s necessary is that many people have their own private CocoaPods saved in a private git repository. I had to solve this problem at work and that’s how I first encountered this issue.\n💭 You might say, slow down, didn’t we already tell Xcode Server how to access our private git repositories by telling it our SSH keys when setting up our first Bot? We did indeed, however that information was only sent over HTTPS in a format called scm blueprint, which Xcode Server only uses to check out our repository (see XcodeServerSDK and what information is sent over when creating a Bot). These SSH keys are sent over just for this purpose, but they aren’t added as standard SSH keys to the _xcsbuildd user, meaning they are not available in our scripts, unfortunately.\nIf you now add a private CocoaPods spec repository to your Podfile and try to integrate, the script will fail with something like\nCloning into ‘MySuperSecretPodspecRepository’…Host key verification failed.fatal: Could not read from remote repository.\nPlease make sure you have the correct access rightsand the repository exists.4.1 Adding SSH keys\nFair enough. You have two options now:\nReuse existing keys\nYou can copy your existing SSH keys to /var/_xcsbuildd/.ssh and change their ownership. You’d run:\n$ sudo -s$ mkdir /var/_xcsbuildd/.ssh$ cp /Users/honzadvorsky/.ssh/id_rsa /var/_xcsbuildd/.ssh/$ cp /Users/honzadvorsky/.ssh/id_rsa.pub /var/_xcsbuildd/.ssh/$ cp /Users/honzadvorsky/.ssh/known_hosts /var/_xcsbuildd/.ssh/$ chown _xcsbuildd:_xcs /var/_xcsbuildd/.ssh/id_rsa$ chown _xcsbuildd:_xcs /var/_xcsbuildd/.ssh/id_rsa.pub$ chown _xcsbuildd:_xcs /var/_xcsbuildd/.ssh/known_hosts$ exitWe use sudo -s to start a root session so that we don’t have to prepend every subsequent command with sudo. With chown we make sure the new copy of our keys belongs to the _xcsbuildd user so that it can access them. We also need to copy the known_hosts file to not be asked about trusting new servers again.\nThis solution works fine, but for increased security, it’s probably better practice to create separate SSH keys for each user.\nGenerate new keys\nLet’s start by using our new skill: log in as _xcsbuildd. Try to remember how to do it, but you can always look it up above if you get stuck.\n$ whoami # make sure we’re _xcsbuildd$ ssh-keygen -t rsaI usually don’t change the defaults, so I just hit return three times and get a confirmation that my new keys have been successfully created.\n…Your identification has been saved in /var/_xcsbuildd/.ssh/id_rsa.Your public key has been saved in /var/_xcsbuildd/.ssh/id_rsa.pub.…$ exit # switch back to your userOnce you’ve switched back to your user, there’s a quick way to copy the new public key\nsudo cat /var/_xcsbuildd/.ssh/id_rsa.pub | pbcopypbcopy is another preinstalled tool, which pipes its input into the clipboard. Super handy!\nNow we just need to add our new public key to e.g. GitHub in Settings -&gt; SSK keys -&gt; Add SSH key. Make sure to name it appropriately so that you remember it’s the _xcsbuildd‘s public key. (The example screenshot below is from GitHub, but add your new public key to whatever git hosting service you’re using.)\n4.2 Confirming known_hosts\nIf you try to re-run your Integration now, you’ll see that the script is still failing with\nCloning spec repo czechboy0 from git@github.com:czechboy0/MySuperSecretPodspecRepository.git[!] Unable to add a source with url git@github.com:czechboy0/MySuperSecretPodspecRepository.git named czechboy0.No worries - the SSH keys are all good, unfortunately we still need to confirm that _xcsbuildd trusts the (in my case) GitHub server. Let’s do that now! Log in as _xcsbuildd again and run:\n$ ssh -T &#x67;&#105;&#116;&#x40;&#x67;&#x69;&#x74;&#104;&#117;&#98;&#46;&#x63;&#x6f;&#109; # substitute with your podspec git repo’s serverThe authenticity of host ‘github.com (192.30.252.131)’ can’t be established.RSA key fingerprint is 16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:df:a6:48.Are you sure you want to continue connecting (yes/no)?$ yesWarning: Permanently added ‘github.com,192.30.252.131’ (RSA) to the list of known hosts.Hi czechboy0! You’ve successfully authenticated, but GitHub does not provide shell access.Cool! Let’s run it again just to confirm…\n$ ssh -T &#x67;&#x69;&#116;&#x40;&#103;&#x69;&#x74;&#x68;&#117;&#98;&#46;&#99;&#x6f;&#109;Hi czechboy0! You’ve successfully authenticated, but GitHub does not provide shell access.Perfect. Now re-Integrate again and your private Pod should get installed correctly! 🎆\n\nPostbuild script: run fastlane\n\nCool, so we got our prebuild script working all the way! Apologies for the length of the previous section, but I know how many people struggle with setting private Pods correctly, so I wanted to settle this once and for all. ☺️\nNow, for our postbuild script, let’s say we want to get a message on Slack and the computer to speak to us when our build finishes. fastlane is a powerful tool for running all sorts of actions, but I wanted to pick something simple for now. Obviously, you can add any action to your Fastfile that you want! (like uploading to Crashlytics Beta/HockeyApp/TestFlight etc) (By the way, you could also migrate our prebuild script to fastlane by using the install_cocoapods action).\nWe could go use our trial-and-error approach from before, but this time we already know what we need to do. 😎 I’ll assume you’ve installed fastlane (sudo gem install fastlane), so we need to make sure fastlane is runnable from our postbuild script. Again, if you’re using non-system Ruby, you’ll need to create a symlink first by running\nsudo ln -s /usr/local/bin/fastlane /usr/bin/fastlaneNext, we’ll add a simple Fastfile with the slack and say actions. I’ve done that for you, so please switch your local branch with git checkout step4 and your Bot’s branch to step4 (like we did above from Xcode).\nAnd this time let’s add a postbuild script, instead of prebuild. It should say\ncd XCSTutorialProject1fastlane postbuildThat’s it! We just tell fastlane to run our lane called “postbuild”, which will perform the above actions for us. Neat! Re-integrate your Bot to hear you computer speak to you 👾\n\nEnvironment variables in scripts\n\nXcode Server also gives you a couple of useful environment variables, so that you can make the right decisions in your scripts. You get metadata about the Integration and the Bot, result of the Integration, assets folder and logs locations on disk and more. See most of the XCS variables below (there are missing ones that show up when you create an archive, for example.) If you’re ever curious, just add the command set to your script and it will dump all the environment variables just like this.\nXCS=1XCS_ANALYZER_WARNING_CHANGE=0XCS_ANALYZER_WARNING_COUNT=0XCS_ARCHIVEXCS_BOT_ID=b8dc7112eda9d6a111f67a04ce046bf7XCS_BOT_NAME=’My First Bot’XCS_BOT_TINY_ID=0F536B6XCS_DERIVED_DATA_DIR=/Library/Developer/XcodeServer/Integrations/Caches/b8dc7112eda9d6a111f67a04ce046bf7/DerivedDataXCS_ERROR_CHANGE=-9XCS_ERROR_COUNT=1XCS_INTEGRATION_ID=b8dc7112eda9d6a111f67a04ce07b055XCS_INTEGRATION_NUMBER=15XCS_INTEGRATION_RESULT=trigger-errorXCS_INTEGRATION_TINY_ID=B905C2DXCS_OUTPUT_DIR=/Library/Developer/XcodeServer/Integrations/Integration-b8dc7112eda9d6a111f67a04ce07b055XCS_PRODUCTXCS_SOURCE_DIR=/Library/Developer/XcodeServer/Integrations/Caches/b8dc7112eda9d6a111f67a04ce046bf7/SourceXCS_TESTS_CHANGE=-2XCS_TESTS_COUNT=0XCS_TEST_FAILURE_CHANGE=0XCS_TEST_FAILURE_COUNT=0XCS_WARNING_CHANGE=0XCS_WARNING_COUNT=0XCS_XCODEBUILD_LOG=/Library/Developer/XcodeServer/Integrations/Integration-b8dc7112eda9d6a111f67a04ce07b055/xcodebuild.logOkay, this is all for today! Great job, you! 👏 This was a bit more technical Tutorial, because it was all about scripts. We learned all about adding CocoaPods and fastlane to our project, we got to meet the mighty _xcsbuildd user for whom we added SSH keys, we encountered and together fixed many issues and at the end, we found the environment variables we get in our scripts for free. I hope I answered all your questions about running scripts on Xcode Server. But if I didn’t, please ping me and I might write a short Hack article about anything I’ve missed.\nEven though we’ve covered a lot in parts 1 to 3, there’s still a big elephant in the room. And that elephant can’t move because no valid signing identity was found. Yes, next tutorial will be all about code signing on Xcode Server. 📝 How to manage certificates and provisioning profiles to make Xcode Server create archives, test on connected iOS devices and even enable you to install your app on your iPhone just over Wi-Fi. If this sounds at all like something you’d like to be able to do, stay tuned for the next Xcode Server Tutorial! 🚀\nI hope you found this useful or interesting. For criticism, praise and future articles, I’m @czechboy0 on Twitter.\n« Part 2: IntegrationsPart 4: Certificates &amp; Provisioning Profiles »All Xcode Server Tutorials &amp; Hacks« Full blog© 2016 honza dvorsky — powered by Wintersmith\n","slug":"Xcode-Server-教程3-预编译以及编译后脚本","date":"2016-08-17T05:13:56.000Z","categories_index":"Mac OS Server","tags_index":"Xcode Server","author_index":"William Xie"},{"id":"9548d9afc15ee6211ee05b4849a8d7df","title":"Xcode Server 教程2: 集成","content":"原文翻译地址\nThis article is Part 2 of a whole series called Xcode Server Tutorials. Check out Part 1 first if you haven’t already. New posts are always tweeted by me (@czechboy0) on Twitter.\nOk, time to stop celebrating your success from Part 1 where you got to install Xcode Server and created your very first Bot, which checked out and tested my demo project from GitHub. I left you just after you created your Bot, which, as you probably saw, triggered the first Integration of your Bot. Today, we will look at what this means and how to take advantage of Xcode’s beautiful visualizations of Integration results.\n\n\nObjective of this article\nWe will take a look at how to look at Bots and Integrations in Xcode and we will explore Integration results in detail.\n\nIntegration Results\n\nIn the Report Navigator, which we discovered in Part 1, take a look at your recently-created Bot. Click on the disclosure triangle on its left to reveal the list of Integrations (just one right now). Now click on the running Integration under the Bot and you should see something like this:\nIn the left bar, you have a list of Bots and their Integrations. If you click on a running Integration, you will see its progress and a cancel (the little x) button. At the top right, you can start another Integration by clicking “Integrate” and edit the Bot’s configuration. Which configuration? The one we explored in detail in our first article.\nOnce your Bot finishes running (which should be a matter of one or two minutes), you will be presented with a nice summary of how the Bot did.\nYou can see the number of errors, warnings, analyzer issues and tests ran/failed. Underneath, you will see any additional messages from Xcode Server (we will go into what these two build service warnings mean and how to fix them in a future article) and at the bottom you have a test result for each device.\nIf you look at the top, you can see that this is just one of five sections in the Integration results area - the Summary tab.\nLet’s click on Tests now to see which tests actually ran.\nThe Tests section is probably my most-visited tab. It shows you which tests ran (left) in a grid of tests vs. devices. On the right you can see that the iPhone 6 Simulator succeeded testExample() and took 0.10s to run a performance test called testPerformanceExample().\nPerformance tests actually run the code 10 times and then statistically process the results, giving you the mean (average) value with its standard deviation (how much the runs varied).\nAt the top, you can see filters All, Passed and Failed, and All vs Performance which are self-explanatory. On the right you can even search tests by name and set performance tests’ baselines (which are useful when you want your test to fail if your code gets slower than the baseline). With performance test baselines, you can introduce a “no regressions” policy in your team.\nLet’s look at Coverage now to see how much of our code is actually covered by tests.\n38%, turns out. Here you get to take full advantage of a new Xcode 7 feature called Code Coverage. It tells you, per target all the way down to per method, how well you’re testing your code. Note that this seems to be runtime code coverage. When this feature is on, your test traces every method call, so that you can even see which code path inside of a method has not been taken in tests. This is much better than all the other static code coverage analyzers out there, because they just can’t give you nearly this amount of detail.\nSince your code might take different paths on different devices, even code coverage is reported separately per device. So to be correct, I should have said that our coverage is 38% on the iPhone 5S Simulator.\nThis feature gives you brilliant insight into your own code and how well you’re actually testing it. If you take time to go through the report every now and then, you’ll save hours by knowing where your time is required most. Even in my open source projects, this feature has been a great guide when deciding what we still need to write tests for.\nLet’s see Commits now.\nThe Commits section gives you an overview of what commits have been pushed since the last Integration. This makes it the perfect tool when your build breaks and you need to find out who actually broke it (not for finger-pointing, obviously, just to be able to better diagnose the problem) and what broke. This overview also tells which files were affected by the recent commits.\nAnd last, but not least, the Logs section.\nThe Logs section will prove very useful when diagnosing a build error or a failed test. Here you can find the logs for everything that Xcode Server did on your behalf. The interactive list can be collapsed and expanded depending on the level of detail you’re looking for. But especially the filters All, Issues and Errors become handy when looking for a test failure or a build error.\nSometimes you need to dig even deeper using your favorite text editor or you just want to download some Integration assets (like the built Xcode Archive). In that case, click Download Logs…, which will get you the whole zipped output of the Integration.\nThere is also a bit of a hidden feature: when you’re interested in the raw output of a command, just hover over the right side of it to reveal a “hamburger”🍔 button. Clicking it will present you with the raw, unformatted output. Handy!\n\nWeb UI\n\nNow, there is one more visual way to access Bots and Integrations, and that is in your second most used app: your web browser. Just navigate to https://127.0.0.1/xcode to find a list of your Bots. If you click on one, you can see its latest Integration. Neat, huh?\nWhat’s also nice is that you can jump directly to Xcode’s Integration results by clicking on the “Open in Xcode” link (usually works). And last but definitely not least, let’s take a look at the Big Screen.\nDo you ever envy web developers with their huge and important-looking dashboards? Well, you just got yourself one as well! Just click on “Big Screen” and behold the beauty below. ✨\nThe Big Screen is definitely one of the better designed UIs from Apple. Putting it up on a huge TV screen in your office ensures that nobody wants to break the build, because The Big Screen™ will publicly shame them by pointing out who the latest committers to your repo were (bottom of the screen). In addition, it tells you when the your Bot’s latest Integration ran (14 minutes ago in our case). Also, this screen scales really nicely when you have like five Bots, by alternating between them with a smooth animation.\nThis is all for today. Great job, you! You can now look at results in Xcode and intelligently analyze and discuss what the build did and didn’t. Plus, in Part 1, you learned how to set up Xcode Server from scratch, so feel free to add “sysadmin” to your LinkedIn profile now 😉\nI have many more tutorials planned - but feel free to ping me on Twitter what you’d like to learn about next. Spoiler alert: Part 3 of this tutorial will go into prebuild and postbuild scripts - how to add fastlane, CocoaPods, Carthage and any custom actions around your builds. We’ll get to know the mysterious _xcsbuildd user haunting your system and we’ll even learn how to integrate private CocoaPods, which has became sort of an “advanced” topic in our community. So stay tuned and see you next time! 👾\nI hope you found this useful or interesting. For criticism, praise and future articles, I’m @czechboy0 on Twitter.\n« Part 1: Getting StartedPart 3: Prebuild &amp; Postbuild Scripts »All Xcode Server Tutorials &amp; Hacks« Full blog© 2016 honza dvorsky — powered by Wintersmith\n","slug":"Xcode-Server-教程2-集成","date":"2016-08-17T05:11:40.000Z","categories_index":"Mac OS Server","tags_index":"Xcode Server","author_index":"William Xie"},{"id":"68a518161e274e65975910a88128b5b1","title":"Xcode Server 教程1：入门","content":"原文翻译地址\n这篇文章是Xcode Server系列教程的第一部分。新的文章将会在我的Twitter（@czechboy0）上发布。\n#前言\n我们都知道Xcode Server是如何工作的。你的iOS团队成员花费数周的时间做一个特征分支，并且在这段时间里他没有把别人所做的修改合并到自己的代码里面。当PM催促团队成员交付既定的功能时，他会创建一个pull请求。人们快速浏览代码（因为它包含四千多行追加代码），完成代码审核之后，合并代码，一切就完成了，对吗？\n并非如此。\n你着手于新特征，期待有喝彩和掌声，因为这也预示着接下来几周要辛苦工作。然而，你却沉溺于Twitter。最终，你没有对新特征进行适当的测试，应用程序在32位设备上崩溃了。\n这并不是一个真实的故事，但却时有发生。我们大多数人都在这样团队工作过：持续集成（CI）不是他们工作的一部分。或许他们认为自己的团队太小没必要使用这么先进的工具，也或许他们太忙没有时间安装。\n持续集成是一种软件开发实践，即了解你合并的内容，时常合并。\n\n这是我个人对持续集成的理解。在上面的事例中，这两个特性都被破坏了。首先，团队不知道他们在合并什么东西（一个bug使得他们的app无法在32位设备上使用）。其次，由于没有时常合并代码，导致最后存在大量差异，无人可以对这样的代码进行合理评审。只要他们使用CI工具，遵循CI实践，这两个问题都是可以避免的。\n如果你的团队还没有使用CI，或者你们已经使用了集成工具但使用效果并不令人满意，那么这篇文章就是为你而准备的。今天，我将展示如何使用Apple公司开发的持续集成服务器——XCode Server（简写为“XCS”）。\n\nXCS之所以能成为我所有项目的专用解决方案，原因有很多：\n\n免费\n自托管\n可以在已连接的iOS设备上进行测试\n支持应用程序的OTA安装，即时可用\n你可以控制它的XCode版本（不需要等别人来为你更新）\n最重要的是，XCS是由XCode的维护者开发的，这意味着你可以得到XCode最新版本和最新特性的支持，这些特性包括代码覆盖图、行为测试结果等等。简直是无与伦比。\n\n今天，我将展示如何进行基本的配置。在这个系列的后续文章中，我将解释如何从中获取CocoaPods（甚至是私有pod）之类的工具，如何归档Ad Hoc 和App Store版本，如何插入诸如“Buildasaur ”和“fastlane ”之类的工具，甚至如何编写相对于Xcode Server API的程序。总的说来，我会展示如何充分利用XCode Server。\n这个系列主要讲述如何使用XCode Server。如果你想了解XCode Server内部是如何工作的，我已经写过这样的一篇文章。\n#所需软件清单\n为了深入理解这篇文章，你需要：\n\n装有OS X10.10或者以上版本的Mac，Xcode 6或者更高版本\n访问Developer Portal的苹果开发者账号\n\n#环境\n我选择使用XCode 7 beta 3和OS X Server5 beta 3，尽管它们都是测试版。与OS X Server 4和XCode 6 没有太大区别。所以都使用旧一点的版本应该也没有问题（只是屏幕看上去会有些许不同）。\n#本文主旨\n本文中，我们要在你的Mac上安装OS X Server，并使得它与XCode可以一起使用。然后我们在XCode Server上创建一个Bot，来测试一个从GitHub下载下来的iOS 应用程序。 就这样。非常简单易懂，这篇文章接下来的部分，我们会更接近一个真实的，更为复杂的iOS开发团队建立。\n我们开始吧！\n#1.下载OS X Server\nXCode需要 OS X Server开启持续集成服务。在Mac App Store上下载OS X Server一般要花费19.99美元。然而，iOS和Mac 开发者可以免费下载。接下来我们要进行免费下载。\n浏览开发者门户的OS X 下载区，下载最新版本的OS X Server5（你需要登录你的开发者账户。）\n\n现在点击已下载的安装包，安装OS X Server。\n#2.启用XCode Server\n启动OS X Server（在你的应用程序文件夹下，名字为“Server.app”）,点击Services下面的Xcode。\n\n然后你需要告诉 OS X Server 使用哪一个XCode，点击“Choose Xcode…”，选择你的XCode 7（XCode 6 也可以）就可以了。\n接下来，XCode Server需要花费大约30秒完成准备工作。之后点击右上角的ON 开关，状态文本将会变成“Starting”。当所有准备工作完成，开始运行的时候，可以看到一个绿色的圆点和“Available on your local network…”。\n\n好了，你建立起一个XCode Server！\n#3.检出我们的测试工程\n现在，我们创建一个Bot来测试GitHub上的一个应用程序（这是我为你特别准备的，是不是很善解人意？）正如你期望的，它叫做，“XCSTutorial Project1”。它是一个带有iOS 应用程序目标的XCode工程。\n创建Bot的一种方式是直接由XCode创建。为了后续工作顺利进行，首先需要将你的工程检出到本地。现在我们进行检出。打开终端，切换到工作路径下，比如在你的文档目录下，运行下面的三个命令：\ngit clone --branch step1 git@github.com:czechboy0/XCSTutorialProject1.git\ncd XCSTutorialProject1\nopen XCSTutorialProject1.xcodeproj\n这会把工程克隆到本地（向导的第一步）并在XCode中打开。请确保你正在使用的XCode与之前在XCode Server中选择的XCode是同一个（最好是XCode 7）。\n#4.在XCode中追加Server\n在我们创建Bot之前，我们需要在XCode注册我们新创建的XCode Server。选择 XCode 的Preferences (CMD+,)，然后选择“Accounts”，在底端点击加号按钮，选择“Add Server”。\n \n在地址栏输入本机地址（127.0.0.1），因为刚刚在本机上安装了XCode Server……\n\n然后输入凭证（与Mac账户的凭证相同，对我来说是 User Name: honzadvorsky和我的登录密码。）\n点击“Add”之后，你会看到你的服务器被追加到XCode的Preference里面。\n\n#5.创建一个Bot\n我一直在说Bot，但是它们到底是什么东西呢？\nBot，是一个XCS 的专业术语，是一个构建工作的描述。它告诉XCode Server 代码位置，如何去生成以及测试代码，在生成结束以后通知哪些人等等。运行一次这样的Bot叫做集成。集成产生有价值的东西，比如archives、IPA、测试结果和日志。\n现在来创建我们的第一个Bot。Bot的控制按钮隐藏在XCode左边区域的最后一列，Report导航栏下。\n\n在左下方，点击齿轮图标和“Create Bot…”。\n\n现在可以看到弹出了一个与下面类似的表单，注意，复选框要求你共享scheme。\n\n这是什么意思呢？\n\n\n\n\n\n\n\n\n\nScheme 是你 xcodeproj j和 xcworkspace文件夹下的文件，描述了使用哪一个目标（例如 XCSTutorialProject1 - iOS app）和如何生成（例如Debug 或者 Release）。只有共享的schema才可以检入到你的代码库，并且只有这些共享的schema可以被持续集成服务例如XCode Server使用。\n总体而言，schema是一个生成方案。所以要确保XCode Server可以看到它，这里我们通过共享实现（当在XCode里面编辑scheme的时候，点击Shared 复选框，这会将scheme加入到我们的代码库中）。\n第一次在你的项目中创建Bot，你会看到这个。通常，你会继续并让XCode提交scheme到你的代码库。但是我已经为你做完了这些。所以，点击Cancel，转到终端，在你的工程文件夹下运行下面的命令\ngit checkout step2\n\n然后重启XCode（抱歉，XCode不喜欢自己修改scheme），重复Bot创建过成。这一次，应该没有关于scheme的消息了，正如下面截图所示。\n\n点击下一步，此处你的XCode将会检查是否有权访问你的（实际上，此处是我的）代码库。很有可能（如果你像我一样使用一个自签证书）会首先看到XCode抱怨“The server SSH fingerprint failed to verify.”这是XCode 7的新的特性，来防止MITM袭击。你需要点击“View”然后点击“Trust”。这意味着你声明：“没有问题，XCode。我了解并且相信这个XCode Server，不需要担心。”\n然后，如果你还没有在XCode的Preferences -&gt; Accounts中登录到你的代码库，XCode会要求你“登录”，它说“请提供证书，以便于XCode Server可以从这个代码库中检出文件。”点击“登录”，告诉XCode，是要创建新的SSH键还使用既存的。因为在 ~/.ssh/里面已经存在SSH键，所以我告诉XCode “使用既存的SSH键”。\n\n你的Bot会获取选定分支上的变更，生成代码的最新版本。这意味着如果你想在多分支上测试代码，比如说 master 和 release两个分支，你需要为它们创建两个独立的Bot（在后续的教程中，我们利用Buildasaur使得这个过程连贯起来）。\n\n选择master，然后点击Next。等一下你会看到所有Bot的配置选项。我们来看一下这些都意味着什么（这段时间比较适合去喝一杯咖啡或者去趟洗手间……伦敦现在的天气不错，不是吗？……板球……好了，回到Bots！）\n#6.Bot配置\n\nSchedule告诉Bot什么时候运行:\n\nPeriodical 意味着Bot每小时，每天还是每周运行一次\nOn Commit使得Bot每5分钟从代码库获取一次最新代码，并且无论何时，发现新的提交任务，都会启动新的集成。在 master 分支上的On Commit Bot可以帮助你快速的发现什么时候测试开始失败，而不需要每个人都记着去手工执行测试\nManual 只有当点击XCode中的“集成”时才会运行\n\nActions 告诉Bot要做那些工作:\n\nPerform analyze action运行静态分析\nPerform test action运行应用程序测试\nPerform archive action存档你的应用程序，以备在TestFlight或者应用程序商店发布时使用。\n允许查看测试覆盖了哪些代码，这个选项会迫使XCode Server收集覆盖率数据而无需在scheme中将偏好设置为on。如果在本地运行测试，你不想收集覆盖率数据，但又需要利用在CI 服务器运行时的覆盖率，这个特性就显得非常有用。\n标记和导出，应用程序从生成档案中通过Wi-Fi直接安装到iOS设备上，以后我会专门写一篇文章介绍你应该如何实现这一操作。\n\nConfiguration 允许重写Bot的生成配置（Debug，Release……）。我总是选择默认的“Use Scheme Setting”。\nCleaning通过定期地清除它的所有资源并从scratch上检出代码库，确保Bot不会依赖于 DerivedData 的状态，或者它的源文件夹。你曾经遇到过损坏的 Pods 文件夹吗？这是一种在新的集成（从scratch上检出所有的东西）开始之前移除所有的产品、中间文件和源文件夹的方式。选项有：\n\nAlways – 每次集成前移除所有的产品和中间产物\nOnce a day – 每天只有第一次集成从scratch开始\nOnce a week – 每周只有第一次集成从scratch开始\nNever – 不能自动移除产品\n\n选项很多，是吗？但是，无需担心，一般使用默认值就可以了。如果不做任何更改，应该是不会有问题的。\n现在请确保“Perform test action”被选中，点击下一步。\n在这里，XCode 7 Beta 4 似乎有一个bug，XCode崩溃了。并不是对所有用户都出现，但是如果你的XCode此时崩溃了，请安装 XCode7 Beta 5 或者以上版本来代替之前的XCode。\n你将会看到一个标题为“Choose the devices that this bot will test with”的页面，这正是我们现在要选择的。在顶端的下拉框中有一个值是“iOS”，并且是不可用的。这是因为在一开始选择的这个scheme告诉XCode Server 我们在一个iOS 目标上生成。\nTest With 给了你四个选项：\n\nAll iOS Devices and Simulators – 在所有已连接的iOS设备和模拟器上进行测试。这会花费一定的时间，因为每个版本的iOS都有10多个模拟器。如果你安装了两个XCode，像我现在这样，就要测试iOS8.4和 iOS 9.0，一共有20多个设备。然而，如果是只花费几秒钟的单元测试，这个时间是可以的。\nAll iOS Devices – 所有已连接的iOS设备，不包含模拟器。\nAll iOS Simulators –所有的iOS模拟器，不包含已连接的iOS设备。\nSpecific iOS Devices – 指定的模拟器和已连接的iOS设备。\n\n\n我们选择最后一个选项，指定的iOS设备，选择3个设备进行测试。如果你已经连接了一个开发设备，它会直接显示在列表中，你可以将它包含到你的测试进程（超简单）。\n一直点下一步，直到看到一个叫做“Configure Bot triggers”的页面。\n触发器是一种在集成之前或者之后运行的行为。XCode Server支持两种触发器类型：脚本和发送邮件通知。\n使用脚本，你基本上可以实现实现所有功能：运行 pod install，或者 fastlane ，甚至是当生成结束以后通知其他成员。\n\nWeirdness Alert – 有个地方特别容易出错。当XCode Server检出代码库的时候，没有把路径变更到附录文件夹（就像你运行 git clone …到本地的时候，你需要将路径改变到你的工程目录）。因此在你的脚本中，需要做的第一件事情是 cd PROJECT_NAME （在我们的案例中是 cd XCSTutorialProject1)然后再运行 pod install 或者 fastlane。\n第二个触发器类型是发送邮件通知，它并不是你期望的那样。当集成结束的时候它会给你发送一封邮件。然而它比这更聪明。它可以发送邮件给所有的提交者，因为它知道谁在上一次集成后提交过代码。这样，只有变更代码的人会被通知。如果想让某些地址总是可以收到这些邮件，你也可以追加。\n你也可以指定当集成失败的时候只通知你，你也可以控制这些邮件的内容。非常棒！\n\n创建一种类型的邮件通知，追加上你的邮件地址。但是，不要勾选Bot中发送给所有的提交者复选框。否则，我会收到你完成集成的邮件（因为我是所有这些内容的提交者。）这是XCode Server一个非常有趣的地方——它的邮件系统不是为开源项目设计的。\n你点击“Create”之后，应该可以看到你创建第一个Bot的请求成功了。\n\n祝贺你！创建了第一个Bot。\n很好奇你刚才做的这些有什么意义？看一下教程2，在那篇文章中我们将详细讲解集成结果！\n","slug":"Xcode-Server-教程1-入门","date":"2016-08-17T05:03:42.000Z","categories_index":"Mac OS Server","tags_index":"Xcode Server","author_index":"William Xie"},{"id":"4f32058287c9be1a1db4b39798fb03e9","title":"iOS Xcode Server 持续集成","content":"转载自牧码人_简书\n#前言常用的持续集成工具有Jenkins、Travis CI、Xcode server等，当然我们选择最简单的Xcode server。\nOS X server中集成了git版本管理功能，Xcode server持续集成服务，还有wiki知识库管理等，你甚至还可以拿它搭建一个网站服务器。\n在持续集成过程中你可以直接使用os x server 的git版本管理功能，将代码提交至自己搭建的OS X server服务器。也可以将代码提交至其他git版本管理仓库中(比如GitHub)。\n设备\n\n\n\n\n\n\n\n\n\n1.一台Git服务器，可以用GitHub、oschina等。 2.一台装OS X Server的服务器，必须为MAC，下文简称 Xcode Server服务器。 3.若干MAC做客户端，下文简称客户端。 4.若干台iOS测试机。\n\n\n#配置Xcode Server服务器\n1、Apple给开发者可以凭开发者账号免费兑换OS X Server。免费兑换地址：\nhttps://developer.apple.com/devcenter/mac/loadredemptioncode.action?seedId=13CB96H8S4\n2、下载OS X Server后点击安装。\n3、打开 Server 应用，以查看 OS X Server 中提供的服务列表。选择“Xcode”。\n点按“选取 Xcode”按钮，然后在“应用程序”文件夹中选择“Xcode”。Xcode 服务将自动启动。\n\n4、开发者团队\n在此处千万不要添加开发者账号\n\n5、添加git存储库，如果用Github、oschina或者自己搭建的git服务器则不需要此步骤。\nXcode 服务 Bot 将从源 Git 储存库访问项目和代码。\n点按“储存库”，然后点按 添加按钮。选取 Git 储存库的名称，然后点按“创建”。\n储存库的 URL 基于服务器主机名称和储存库名称。例如，储存库的 URL 将为：https://myserver.example.com/git/Mac_Calc.git\n\n#配置Xcode客户端，创建bot\n1、打开xcode&gt;product&gt;create bot\n2、填写bot名称，选择Xcode Server服务器\n\n3、Actions：选择执行的动作：\na、对代码进行静态分析\nb、对代码进行单元测试\nc、生成archive包（可以选择是否生成用户安装包）\n4、cleaning：选择在何时清理项目，有几个选项（总是、每天、每周、从不）\n5、configuration：选择编译配置（Debug、release）\n\n6、选择在何时Xcode Server服务器开始持续集成，有几个选项（定时、在有新代码提交时、手动）\n\n7、Before Integration 在开始持续集成前执行的脚本\n8、After Integration在持续集成后执行的脚本\n\n9、至此，创建bot完成\n#Xcode Server服务器证书配置\n1、配置Certificates\n打开钥匙串，将iPhone Developer: xxx和iPhone Distribution:xxx导出为.p12文件\n\n将导出的.p12文件 导入装OS X Server的MAC的钥匙串中，这次需导入到钥匙串系统中，而不是登录中\n\n持续集成生成包时证书由/usr/bin/codesign管理，所以需将codesign添加为允许访问证书的程序\n\n在显示简介中选择 访问控制 &gt;始终通过这些应用程序访问 中点击加号，开始选择/usr/bin/codesign程序。选择完成后点击确认。由于usr是隐藏文件，在选择时使用快捷键 CMD+SHIFT+. 显示隐藏文件\n\n按照以上步骤将iPhone Distribution:xxx的访问控制，也添加/usr/bin/codesign程序。\n2、将Provisioning Profiles拷贝到Xcode Server\nXcode客户端证书保存在以下文件夹中\nUser/Library/MobileDevice/ProvisioningProfiles\n\nXcode Server服务器证书保存在以下文件夹中\n/Library/Developer/XcodeServer/ProvisioningProfiles\n\n将Xcode客户端路径下的证书保存至Xcode Server服务器对应路径下\n3、在上传代码到仓库时需选择正确的证书，如下图\n\n#开始持续集成\n点击integrate开始持续集成\n\n正常情况等待几分钟会看到下面的界面，说明持续集成完成。可以将ipa包安装到手机，也可以将Archive上传到appStore。当然也可以直接用iPhone Safari访问xcode server进行安装。\n\n#cocoapod依赖管理,上传ipad\n在本篇中我们主要讲解如何在持续集成前执行 pod install进行依赖管理，如何在持续集成后将.ipa上传至蒲公英服务器。\n打开Xcode&gt;Bot&gt;Edit Bot&gt;Triggers\n\n首先添加Before Integrate脚本。\n持续集成前先执行 pod install。\n如果项目中没有使用CocoaPods管理三库请略过此步骤，想具体了解CocoaPods，请Google。\nexport LC_ALL=&quot;en_US.UTF-8&quot;\n\n进入工程根目录\ncd QYBaseProject\n\n 执行pod install\n/usr/local/bin/pod install\n\n\n添加 After Integrate脚本。\n持续集成后将ipa包上传至蒲公英。\n蒲公英是免费的应用分发平台，如果没有注册请注册。注册后在账户设置中有API Key、User Key。。\nIPA_NAME=$(basename \"$&#123;XCS_ARCHIVE%.*&#125;\".ipa)\nIPA_PATH=\"$&#123;XCS_OUTPUT_DIR&#125;/ExportedProduct/Apps/$&#123;IPA_NAME&#125;\"\necho $&#123;IPA_PATH&#125;\n\n请根据蒲公英自己的账号，将其中的 uKey 和 _api_key 的值替换为相应的值。\ncurl -F \"file=@$&#123;IPA_PATH&#125;\" -F \"uKey=User Key\" -F \"_api_key=API Key\" http://www.pgyer.com/apiv1/app/upload\n\n\n点击Integrate开始持续集成。\n集成完成后Xcode server会自动将ipa包上传至蒲公英，上传成功后，蒲公英会给你发送邮件。\n现在在iPhone Safari浏览器中打开邮件中的链接，点击安装。\n如果你的开发者账号不是企业账号，请用在账号中添加过Device id的设备上安装。\n\n","slug":"iOS-Xcode-Server-持续集成","date":"2016-08-17T05:02:45.000Z","categories_index":"Mac OS Server","tags_index":"Xcode Server","author_index":"William Xie"},{"id":"fcb7ab71bc8df532f85ded713e0747c8","title":"Xcode开发者工具磁盘空间清理","content":"#Xcode磁盘空间大清理\n使用Daisy Disk可以查看整个电脑的存储情况\n##移除对旧设备的支持\n每次把一个设备接入电脑进行真机调试之前，电脑会对设备建立索引，也在此文件夹下生成对该设备系统的支持文件。于是这里存在了一堆对旧版本iOS设备支持的文件。而我最近基本只对iOS9.3的设备进行真机调试。于是删除了所有低于9.3的文件夹。\n路径：~/Library/Developer/Xcode/iOS DeviceSupport\n\n\n##移除旧版本的模拟器支持\n影响：不可恢复；如果需要旧版本的模拟器，就需要重新下载了。\n路径：~/Library/Application Support/iPhone Simulator\n##移除模拟器的临时文件\n影响：可重新生成；如果需要保留较新版本的模拟器，但tmp文件夹很大。放心删吧，tmp文件夹里的内容是不重要的。在iOS Device中，存储空间不足时，tmp文件夹是可能被清空的。\n路径：~/Library/Application Support/iPhone Simulator/8.0/tmp (以iOS Simulator 6.1为例)\n##移除模拟器中安装的Apps\n影响：不可恢复；对应的模拟器中安装的Apps被清空了，如果不需要就删了吧。\n路径：~/Library/Application Support/iPhone Simulator/8.0/Applications (以iOS Simulator 为例)\n#移除Archives\n每次打包App的dSYM等数据就保存在这里，把一些没用的版本删了。如果是上线了的版本还是保留吧。\n路径：~/Library/Developer/Xcode/Archives\n##移除DerivedData\n这个文件夹中保存的是Xcode的缓存文件，曾经在Xcode跑过的所有项目的索引、build的信息等都会保存在这里。删除后在下次打开项目编译的时候将会重新生成。由于这里包含了大量已经没用的项目的信息又懒得去筛选，于是把整个文件夹删了。\n路径：~/Library/Developer/Xcode/DerivedData\n##Products\n路径: ~/Library/Developer/Xcode/Products/\n同上，把没用的删了\n##移除旧的Docsets\n影响：不可恢复；将删除旧的Docsets文档\n路径：~/Library/Developer/Shared/Documentation/DocSets\n##CoreSimulator ~/Library/Developer/CoreSimulator/Devices/\n一堆模拟器的数据。每个文件夹里包含的就是一个特定系统版本的设备的数据。每个文件夹对应哪个设备可以在其下device.plist中查看。亲测删除之后的效果跟在模拟器里重置相同。省得一个个去重置了，删吧。\n##XCPGDevices ~/Library/Developer/XCPGDevices/\n这里保存了playground的项目缓存。全删了\n","slug":"Xcode开发者工具磁盘空间清理","date":"2016-08-15T07:50:10.000Z","categories_index":"iOS SDK","tags_index":"","author_index":"William Xie"},{"id":"8cac6432eb6fae6843b175d84d8cbe0c","title":"苹果开发者账号相关知识","content":"#Certificates什么是证书什么是证书？证书就是：证明证书拥有者拥有证书上所说的能力。一个证书要涉及到颁发者，拥有者，证明拥有者拥有了什么能力。\n例如，CET-4证书；颁发者：学校，拥有者：自己，证明的能力：英语达到四级水平。苹果开发者证书也是一样，颁发者：自己，拥有者：安装证书的电脑；证明的能力：可以安装或者打包某应用程序。\n\n开发者证书分为两种类型：Development Certificate（开发证书）和Production Certificate（发布证书）。\n##开发者证书能力来源那么当某台电脑安装开发者证书后，这台电脑是如何拥有这种能力的呢？\n\n\n\n\n\n\n\n\n\n苹果在此运用了代码签名验证。代码签名验证允许我们的操作系统来判断是谁对App进行了签名，在安装了Xcode后，Xcode会在项目编译期间使用你的代码签名验证，这个验证是一个由Apple认证过的公钥-私钥对组成，私钥存储在你的钥匙串中（Mac本地，在系统实用工具中），公钥包含在证书（Certificates）中，证书在本地钥匙串和开发者账号中都有存储。另外，还有一个我们可以叫做媒介证书的证书来确保我们的证书（Certificates）是经过授权而发布的。当安装好Xcode时媒介证书（Intermediate Certificate）就已经安装到我们的钥匙串中去了。通过在开发者账号（Developer Account）和本地（Mac）都经过验证的证书（Certificate）我们就可以利用合法的证书进行App的测试和发布了。\n##电脑向证书机构申请凭证在制作证书的时候会有一步让你上传一个CSR文件(用于换取证书的公钥文件)，导出CSR这个过程其实就是电脑向证书机构申请凭证的过程。证书是你用电脑制作的并且颁发给你的电脑的。但是这台电脑是否具有制作证书的能力，就是要这个CSR文件来凭证。CSR从钥匙串中导出，具体步骤在制作证书的时候有具体描述，这里不再详细叙述。\n证书在Xcode工程中所对应的位置\n\n#IdentifiersIdentifiers中又分为App IDs、Pass Type IDs、Website Push IDs、iCloud Containers、App Groups、Merchant IDs、这里主要讲解App IDs。\nApp ID是什么App ID其实就是一个App的身份证，一个App的唯一标示。在Project中称为Bundle ID。在Member Center、Project、iTunes Connect都是需要此ID去标示此App的唯一性。Bundle ID在不同环境下的表现关系。\n\n\n\n\n\n\n\n\n\n\n一个Bundle ID精确的标识了一个App。Bundle ID字符串中只能包含字符（A-Z，a-z，0-9），连接符（-），点（.）而且此字符串最好是reverse-DNS格式的。例如你公司的域名是Acme.com，你App的名字是Hello，那么你可以用com.Acme.Hello作为你的Bundle ID。\nBundle ID的作用：\n\n\n\n\n\n\n\n\n\n1.在Xcode工程中，Bundle ID储存在Info.plist中，当你编译工程的时候，他会把此文件拷贝到你的app包中。2.在iTunes Connect，用Bundle ID去标识App，在你第一次构建上传之后，你就不能在改变或者删除你的Bundle ID3.在Member Center，你创建一个和Bundle ID相匹配的App ID。如果App ID是精准类型的，你就必须精确的去匹配你的Bundle ID，Bundle ID是大小写敏感的。\n##在Member Center中添加App ID在Member Center中添加App ID也是很简单，选中App ID点击右上角的+号，App ID Description就是写一下这个App ID的描述了。App ID Prefix：App ID的前缀，这里苹果为了更精确的保证App ID的唯一性使用了开发者账号的Team ID作为App ID的前缀。App ID Suffix：App ID的后缀，这里有两种类型，一种是精准的，一种是通用的，我们在使用中大多数都是使用精准的，直接把我们的Bundle ID填进去就好。下面就是App包含的服务，这个根据自己业务所需的类型自己选择就可以了，而我们用的最多的也就是Push Notifications推送服务。然后continue就可以了。\n#DevicesDevice就是用来测试的设备。在Member Center中添加device的步骤其实也很简单了，主要就是要拿到device的UDID，这里我们可以利用iTunes、iTools、Xcode这些工具都可以拿到设备的UDID。需要注意的就是，每个开发者账号，每年最多可以添加100台调试设备，而且不能更改，想要更改就要等到下一年重新续费的时候才能更改调试设备了。在下面要讲述的描述文件中只有发布到App Store和In House的时候这两种类型的描述文件的制作是不需要添加device的，而其他描述文件的制作都是需要添加device的。\n#Provisioning Profiles\n描述文件描述了可由哪台电脑，把哪个App，安装到哪台手机上面。一个描述文件的制作是需要App ID、Device、Certificate这些信息的。所以苹果在Member Center中把这个文件的制作排在最后面是很合理的。描述文件其实可以分为两种类型，一种是带有device信息的；而另一种是不带device信息的。\n##带device信息的描述文件\n\n这种类型的描述文件包括所有开发类型的描述文件和发布到Ad Hoc上面的描述文件。开发和发布到Ad Hoc上都是需要指明具体要安装到哪部手机上的。\n##不带device信息的描述文件\n\n不带device信息的描述文件只有发布到App Store和In House两种情况下才使用这个描述文件，因为通过这两个渠道发布的App我们是不能确定将来要安装到那一台设备上的，因此也就不会带有Device的信息。\n描述文件在Xcode中的位置\n\n团队开发证书的管理在团队开发的时候，最好是一个人去管理证书，当有其他人要用的时候，可直接导出.p12证书供其他开发者使用。证书出了问题，我感觉还是相当麻烦的，而App ID在添加之后，基本上是不会改变的，除非要为App添加新的服务，这时候才要重新编辑App ID，所以App ID最好也是管理证书的人去管理App ID。添加设备这一块就很随意了，所有的开发者都应该有权去管理添加设备这一块。描述文件的制作这个要区分一下是开发类型的描述文件，还是发布类型的描述文件。开发类型的描述文件应该是团队里的每一个开发者都有权去管理的，实际上当开发类型的描述文件出现问题的时候，开发者可以对此描述文件重新编辑一下进行使用，这样是不会影响其他开发者的，甚至你可以自己重新制作一个描述文件也没什么问题。但是发布类型的描述文件，这个最好还是管理证书的那个人去管理这个描述文件。打包发布的时候如果这个描述文件出现变化，还是很麻烦的，而且这个描述文件对于团队其他开发者来说也不是很常用，甚至是根本用不到这个描述文件。\n导出.p12.p12又称为个人信息交换证书。此证书实际包含了.cer证书及对应的私钥信息。上述证书中提到.cer文件中包含公钥，私钥在本地钥匙串中。而.p12包含了公钥私钥，所以可以分发给团队其他成员使用。.cer文件没有包含私钥，所以别人的电脑上用此证书时找不到对应私钥，从而使用不了。在导出p12的时候是点击证书导出的，如（图5-1）所示：有下标箭头的就是有对应的私钥。\n\n参考:    App Distribution Guide\n","slug":"苹果开发者账号相关知识","date":"2016-08-13T12:14:06.000Z","categories_index":"iOS SDK","tags_index":"Apple Developer","author_index":"William Xie"},{"id":"65d1545dfe3983525223d1b1c48e131d","title":"iOS使用TestFlight进行App Beta版测试","content":"在2014WWDC中库克用了20秒的时间，简短的3句话，介绍了测试版本的TestFlight服务。TestFlight用于将Beta版测试，TestFlight已经被苹果收购，所以不要担心存在第三方测试造成数据泄露问题。TestFlight需要iOS8及以上版本的iOS设备才能运行，所以iOS7及之前的设备就不能安装了。TestFlight整合进了iTunes Connect，开发者可以通过电子邮件来邀请测试员来进行测试，这样开发者就可以更简单地让你的同行非同行、你的上级、你的客户、你所想要一起参与测试的人一起来测试应用。\nTestFlight的测试方式分为两种：\n\n内部测试\n外部测试\n\n从功能上讲，这两种方式都可以为测试人员在测试阶段对你的App进行测试。但是既然分了内部测试和外部测试，他们肯定还是有区别的，所谓的内部主要是指iTunes Connect上在你的开发团队里参与技术开发或者管理的成员。最多可以邀请25个内部成员，而与之相对的外部测试，指的是那些不属于你的团队或者公司的测试者，外部测试人员的上限是2000人。这里有一点需要注意的是，在你邀请外部成员参与测试之前，需要先通过苹果的审核，一般审核会在一天左右。而这一限制在内部成员上就没有，也就是说只要你把你的App上传到iTunes Connect上之后内部成员就可以开始进行内部测试了，无需审核。在邀请发出后，有效测试时间为60天。\n\n\n\n\n\n\n\n\n\n\n\n1、现在公司也有使用比较老的测试方法，就是需要提供参与app测试人员的设备UDID，并且开发者需要将这些设备的UDID添加到开发者中心，每次有新的测试人员加入，需要重新生成profiles，重新打包，最可恶的是，只能添加100台设备的限制，总体来说，比较笨拙。2、使用TestFlight测试的好处，只需要参与app测试人员提供一个邮箱，开发者登录iTunes Connect，给测试者发送邀请，测试者接受邀请，然后通过TestFlight，下载安装程序。不需要用户提供设备的UDID，最重要的一点是没有了100台设备的限制，一般内部测试人员最多25个人，外部测试人员最多2000个人，重点是不需要重新配置证书了，也不需要手动发送ipa包, 直接上传到iTunes即可。 3、然而，也有其他公司在使用蒲公英等其他参与测试。\n接下来介绍一下TestFlight如何使用：一、开发者需要做的事情1、进入网址：https://itunesconnect.apple.com 输入账号密码登录iTunes Connect。\n\n2、成功登录iTunes Connect，点击我的App，进入App列表页\nps：如果是初次创建的 App，需要创建一个 iTunes Connect Record。如果你的 App 已经创建好了，可以直接跳过这段，如果你要新建一个 App 的话，可以按照下面的步骤来做：(1)、登录 iTunes Connect 。(2)、在 iTunes Connect 的首页，点击‘My Apps’图标。(3)、开发者第一次进到这里的时候，这里是个空白页。点击左上角的‘+’号按钮，创建一个新的 App 。在你创建了 App 之后，这里会显示你创建的 App 列表。\n\nPaste_Image.png(4)、选择‘New App’。如果你只是 iOS 平台的开发者，这里不会出现其它的选项（如‘New Mac App’）。\n\n(5)、填写好如下弹窗内的信息，点击‘Create’按钮完成创建。\n\n(6)、对于一些必填信息，如果未填写的话，Apple 会在对话框内给出如下提示：\n\nPaste_Image.png(7)、提交App到iTunes connect。在 Xcode 中配置好版本和证书信息。选中菜单‘Product-&gt;Archive’将当前代码归档，归档完成后会弹出‘Organizer-Archives’对话框。选择‘Validate’按钮来检测该归档文件是否符合要求。验证通过之后，你可以选择‘Submit’来提交这个归档。\n3、每当你提交一个新的build之后，在 iTunes Connect的列表中都会对应的增加一个build。\n\nPaste_Image.png选择TestFlight，在TestFlight中填写基本信息接收反馈的邮箱地址，隐私政策网址等。\n\nPaste_Image.png\nPaste_Image.pngInternal Testing：内部测试External Testing：外部测试\n4、邀请测试人员(1)、内部测试：点击Internal Testers，添加测试人员（一般内部测试人员最多25个人）\n\nPaste_Image.png21588630-\nPaste_Image.png\nPaste_Image.png点击Select Version to Test，添加测试版本\n\nPaste_Image.png选中一个版本，点击OK\n\nPaste_Image.png点击save\n\nPaste_Image.png点击Start Testing，之后会收到两封邮件，一封是邀请你加入测试组的邮件，点击同意即可，另一封是成功加入测试组的通知，点击start testing然后跳转到有加粗黑色字体的8个字母测试码的页面，下载TestFlight，然后点击Redeem，输入这8个字母即可下载测试app。\n\nPaste_Image.png点击Start Testing\n\nPaste_Image.png\nPaste_Image.png(2)、邀请外部测试人员\n\nPaste_Image.png点击External Testers，选择添加新测试员，或者使用CSV批量导入邀请外部测试人员。\n\nPaste_Image.png输入电子邮件，名称和姓氏可不填，点击添加。\n\nPaste_Image.png点击Add Build to Test，添加测试版本\n\nPaste_Image.png点击Next，进入下一步\n\nPaste_Image.png填写测试版本的一些信息，点击Next，进入下一步\n\nPaste_Image.png填写联系人信息，和 Beta App Review审核的测试账号，点击Next，进入下一步\n\nPaste_Image.png填写审核信息，然后点击submit，提交 Beta 审核，目前来看，Beta 审核还是比较快速的，有时候一个工作日就可以通过审核。可能是现在使用 TestFlight 功能的 App 还不太多吧；不知道等 TestFlight 普及之后，随着参与 Beta Review 的 App 越来越多，Beta 审核还能不能一直这么快。\n\nPaste_Image.pngps：还需要一提的是，外部测试人员想要参与测试的话，必须要 App 已经通过了 Beta App Review 才行。审核通过，点击Invite邀请按钮，测试者会收到来自TestFlight Beta Testing的邀请邮件。\n二、开发者需要做的事情1、在AppStore上面搜索“TestFlight”\n\n2、下载TestFlight\n3、打开TestFlight进行使用\nps：(1)、应用提示是否允许“推送通知”，一般是允许的，提醒测试新版本；(2)、这时候TestFlight内是没什么内容可看的；(3)、等待开发者邀请测试。（注意查看关联Apple ID邮箱的邮件，2封邮件）\n4、接受邀请iTunes Connect\n\nps：(1)、打开邮箱邮件（电脑和手机操作都可以）；(2)、点击邮件详情里面的“activate your access”，跳转到iTunes Connect登录页；(3)、登录Apple ID账户，按提示勾选同意协议接受邀请。(4)、这是第一封邮件，只有邀请加入开发者用户才会收到。只需要接受一次即可。\n5、接受TestFlight测试邀请(1)、打开邮箱邮件（电脑和手机操作都可以，推荐手机操作。）；(2)、点击邮件详情里面的“Start Testing”；(3)、打开“TestFlight”（手机操作第2步会自动打开TestFlight）；(4)、在TestFlight显示App信息，可以接收测试邀请“Accept”。ps：这是第二封邮件，只有邀请加入应用测试的才会收到。只需要接受一次即可。\n\n电脑操作要有这3步：(1)、Get TestFlight from the App Store（翻译：到App Store下载TestFlight）(2)、Open TestFlight and choose Redeem（翻译：打开TestFlight选择Redeem）(3)、Enter xxxxxx and start testing（翻译：输入验证码，然后开始测试）\n\n6、打开TestFlight，输入验证码，Install应用。\n","slug":"iOS-使用TestFlight进行App-Beta版测试","date":"2016-08-13T09:13:38.000Z","categories_index":"iOS SDK","tags_index":"TestFlight","author_index":"William Xie"},{"id":"6355ecbfbbb37a43783c9d609c208b3c","title":"Apple Pay编程开发详细教程","content":"#Apple Pay简介\n##什么是Apple PayApple Pay，简单来说, 就是一种移动支付方式。通过Touch ID/ Passcode，用户可使用存储在iPhone 6, 6p等设备上的信用卡和借记卡支付证书来授权支付；\n它是苹果公司在2014苹果秋季新品发布会上发布的一种基于NFC的手机支付功能，于2014年10月20日在美国正式上线，2016年2月18日凌晨5：00， Apple Pay 业务在中国上线。\nApple Pay 是在 iOS 8 中第一次被介绍，它可以为你的应用中的实体商品和服务，提供简单、安全、私密的支付方式。它使得用户支付起来非常简便，只需按一下指纹就可以授权进行交易。\n\n##使用前提1.支持iOS设备\nApple Pay 只能在特定的设备上使用，目前为止，这些设备包括 iPhone 6, iPhone 6+, iPad Air 2, iPad mini 3. 这是因为 Apple Pay 需要特定的硬件芯片来支持，这个硬件叫做 Secure Element （简称SE，安全元件）,他可以用来存储和加解密信息。    \n2.系统支持\niOS8.0+版本\n\n\n\n\n\n\n\n\n\n\n注意：iOS9.2才真正的支持“银联支付”， 意味着iOS9.2以后才可以在中国市场使用\n3.银行支持     需要将被支持银行的银行卡， 添加到手机wallet应用当中\n##应用场景1.线下支付\n如果发现以下标识，就代表该商家支持Apple Pay\n\n苹果公开的Apple Pay商家有    \n2.线上支付\n2.1应用内支付\n\n2.2 Apple Pay on Web \n##与其他第三方支付的区别1.硬件方面\n\n\n\n\n\n\n\n\n\nApple Pay：必须是iOS设备， 而且是按照线上支付和线下支付区分不同的真机设备(Apple Pay设备支持列表)微信、支付宝： 基本跟硬件设备无关， 支持大多数的只能手机\n2.网络环境要求\n\n\n\n\n\n\n\n\n\nApple Pay：线上支付需要联网， 线下支付无需联网就可以支付微信、支付宝： 无论是线上还是线下支付， 都需要联网使用\n3.使用技术\n\n\n\n\n\n\n\n\n\nApple Pay：线下支付使用的是 基于NFC的近场通讯技术微信、支付宝： 线下支付使用的是 扫码支付（条形码、二维码）\n4.主要功能\n\n\n\n\n\n\n\n\n\nApple Pay：线上支付、线下支付、部分升级后的ATM机可以取款微信、支付宝： 线上支付、线下支付、转账、理财等\n5.安全性能\n\n\n\n\n\n\n\n\n\nApple Pay：不保留银行卡信息，并且不会暴漏给外界、不分流银行存款（不需要从银行卡转钱到另外一个平台）、不能充值  安全性较高微信、支付宝： 密码保护，身份验证等手段保护账户  安全性相对稍差\n6.支付时长\n\n\n\n\n\n\n\n\n\nApple Pay：无论是线上支付，还是线下支付， 只需要验证指纹即可支付。非常迅速微信、支付宝： 需要扫码支付， 流程相对繁琐，所以时长较长\n7.各自弊端\n\n\n\n\n\n\n\n\n\nApple Pay：只适用于苹果设备， 支付场景单一，无转账理财等业务微信、支付宝： 安全性较差， 必须联网操作，需要充值到对应平台\n#为什么要使用Apple PayApple Pay 大大简化了开发者的工作。你无需自己来管理卡号，也不需要用户去注册银行卡。你可以移除部分业务模块，甚至不需要用户模块了。购买和账单信息回自动交由 Apple Pay token 来处理。这意味着简化了购买流程，可以带来更高的转化率。\n在 WWDC session 702 , Apple Pay Within Apps 中, Nick Shearer 介绍了部分 Apple Pay 在美国的不同商业交易中超高转化率的统计情况。Stubhub 发现使用 Apple Pay 的客户的转换率超过传统客户 20%。OpenTable 发现采用了 Apple Pay 之后呈现了 50%的增长。Staples 发现采用了 Apply Pay 后，实现了109%的转换率增长。其实不仅仅是超高的转化率,还有就是让我们的支付方式看起来高大上.\n#Apple Pay 工作流程\n接入方式\n因为 Apple Pay 在国内是跟银联合作的，所以在接入方式的选择上有两种。一种是使用 CUP SDK（CUP 就是 China Union Pay）等第三方的 SDK。另外一种就是使用 iOS 的 PassKit Framework 和银联的接口来接入。本质上来说，第三方 SDK 就是对 PassKit Framework 和传输信息的加密解密过程做了一层封装，让开发者可以轻松完成 Apple Pay 的接入。\n两种接入方式对比：第一种使用第三方 SDK 接入的方式开发成本较低，但缺点在于对 Payment Sheet 定制化程度不够。而第二种形式的缺点就是开发成本较高。不仅 iOS 端要处理好 Payment Sheet 的显示和隐藏的逻辑，还要对各种异常情况做好相应的 UI 处理。同时在后台也需要处理好以下情况：支付信息的解密，银联接口的交互，以及订单状态的处理。\n支付流程分析\n要理解 Apple Pay 的支付流程，其中最关键一点就是：Apple 不处理跟扣款相关的逻辑，它只负责支付信息的传递。Apple 通过 Touch ID 来验证银行卡卡持有者身份。实际的扣款行为则是发生在银联端，接入了 Apple Pay 的商户组织好 Apple 返回的支付信息，向银联发出扣款请求之后，该笔交易才会真正发生扣款。所以，商户还是要跟银联进行结算的，Apple Pay 只是提供了一种支付渠道。\n\nApple Pay 应用内支付流程如下:\n\n\n\n\n\n\n\n\n\n1.App 根据使用场景显示 Payment Sheet。 2.用户选择需要进行支付的卡以及支付需要的个人信息后，进行指纹验证，之后根据情况，有些银行卡还需要输入卡对应的密码（PIN 码） 3.iOS 将支付相关信息发送到 Apple 的服务器，进行加密。然后通过回调函数将加密后的支付信息返回给对应 App。 4.App 在收到回调之后，将对应信息发送到自己的服务器。 5.服务器在收到 App 发送来的支付信息后，对数据进行解密操作，提取其中需要的信息，组织银联接口报文，调用银联的接口，完成扣款\n下面对过程中的关键地方做一些说明。\n1.App 收到的 Payment sheet 回调信息中，包含了一个 PKPayment 的对象，该对象包含了所有跟 Apple Pay 支付相关所有信息。比如用户的手机号或者收货地址等等，其中最重要的就是 payment token，它的 paymentData 字段数据就是需要发送给服务器的内容。用户信息部分是明文的，而支付信息也就是 paymentData 部分则是被加密过的。\n2.paymentData 的内容是 Json 格式的二进制流，服务器在收到这个数据之后进行解析，其中的 header.wrappedKey 是使用非对称加密算法加密过的对称秘钥。使用在苹果开发者后台配置 merchant 时的私钥进行解密，会得到这个对称秘钥。然后用这个对称秘钥对 data 字段所包含的加密数据进行解密，可以得到 Apple 返回的与支付相关的信息。此支付信息是加密过的，包含了用户支付的卡号和 PIN 码等信息，理论上只有银联才能解析出来真正的内容，我们作为商户是看不到具体信息的。服务器端需要将这些解密过的信息组织成银联所需的报文内容，然后调用银联的扣款接口，完成扣款。\n\n\n\n\n\n\n\n\n\n特别注意：paymentData 里的有一个交易金额字段，但该字段返回的数据并不是实际支付的金额。在组织银联报文的时候一定要注意不要直接使用该字段的内容作为扣款金额的值。\n3.调用银联接口时也有一些需要注意的事项。拿调用银联扣款接口举例，在组织好报文并调用银联接口发送给银联之后，银联的接口返回结果同时有同步和异步两种形式。注意：如果同步结果返回成功，说明银联成功收到并开始处理扣款请求，并不是代表扣款成功。扣款是否成功，是通过异步形式来通知的。扣款不成功的原因可能有很多，比如卡被冻结，PIN 码错误，余额不足等等。为了保证交易状态的准确，推荐的做法是这样：在调用扣款接口后，如果 3 秒内没有收到本次调用的异步结果回调，则使用银联的流水号，开始轮询银联的交易状态接口来确保拿到确切的交易结果。\n4.Apple Pay 是很重视数据安全的。从上面的流程可以看到，为了保证整个交易的安全，Apple Pay 对每个关键流程都有加密处理。同时对每个绑定了 Apple Pay 的银行卡生成一个虚拟卡号，这个卡号的部分信息可以在 wallet 里绑定的卡片详情里看到。在实际支付中是用的这个卡号来做交易，这样可以在一定程度上保证我们银行卡的信息安全。\n#Apple Pay对象类简介\n所有这些类都包含在 PassKit（因此以 PK 开头） 之内，所以你需要在用到 Apple Pay 的地方，引入这个框架\nimport PassKit\n\nPKPaymentButton\nPKPaymentSummaryItem这个类是你的Apple Pay 交易清单上的一条。它可以是商品的，也可以是税，或者运费。账单列表使用PKPaymentSummaryItem添加描述和价格，价格使用NSDecimalNumber。PKPaymentSummaryItem初始化：  label为商品名字或者是描述，amount为商品价格，折扣为负数，type为该条账单为最终价格还是估算价格(比如出租车价格预估)\nNSDecimalNumber NSDecimalNumber可以使用数字初始化，也可以使用字符串\nPKPaymentRequestPKPaymentRequest 合并你所有想要用户看到的信息。诸如 merchant identifier, country code 和 currency code。\nPKPaymentAuthorisationViewControllerPKPaymentAuthorisationViewController 让用户及时授权 PKPaymentRequest，并且选择投递地址和支付的卡。\nPKPaymentPKPayment包括需要处理的交易的信息，并且包含需要用户确认的消息。\n#iOS应用内集成Apple Pay开发环境 : \n\n\n\n\n\n\n\n\n\n1.Mac OS X 10.11.6  2.Xcode 8 beta4  3.付费开发者账号  4.Swift 3.0\n##配置支付环境1.1创建一个Xcode项目为项目创建一个AppleIDApple Pay Demo &gt; General &gt; Bundle identifier\n\n1.2开启Apple Pay功能Apple Pay Demo &gt; Capabilities1.3添加MerchantID\n\n##代码实现\n定义成员变量\n//支付视图\n@IBOutlet weak var payView: UIView!\n//支付按钮\nvar payButton : PKPaymentButton? = nil\n//价格数组 \nlet priceArray = [9888.0,230.0,200.0,150.0,233.0,33.0,-1800.0]\n/// 购物清单数组\nvar paymentSummaryItems : [PKPaymentSummaryItem]? = nil\n/// 配送方式数组\nvar paymentShippingMethods : [PKShippingMethod]? = nil\n\n1.判断当前是否支持Apple Pay\n//1.判断当前设备是否支持苹果支付\nif !PKPaymentAuthorizationViewController.canMakePayments() &#123;\n    //隐藏\n    payView.isHidden = true\n    print(&quot;设备不支持ApplePay，请升级至9.0以上版本，且iPhone6以上设备才支持&quot;)\n&#125;\n\n2.判断当前是否添加银行卡检查用户是否可进行某种卡的支付，是否支持Amex、MasterCard、Visa与银联四种卡，根据自己项目的需要进行检测\nif !PKPaymentAuthorizationViewController.canMakePayments(usingNetworks: [PKPaymentNetwork.chinaUnionPay,PKPaymentNetwork.visa,PKPaymentNetwork.masterCard])&#123;\n    print(&quot;没有绑定银行卡,跳转到绑定银行卡界面&quot;)\n    //创建一个跳转按钮,当用户点击按钮时,跳转到添加银行卡界面\n    payButton = PKPaymentButton(paymentButtonType: PKPaymentButtonType.setUp, paymentButtonStyle: PKPaymentButtonStyle.whiteOutline)\n    payButton!.addTarget(self, action: #selector(ViewController.jump), for: .touchUpInside)\n    //添加到payView\n    payView.addSubview(payButton!)\n&#125;\n//跳转到银行卡界面\nfunc jump()  &#123;\n    let pl = PKPassLibrary()\n    pl.openPaymentSetup()\n&#125;\n\n如图:如果当前系统支持Apple Pay 以及 Wallet 已经添加了银行卡,显示购买按钮\npayButton = PKPaymentButton(paymentButtonType: PKPaymentButtonType.buy, paymentButtonStyle: PKPaymentButtonStyle.black) \npayButton!.addTarget(self, action: #selector(ViewController.buy), for: .touchUpInside)     \n//添加到payView\npayView.addSubview(payButton!)\n\n如图:           \n\n\n\n\n\n\n\n\n\n注意:显示的Apple Pay按钮和Set Apple Pay按钮图片需要按照官方文档 要求设置\n3.创建支付请求创建一个PKPaymentRequest,该request需要包括所有商品和服务费用的，例如邮寄费，税或者折扣等\n//1.创建PKPaymentRequest\nlet request = PKPaymentRequest()\n//2.配置支付请求\n//2.1配置申请的merchantID\nrequest.merchantIdentifier = &quot;你申请的merchantID&quot;\n//2.2 配置国家代码 和 货币\nrequest.countryCode = &quot;CN&quot;\nrequest.currencyCode = &quot;CNY&quot;\n//2.3 配置用户可进行支付的银行卡\nrequest.supportedNetworks = [PKPaymentNetwork.chinaUnionPay,PKPaymentNetwork.discover,PKPaymentNetwork.masterCard]\n//2.4 配置商家处理协议 \n//设置支持的交易处理协议，3DS必须支持，EMV为可选，目前国内的话还是使用两者吧\nrequest.merchantCapabilities = [PKMerchantCapability.capability3DS,PKMerchantCapability.capabilityEMV]\n//2.5 配置购买商品清单(订单)\nvar sum : Double = 0.0\n_ = priceArray.map &#123; i  in\n            sum = sum + i\n    &#125;\n    \nlet item1 = PKPaymentSummaryItem(label: &quot;DJI精灵4无人机主机&quot;, amount: NSDecimalNumber(value: priceArray[0]))\nlet item2 = PKPaymentSummaryItem(label: &quot;DJI精灵4智能电池&quot;, amount: NSDecimalNumber(value: priceArray[1]))\nlet item3 = PKPaymentSummaryItem(label: &quot;DJI精灵4螺旋桨&quot;, amount: NSDecimalNumber(value: priceArray[2]))\nlet item4 = PKPaymentSummaryItem(label: &quot;DJI精灵4旅行背包&quot;, amount: NSDecimalNumber(value: priceArray[3] ) )\nlet item5 = PKPaymentSummaryItem(label: &quot;DJI精灵4第二手柄&quot;, amount: NSDecimalNumber(value: priceArray[4]))\nlet item6 = PKPaymentSummaryItem(label: &quot;DJI精灵4云台盖&quot;, amount: NSDecimalNumber(value: priceArray[5]))\nlet item7 = PKPaymentSummaryItem(label: &quot;大学生折扣价&quot;, amount: NSDecimalNumber(value: priceArray[6]))\n//最后这个是支付给谁\nlet totalItem = PKPaymentSummaryItem(label: &quot;DJI官方旗舰店&quot;, amount: NSDecimalNumber(value: sum))\n//note:支付清单 ,最后一个item ,代表汇总\n//summaryItems为账单列表，类型是 NSMutableArray，这里设置成成员变量，在后续的代理回调中可以进行支付金额的调整。\nrequest.paymentSummaryItems = [item1,item2,item3,item4,item5,item6,item7,totalItem]\nself.paymentSummaryItems = request.paymentSummaryItems\n//3.0 配置请求的附加信息\n//设置发票配送信息(billingAddress)和货物配送地址信息(ShippingAddress),用户设置后可以通过代理回调 代理获取信息的更新\n//3.1  是否显示发票收货地址, 显示哪些选项\n//如果需要邮寄账单可以选择进行设置，默认PKAddressFieldNone(不邮寄账单)\n//楼主感觉账单邮寄地址可以事先让用户选择是否需要，否则会增加客户的输入麻烦度，体验不好\nrequest.requiredBillingAddressFields = .all\n//3.2 送货地址信息,默认PKAddressFieldNone(没有送货地址)\n//需要根据不同的商品类型来设置requiredShippingAddressFields，如果使电子/虚拟商品（一般为提取/下载链接），则显示联系人邮箱。如果为实物，则显示联系人地址、手机号以及邮箱\nrequest.requiredShippingAddressFields = .all\n    \n//设置货物的配送方式，不需要不配置\n//3.3 配置快递方式 &lt;PKShippingMethod*&gt;\nlet method1 = PKShippingMethod(label: &quot;韵达快递&quot;, amount: NSDecimalNumber(value: 0.0))\nmethod1.detail = &quot;送货上门&quot;\nmethod1.identifier = &quot;yundakuaidi&quot;\n    \nlet method2 = PKShippingMethod(label: &quot;顺风快递&quot;, amount: NSDecimalNumber(value: 18.0))\nmethod2.detail = &quot;24小时&quot;\nmethod2.identifier = &quot;shunfengkuaidi&quot;\n\nrequest.shippingMethods =  [method1,method2]\nself.paymentShippingMethods = request.shippingMethods   \n//3.4 配置快递取货方式\nrequest.shippingType = .storePickup\n    \n//3.5 添加一些附加的数据\nrequest.applicationData = &quot;BuyID=123456789&quot;.data(using: String.Encoding.utf8)\n    \n    \n\n4.弹出授权视图控制,让用户去支付\n //显示购物信息并进行支付\nlet avc  = PKPaymentAuthorizationViewController(paymentRequest: request)\navc.delegate = self\nself.present(avc, animated: true, completion: nil)\n\n\n\n\n\n\n\n\n\n\n显示所有已绑定的银行卡。当选择卡片会调用代理方法paymentAuthorizationViewController:didSelectPaymentMethod:completion:该方法，需要实现completion完成回调，否则会卡在payment processing界面\n\n\n\n5.PKPaymentAuthorizationViewControllerDelegate 代理方法\n5.1 选择支付方式代理方法\n /**\n 选择支付方式\n - parameter controller:    授权视图控制器\n - parameter paymentMethod: 支付方式信息\n - parameter completion:    回调\n */\nfunc paymentAuthorizationViewController(_ controller: PKPaymentAuthorizationViewController, didSelect paymentMethod: PKPaymentMethod, completion: ([PKPaymentSummaryItem]) -&gt; Void) &#123;\n    //作用:\n    //选择支付方式选择回调,用于更新不同的货币,支付金额等,主要更新paymentSummaryItems对象数组\n    print(&quot;已经选了一个付款方式&quot;)\n    //付款方式\n    var  paymentType : String = &quot;&quot;\n    switch paymentMethod.type &#123;\n    case .unknown:\n        paymentType = &quot;未知&quot;\n    case .debit:\n        paymentType = &quot;借记卡&quot;\n    case .credit:\n        paymentType = &quot;信用卡&quot;\n    case .prepaid:\n        paymentType = &quot;预付卡&quot;\n    case .store:\n        paymentType = &quot;store方式&quot;\n    &#125;\n    //网络内购部分数据会为nil\n    print(&quot;当前网络:\\(paymentMethod.network),支付方式:\\(paymentType),支付卡号:\\(paymentMethod.displayName)&quot;)\n    print(paymentMethod.paymentPass)\n    \n    completion(self.paymentSummaryItems!)\n    \n&#125;\n\n5.2选择送货地址信息代理方法\n/**\n 选择送货地址信息\n - parameter controller: 授权视图控制器\n - parameter contact:    送货地址信息\n - parameter completion: 回调\n */\nfunc paymentAuthorizationViewController(_ controller: PKPaymentAuthorizationViewController, didSelectShippingContact contact: PKContact, completion: (PKPaymentAuthorizationStatus, [PKShippingMethod], [PKPaymentSummaryItem]) -&gt; Void) &#123;\n    print(&quot;选择收货人联系方式:\\(contact))&quot;)\n    //送货信息选择回调，如果需要根据送货地址调整送货方式，比如普通地区包邮+极速配送，偏远地区只有付费普通配送，进行支付金额重新计算，可以实现该代理.\n    //返回给系统  更新以后的shippingMethods配送方式和更新以后的summaryItems账单列表\n    //如果不支持该送货信息返回想要的PKPaymentAuthorizationStatus\n    \n    completion(PKPaymentAuthorizationStatus.success, self.paymentShippingMethods!, self.paymentSummaryItems!)\n&#125;\n\n5.3选择邮寄方式代理方法\n/**\n 选择邮寄方式\n - parameter controller:     授权视图控制器\n - parameter shippingMethod: 邮寄方式\n - parameter completion:     回调\n */\nfunc paymentAuthorizationViewController(_ controller: PKPaymentAuthorizationViewController, didSelect shippingMethod: PKShippingMethod, completion: (PKPaymentAuthorizationStatus, [PKPaymentSummaryItem]) -&gt; Void) &#123;\n    print(&quot;选择邮寄方式为:\\(shippingMethod.label)&quot;)\n    //配送方式回调，如果需要根据不同的送货方式进行支付金额的调整，比如包邮和付费加速配送，可以实现该代理\n    //更新paymentSummaryItems数组\n    completion(PKPaymentAuthorizationStatus.success, self.paymentSummaryItems!)\n&#125;\n\n5.4已经授权支付代理方法\nfunc paymentAuthorizationViewController(_ controller: PKPaymentAuthorizationViewController, didAuthorizePayment payment: PKPayment, completion: (PKPaymentAuthorizationStatus) -&gt; Void) &#123;\n    print(&quot;完成授权,获取Token,连接商家服务器&quot;)\n    //支付凭据，发给服务端进行验证支付是否真实有效\n    print(payment.token)\n    print(payment.shippingMethod)  //送货方式\n    print(payment.billingContact)  //账单信息\n    print(payment.shippingContact) //送货信息\n\n    // 一般在此处,拿到支付信息, 发送给服务器处理, 处理完毕之后, 服务器会返回一个状态, 告诉客户端,是否支付成功, 然后由客户端进行处理\n    let isSuccess = true\n    //它需要你连接服务器并上传支付令牌和其他信息，以完成整个支付流程。\n    if isSuccess &#123;\n        completion(.success)\n    &#125;else&#123;\n        completion(.failure)\n    &#125;\n    print(&quot;已经授权支付&quot;)\n&#125;\n\n5.5授权控制器完成支付或者取消\n func paymentAuthorizationViewControllerDidFinish(_ controller: PKPaymentAuthorizationViewController) &#123;\n    self.dismiss(animated: true, completion: nil)\n    print(&quot;取消或者完成交易&quot;)   \n&#125;\n\n\n#Web端集成Apple Pay\n","slug":"Apple-Pay编程开发详细教程","date":"2016-08-12T13:22:21.000Z","categories_index":"iOS SDK","tags_index":"ApplePay","author_index":"William Xie"},{"id":"b7a7249920521c3b70ef581661870b51","title":"翻译: Apple Pay编程指南","content":"#关于Apple Pay\nApplePay是一种移动支付技术，它能够让用户以一种便捷安全的方式为现实世界中购买的商品和服务付款。\n关于相关App里的数字商品和服务，请参考In-App Purchase Programming Guide.\n\n\n##Apple Pay 工作流程\n使用Apple Pay的APP需要在Xcode中开启Apple Pay capabilities这一项特殊的权限。你同样需要注册一个商业标示，并设置密钥；在给服务器发送支付信息时，这些密匙可以确保数据的安全传输。\nTo initiate a payment, your app creates a payment request. This request includes the subtotal for the services and goods purchased, as well as any additional charges for tax, shipping, or discounts. Pass this request to a payment authorization view controller, which displays the request to the user and prompts for any needed information, such as a shipping or billing address. Your delegate is called to update the request as the user interacts with the view controller.\n发送一个付款,你的app创建一个付款请求,这个请求包括 所购买的服务和商品的合计, 也包括附加的税 打折,购物, 通过这个情节 给一个 付款授权视图控制器, 将要显示这个请求给送货 和 提示 任何需要的信息, 比如 购物和付款地址, 你的代理 被调用 更新 这个请求 用户交互 和这个视图控制器.\n支付请求就是描述当前进行的购买操作，包括支付金额。你把支付请求发送给一个授权支付的视图控制器；该试图控制器呈现相关请求内容，并提示用户需要输入的信息，例如配送地址或者账单地址。接着，当用户与视图控制器交互，并提供新的支付信息时，APP会调用支付请求的委托，继续执行支付流程。\nAs soon as the user authorizes the payment, Apple Pay encrypts payment information to prevent an unauthorized third party from accessing it. On the device, Apple Pay sends the payment request to the Secure Element, which is a dedicated chip on the user’s device. The Secure Element adds the payment data for the specified card and merchant, creating an encrypted payment token. It then passes this token to Apple’s servers, where it is reencrypted using your Merchant Identifier certificate. Finally, the servers pass the token back to your app for processing.\n一旦用户授权这个支付,Apple Pay就会加密支付信息 防止未授权第三方支付访问它.在设备上,Apple Pay 发送 支付请求到 安全模块,这个模块就是用户设备专门的芯片.这个安全模块添加指定银行卡和商家的支付信息数据,创建一个加密支付token.\nApple Pay会对支付信息进行加密处理，以防止未获授权的第三方获取用户的支付信息。你可以在自己的服务器上完成整个支付流程，也可以在自己的服务器上使用第三方支付平台来解码支付信息，并完成支付处理。\nThe payment token is never accessed or stored on Apple’s servers. The servers simply reencrypt the token using your certificate. This process lets your app securely encrypt the payment information without it having to distribute your Merchant Identifier certificate as part of the app.\n关于Apple Pay安全性的更多信息, 请参考 iOS Security Guide.\nIn most cases, your app passes the encrypted payment token to a third-party payment platform to decrypt and process the payment. However, if your team has an existing payment infrastructure, you can decrypt and process the payment on your own server.\n关于支持Apple Pay的支付平台信息，请参考developer.apple.com/apple-pay/\n#配置支付环境\n一个商用ID标识可以帮助Apple Pay识别你，让你能够接受付款。在支付信息加密的过程中，把公匙和证书与ID标示关联起来进行加密是必不可少的一步。在APP使用Apple Pay之前，你首先得注册一个商用ID，并配置它的相关证书。\n注册商用ID标示\n\n\n\n\n\n\n\n\n\n1.在开发者会员中心，选择“Certificates，Identifiers&amp;Profiles” 2.在Identifiers下，选择Merchant IDs 3.在右上角点击”+”按钮 4.在Description栏、ID栏输入相应信息，点击”Continue” 5.浏览下配置参数，点击”Register” 6.点击”Done”\n为你的ID标示配置一个证书\n\n\n\n\n\n\n\n\n\n1.在开发者会员中心，选择”Certificates，Identifiers&amp;Profiles“ 2.在Identifiers下，选择Merchant IDs 3.选择列表中的ID标示，点击Edit 4.点击”Create Certificate”，按照指示获取或生成签名证书请求（CSR），点击”Continue” 5.点击”Choose File”,选择你的CSR，点击”Generate” 6.点击”Download”下载证书，点击”Done”\n如果KeyChain Access中显示了警示信息，表示未知授权签发证书或者无效证书发行人，那么要确保你已经在钥匙链中安装了WWDR中级证书-G2和Apple Root CA-G2。你可以在这个地方下载这些东西：apple.com/certificateauthority.\n为了在Xcode中启用Apple Pay，打开APP工程文件的Capabilities面板。在Apple Pay这行将开关按钮设置为”ON”，接着选择APP需要使用的ID标示。\n\n\n\n\n\n\n\n\n\n\n注意：在APP排错时，偶尔手动启用Apple Pay很管用。请按照以下步骤手动启用Apple Pay：    1.在会员中心，选择Certificates，Identifiers&amp; Profiles    2.在Identifiers下，选择App IDs    3.选择列表中的app ID，点击”Edit”    4.选择 Apple Pay ，点击”Edit”    5.选择你需要使用的ID标示，点击”Continue”    6.浏览配置参数，点击”Assign”    7.点击”Done”\n#创建支付请求\n创建支付请求\n支付请求是PKPaymentRequest类的实例，它的组成部分包括一个用来表示将要购买的项目的摘要，一个可用的配送方式列表，一个表示用户需要提供的配送信息的描述，以及一些商家和支付平台的信息。\n##判定用户是否能够支付\n在创建支付请求之前，要首先通过调用PKPaymentAuthorizationViewController 类里的canMakePaymentsUsingNetworks:方法来判断用户是否能够使用你提供的支付网络进行支付。如果要判断用户的硬件是否支持Apple Pay或者是否因为家长控制而不能支付，请使用canMakePayments 方法。\nIf canMakePayments returns NO, the device does not support Apple Pay. Do not display the Apple Pay button. Instead, fall back to another method of payment.\nIf canMakePayments returns YES but canMakePaymentsUsingNetworks: returns NO, the device supports Apple Pay, but the user has not added a card for any of the requested networks. You can, optionally, display a payment setup button, prompting the user to set up his or her card. As soon as the user taps this button, initiate the process of setting up a new card (for example, by calling the openPaymentSetup method).\nOtherwise, as soon as the user presses the Apple Pay button, you must begin the payment authorization process. Do not ask the user to perform any other tasks before presenting the payment request. For example, if the user needs to enter a discount code, you must ask for the code before he or she presses the Apple Pay button.\nNOTE\nTo create an Apple Pay–branded button for initiating payment request on iOS 8.3 or later, use the PKPaymentButton class. For iOS 8.2 or earlier, use the resources described in the Apple Pay Identity Guidelines.\nFor additional guidelines on using Apple Pay buttons and payment marks, see Apple Pay in iOS Human Interface Guidelines.\n如果用户不能进行支付，那就不要显示支付按钮，相应的应该退回到其它支付方式。\nBridging from Web-Based Interfaces\nIf your app uses a web-based interface for purchasing goods and services, you must move the request from the web interface to native iOS code before processing an Apple Pay transaction. Listing 3-1 shows the steps needed to process requests from a web view.\nListing 3-1Buying items from a web view// Called when the web view tries to load “myShoppingApp:buyItem”-(void)webView:(nonnull WKWebView *)webViewdecidePolicyForNavigationAction:(nonnull WKNavigationAction *)navigationActiondecisionHandler:(nonnull void (^)(WKNavigationActionPolicy))decisionHandler {\n// Get the URL for the selected link.\nNSURL *URL = navigationAction.request.URL;\n\n// If the scheme and resource specifier match those defined by your app,\n// handle the payment in native iOS code.\nif ([URL.scheme isEqualToString:@&quot;myShoppingApp&quot;] &amp;&amp;\n    [URL.resourceSpecifier isEqualToString:@&quot;buyItem&quot;]) &#123;\n\n    // Create and present the payment request here.\n\n    // The web view ignores the link.\n    decisionHandler(WKNavigationActionPolicyCancel);\n&#125;\n\n// Otherwise the web view loads the link.\ndecisionHandler(WKNavigationActionPolicyAllow);\n\n}\n##支付请求包含货币和地区信息\n所有的汇总金额应该使用同一种货币，货币的信息可使用PKPaymentRequest类的currencyCode属性进行指定。像”USD”这样，使用3个字符格式的ISO货币编码。\n一个支付请求里的国家代码表示了这次购买发生的国家或者将要在这个国家处理这次支付。像”US”这样，使用2个字符格式的ISO国家编码。\n在支付请求里指定的商用ID必须匹配应用中指定的商用ID列表之一。\nrequest.currencyCode = @&quot;USD&quot;;\nrequest.countryCode  = @&quot;US&quot;;\nrequest.merchantIdentifier = @&quot;merchant.com.example&quot;;\n\n##支付请求包含一个支付摘要项目的列表\n支付摘要项目，属于PKPaymentSummaryItem 类，描述了支付请求的不同部分。在一个支付请求里不要使用太多的摘要项目—典型的项目像比如小计金额、折扣信息、配送信息、含税信息以及总计金额等。如果你想要提供更详细的支付项目列表，可以在你应用的其它地方提供。\n每一个摘要项目会有一个标签和数额，就像在代码列表3-1中显示的那样。标签文本是一个用户可阅读的摘要项目描述信息，数额是相对应的支付数额。在一个支付请求中所有的数额都要使用在这个请求中指定的货币。对于折扣或优惠券，则需要把数额设成负数。\nListing 3-2创建支付项目\n// 12.75 subtotalNSDecimalNumber *subtotalAmount = [NSDecimalNumber decimalNumberWithMantissa:1275 exponent:-2 isNegative:NO];self.subtotal = [PKPaymentSummaryItem summaryItemWithLabel:@”Subtotal” amount:subtotalAmount];\n// 2.00 discountNSDecimalNumber *discountAmount = [NSDecimalNumber decimalNumberWithMantissa:200 exponent:-2 isNegative:YES];self.discount = [PKPaymentSummaryItem summaryItemWithLabel:@”Discount” amount:discountAmount];\n\n\n\n\n\n\n\n\n\n注意:这里使用NSDecimalNumber类来存储摘要项目的数额，它是一个以10为底数的数值。可以使用指定尾数和指数的方式（像代码中那样）来创建这个类的实例，也可以通过指定字符串和locale来实例化，字符串指定了相应的数值。这里总是使用以10为底数的数值来做财务计算–例如当需要计算5%折扣掉的金额时。\n尽管有时使用其它的计数方法更方便，但是像float或者Double这样的IEEE浮点数类型是不适合作财务计算的，这些数据类型使用的是以2为底数的数值表示方法，这就表示有一些十进制数值不能准确得被表示–例如0.42必须以0.41999这样的循环小数来近似表示，而这种近似表示常常会造成财务计算的错误结果。\n在这个摘要项目列表中的最后一个是总计金额。这个金额是通过把所有其它金额相加而得到。总计的显示方法和其它的摘要项目不同：应该使用你公司的名称做为其标签，使用所有其它项目的金额总和做为金额。使用paymentSummaryItems 属性将这些摘要项目加入支付请求。\n// 10.75 grand total\nNSDecimalNumber *totalAmount = [NSDecimalNumber zero];\ntotalAmount = [totalAmount decimalNumberByAdding:subtotalAmount];\ntotalAmount = [totalAmount decimalNumberByAdding:discountAmount];\nself.total = [PKPaymentSummaryItem summaryItemWithLabel:@&quot;My Company Name&quot; amount:totalAmount];\nself.summaryItems = @[self.subtotal, self.discount, self.total];\nrequest.paymentSummaryItems = self.summaryItems;\n\n##配送方式是一种特殊的摘要项目\n对于每一种可用的配送方式创建一个PKShippingMethod的实例。就像其它支付摘要项目一样，配送方式包含用户易于辨别的标签，比如”标准配送”或者”第二天配送”，还有一个金额来表示配送费用。与其它摘要项目不同的是，配送方式还有一个detail属性–像”7月29日到达”或者”24小时之内配送”等–可以用来解释各个配送方式之间的区别。\n使用identifier属性来在代理方法中区分不同的配送方式，这个属性只会在你的应用内使用–框架看不到这个属性，并且它也不会出现在UI中。在创建配送方式时为其分配一个独一无二的标识符。为了方便调试，可使用文本缩写，比如”discount”, “standard”, 或者 “next-day”.\n有一些配送方式在某些地区可能不适用，或者有不同的价格，你可以在用户选择配送地址或配送方式的代理方法时更新这些信息，就像Your Delegate Updates Shipping Methods and Costs描述的一样。\n##指定你支持的支付方式\n通过在supportedNetworks属性中填入字符串常量数组来指定你支持的支付网络。通过指定merchantCapabilities属性来指定你支持的支付处理标准，3DS支付方式是必须支持的，EMV方式是可选的。\n商家支持的支付处理标准使用标识位来进行组合，像下面这样：\nrequest.supportedNetworks = @[PKPaymentNetworkAmex, PKPaymentNetworkMasterCard, PKPaymentNetworkVisa];\n// Supports 3DS only\nrequest.merchantCapabilities = PKMerchantCapability3DS;\n// Supports both 3DS and EMV\nrequest.merchantCapabilities = PKMerchantCapability3DS | PKMerchantCapabilityEMV;\n\n##指示所需配送信息和账单信息\n通过填充 requiredBillingAddressFields 和 requiredShippingAddressFields属性来指定所需账单信息和配送地址信息。当你显示一个视图控制器时，它会提示用户输入所需内容。这些字段常量可以像下面这样进行组合来设置这些属性：\nrequest.requiredBillingAddressFields = PKAddressFieldEmail;\nrequest.requiredBillingAddressFields = PKAddressFieldEmail | PKAddressFieldPostalAddress;\n\n如果你已经有了用户的账单和配送信息，可以直接在支付请求中使用它们。但是尽管Apple Pay默认使用了这些信息，用户仍然可以在授权支付的过程中修改这些信息。\nABRecordRef record = ABPersonCreate();\nCFErrorRef error;\nBOOL success;\nsuccess = ABRecordSetValue(record, kABPersonFirstNameProperty, @&quot;John&quot;, &amp;error);\nif (!success) &#123; /* ... handle error ... */ &#125;\nsuccess = ABRecordSetValue(record, kABPersonLastNameProperty, @&quot;Appleseed&quot;, &amp;error);\nif (!success) &#123; /* ... handle error ... */ &#125;\nABMultiValueRef shippingAddress = ABMultiValueCreateMutable(kABMultiDictionaryPropertyType);\nNSDictionary *addressDictionary = @&#123;\n(NSString *) kABPersonAddressStreetKey: @&quot;1234 Laurel Street&quot;,\n(NSString *) kABPersonAddressCityKey: @&quot;Atlanta&quot;,\n(NSString *) kABPersonAddressStateKey: @&quot;GA&quot;,\n(NSString *) kABPersonAddressZIPKey: @&quot;30303&quot;\n&#125;;\nABMultiValueAddValueAndLabel(shippingAddress,\n(__bridge CFDictionaryRef) addressDictionary, kABOtherLabel,nil);\nsuccess = ABRecordSetValue(record, kABPersonAddressProperty, shippingAddress, &amp;error);\nif (!success) &#123; /* ... handle error ... */ &#125;\nrequest.shippingAddress = record;\nCFRelease(shippingAddress);\nCFRelease(record);\n\n存储额外信息\n使用applicationData属性来存储一些在你的应用中关于这次支付请求的唯一标识信息，比如一个购物车的标识符。在用户授权支付之后，这个属性的哈希值会出现在这次支付的token中。\n#授权支付\n支付授权过程是由支付授权view controller和它的代理协作完成的。支付授权view controller做了两件事情：它让用户选择支付请求所必需的账单和配送信息，还有让用户最终授权同意这次支付。当用户和view controller交互时，代理方法就会被调用，这样你的应用就可以不断地更新显示的信息–例如在配送地址更改后更新配送费用。用户最终授权支付请求之后代理方法同样也会被调用。\n\n\n\n\n\n\n\n\n\n注意：在实现这些方法时注意，这些方法可能会被多次调用，而它们被调用的顺序取决于用户的行为的顺序。\n在所有这个授权过程中被调用的代理方法中，都会有一个completion block被做为参数之一传入，支付授权view controller会在一个代理方法执行完毕（通过调用completion块）后再调用另一个代理方法。唯一的例外是paymentAuthorizationViewControllerDidFinish:方法：它不包含completion block，所以它可以在任何时候被调用。\n这个completion block有一个传入参数，基于现有的可用信息，你可以通过这个参数并指定这次交易的状态。如果这次交易没有任何问题，传入PKPaymentAuthorizationStatusSuccess，否则，你要传入一个识别问题的值。\n通过在PKPaymentAuthorizationViewController类的构造方法中传入一个支付请求来对它进行实例化，然后给这个视图控制器设置一个代理，就可以把它展示给用户了。\nPKPaymentAuthorizationViewController *viewController = [[PKPaymentAuthorizationViewController alloc] initWithPaymentRequest:request];\nif (!viewController) &#123; /* ... Handle error ... */ &#125;\nviewController.delegate = self;\n[self presentViewController:viewController animated:YES completion:nil];\n\n当用户与这个视图控制器进行交互时，它的代理方法会被调用。\n通过代理更新配送方式和费用\n当用户提供配送信息之后，授权view controller 会调用paymentAuthorizationViewController:didSelectShippingAddress:completion: 和 paymentAuthorizationViewController:didSelectShippingMethod:completion:这两个代理方法。在这两个方法中根据最新信息来更新支付请求。\n- (void) paymentAuthorizationViewController:(PKPaymentAuthorizationViewController *)controller\n               didSelectShippingAddress:(ABRecordRef)address\n                             completion:(void (^)(PKPaymentAuthorizationStatus, NSArray *, NSArray *))completion\n&#123;\n    self.selectedShippingAddress = address;\n    [self updateShippingCost];\n    NSArray *shippingMethods = [self shippingMethodsForAddress:address];\n    completion(PKPaymentAuthorizationStatusSuccess, shippingMethods, self.summaryItems);\n&#125;\n\n- (void) paymentAuthorizationViewController:(PKPaymentAuthorizationViewController *)controller\n                didSelectShippingMethod:(PKShippingMethod *)shippingMethod\n                             completion:(void (^)(PKPaymentAuthorizationStatus, NSArray *))completion\n&#123;\n    self.selectedShippingMethod = shippingMethod;\n    [self updateShippingCost];\n    completion(PKPaymentAuthorizationStatusSuccess, self.summaryItems);\n&#125;\n\n当支付被授权后，支付token会被创建\n当用户最终授权了一个支付请求，框架会通过与苹果服务器和嵌入在设备中的一个安全模块进行通信，生成一个支付token。然后你在paymentAuthorizationViewController:didAuthorizePayment:completion:方法中将这个token和其它一些你需要用来处理这次购买的信息–例如配送地址和购物车标识–发送给你的服务器。这个过程是这样的：\n框架发送支付请求给安全模块，只有安全模块可以访问存储在设备上的标记化的卡信息。安全模块把特定的卡和商家等支付数据加密，以保证只有苹果可以读取，然后发送给框架。框架会将这些数据发送给苹果。苹果服务器再次加密这些支付数据，以保证只有商家可以读取。然后服务器对它进行签名，生成支付token，然后发送给设备。框架调用相应的代理方法并传入这个token，然后你的代理方法传送token给你的服务器。至于你的服务器采取的行为要取决于你是自己处理这次支付或者你是和其它支付平台合作来进行支付处理。不管怎样，你的服务器处理这个订单然后传送一个状态信息给设备，代理方法会把这个状态信息传送给completion块，像在“Processing a Payment”中讨论过的。\n- (void) paymentAuthorizationViewController:(PKPaymentAuthorizationViewController *)controller\ndidAuthorizePayment:(PKPayment *)payment\ncompletion:(void (^)(PKPaymentAuthorizationStatus))completion\n&#123;\nNSError *error;\nABMultiValueRef addressMultiValue = ABRecordCopyValue(payment.billingAddress, kABPersonAddressProperty);\nNSDictionary *addressDictionary = (__bridge_transfer NSDictionary *) ABMultiValueCopyValueAtIndex(addressMultiValue, 0);\nNSData *json = [NSJSONSerialization dataWithJSONObject:addressDictionary options:NSJSONWritingPrettyPrinted error: &amp;error];\n// ... Send payment token, shipping and billing address, and order information to your server ...\nPKPaymentAuthorizationStatus status;  // From your server\ncompletion(status);\n&#125;\n\n在代理方法中释放授权View Controller\n在框架显示交易状态之后，授权View Controller会调用代理paymentAuthorizationViewControllerDidFinish:的方法。在这个方法的实现中，先释放授权页面控制器再显示你自己的订单确认页面。\n- (void) paymentAuthorizationViewControllerDidFinish:(PKPaymentAuthorizationViewController *)controller\n&#123;\n[controller dismissViewControllerAnimated:YES completion:nil];\n&#125;\n\n#支付处理\n处理一个支付请求涉及以下几个步骤：\n\n\n\n\n\n\n\n\n\n1.把支付信息，以及支付流程+所需的其他信息，一起发送给你的服务器。 2.验证支付数据的哈希表和签名 3.为加密过的支付数据解码 4.向支付处理系统提交支付数据 5.向订单追踪系统提交订单\n处理支付请求时，你有两个选择；你既可以利用支付平台处理支付请求，也可以自己实现支付请求处理流程。一个常用的支付平台可以完成上述大部分操作。\n读取，验证，以及处理支付信息需要有一定的相关密码知识，例如计算SHA-1哈希表，读取和验证PKCS#7签名，执行Elliptic Curve Diffie-Hellman密匙交换。如果没有一定的密码学背景，你可以考虑使用第三方支付平台来完成这些操作。\n关于支持Apple Pay支付平台的更多信息，请参考developer.apple.com/apple-pay/\n处理支付请求所用的信息拥有一种嵌套式的数据结构，如下图。支付令牌是PKPaymentToken类的实例。其paymentData属性值是一个JSON词典，它的头文件信息可以用来验证和加密支付数据。加密过的数据信息包括支付金额、持卡人姓名，以及一些其他指定的支付处理协议。\n\n关于支付数据结构格式的详细信息，请参看：Payment Token Format Reference.\n","slug":"翻译-Apple-Pay编程指南","date":"2016-08-10T12:38:06.000Z","categories_index":"iOS SDK","tags_index":"ApplePay,编程指南","author_index":"William Xie"},{"id":"3c0a0d34cfd9db591b23a050e657ccea","title":"iOS APP 国际化和本地化","content":"","slug":"iOS-APP-国际化和本地化","date":"2016-08-10T11:23:40.000Z","categories_index":"","tags_index":"","author_index":"William Xie"},{"id":"4ed5275dd28725980e50687728d6d44a","title":"Reveal调试和分析UI","content":"","slug":"Reveal调试和分析UI","date":"2016-08-10T11:20:37.000Z","categories_index":"","tags_index":"","author_index":"William Xie"},{"id":"9f6ced9582899d9cc298fd7b7b36a194","title":"Wallet 开发","content":"2012年WWDC上iOS6发布了一个全新的应用–Passbook，管理电子票券，包括登机牌，电影票，优惠卡，购物卡等。2015年苹果全球开发者大会(WWDC 2015)在美国旧金山正式开幕本届主题为“the epicenter of change.（变革的中心）”。苹果在会上宣布其iOS系统自带应用Passbook改名为Wallet，其改名和应用升级也是为了配合Apple Pay的一些功能，此时Wallet除了支持原本的电子票券，还支持信用卡，借记卡，即Apple Pay。 \n","slug":"Wallet开发","date":"2016-08-10T11:08:30.000Z","categories_index":"iOS SDK","tags_index":"Wallet","author_index":"William Xie"},{"id":"00d58d9a73e1bc4a1c001712fc4a5ff9","title":"iBeacon 微定位技术","content":"在一家大型商场,医院或是大楼里,你是否会曾经有过找不到想要去的地方的经历呢?这种情况下采用上面介绍的传统定位方式,就有些”力不从心”了,首先不能采用GPS定位,而WiFi 和蜂窝式移动电话基站定位误差比较大,这种情况下的定位就是 “微定位”技术了\n#地理围栏\n微定位技术中一个比较重要的概念—地理围栏. 地理围栏(Geo-fencing)是LBS的一种新应用,就是用一个虚拟的栅栏围出一个虚拟地理边界. 当手机进入,离开某个特定地理区域,或在该区域活动时,手机可以可以接受自动通知和警告.有了地理围栏技术,位置社交网站就可以帮助用户进入某一个地区时自动登记.\n地理围栏可以采用传统定位或微定位实现,当然微定位更加有现实意义,建立地理围栏技术往往是处于电子商务,店内导航和设计活动等目的. 定位环境比较复杂,定位要求比较精确.\n\n#iBeacon 技术\n苹果公司在iOS 7 之后 支持iBeacon技术,iBeacon技术是苹果公司研发的,它使用低功率蓝牙技术,通过多个iBeacon 基站创建一个信号区域(地理围栏),当设备进去该区域时,相应的应用便会提示用户进入这个地理围栏.\niBeacon 是苹果公司推出的一项室内定位技术，通过软件和硬件的结合，从而大大提高室内精度，从原来的几百米，几十米，提高到一米以内的定位精度。有了这么高精度的定位能力，许多原来只能想一想的事情，现在可以做到了：当你走到某个商品前，手机应用自动跳出商品的介绍，让你的购物体验感，大大增强。下图是一个典型的应用场景：\n\n当用户(安装了特定应用的iOS用户)进入一家大型商场,在门口会有一个iBeacon 基站,它会提示用户是否需要接入这个信号网络。如果用户选择了”是”，他就可以享受到很多服务，iBeacon基站可以核对用户的 Passbook中是否具有本店的某种商品的优惠券或打折卡，当然也可以为用户发放电子优惠打折卡（即pass)，然后存人到passbook中。也可以为用户提供商场的室内导航。最后要结账的时候，iBeacon可以提供零接触支付。\n此外，每个iBeacon基站内置ARM架构cpu、蓝牙模块和闪存，以及加速度计、陀螺仪 寺传愁器。由于采用低功耗蓝牙技术通信，iBeacon基站更加省电，一个小纽扣电池使能为 一个iBeacon基站提供长达两年的续航时间。\n#iBeacon技术实现微定位\niBeacon技术通信的核心是低功耗蓝牙通信，iBeacon基站就是一个外设，它只是负责广播数据，而中心是用户iOS设备上的应用。我们在开发阶段可以使用一个ios设备，在上面安装一个特定应用使其作为iBeacon基站角色。如果不考虑成本，我们可以使用iOS设备作为iBeacon基站，但事实上这样一个方案过于奢侈了，现在已经有一些公司开发出了功能完善的iBeacon技术的基站，它只需要很低的费用就可以构建iBeacon地理围栏。 \n##iBeacon 基站服务端\nimport UIKit\nimport CoreBluetooth\nimport CoreLocation\n// iBeacon UUID\nlet kUUID = \"88936DF5-E10B-4382-89D6-8AE0D80373F8\"\n// 地理围栏区域\nlet kID = \"com.williamxie.AirLocate\"\n// 蓝牙强度\nlet kPower = -59\n\nclass ViewController: UIViewController , CBPeripheralManagerDelegate &#123;\n    //蓝牙低功耗外设管理者\n    var peripheralManager : CBPeripheralManager!\n    \n    override func viewDidLoad() &#123;\n        super.viewDidLoad()\n        \n        self.peripheralManager = CBPeripheralManager(delegate: self, queue: nil)\n        \n    &#125;\n    \n    //广播数据开关\n    @IBAction func valueChanged(sender: AnyObject) &#123;\n        \n        let swc = sender as! UISwitch\n        if swc.on &#123;\n            \n            let uuid = NSUUID(UUIDString: kUUID)\n            //CLBeaconRegion 对象 描述了 基于蓝牙低功耗Beacon 的地理围栏区域\n            // 创建iBeancon 基站 定位标示符 和 地理围栏表示\n            let region = CLBeaconRegion(proximityUUID: uuid!, identifier: kID)\n            //获取iBeacon 基站广播所需数据\n            let peripheralData = region.peripheralDataWithMeasuredPower(kPower)\n            let dict:NSDictionary = peripheralData\n            //进行广播\n            self.peripheralManager.startAdvertising(dict as! [String : AnyObject] )\n            \n        &#125; else &#123;\n        \t//定制广播\n            self.peripheralManager.stopAdvertising()\n        &#125;\n    &#125;\n    \n    //MARK: --实现CBPeripheralManagerDelegate协议\n    func peripheralManagerDidUpdateState(peripheral: CBPeripheralManager) &#123;\n        print(\"外设状态变化\")\n    &#125;\n&#125;\n\n\n##iBeacon 客户端\nViewController.swift\n\nimport UIKit\nimport CoreBluetooth\nimport CoreLocation\n//表示iBeacon 基站\nlet kUUID = \"88936DF5-E10B-4382-89D6-8AE0D80373F8\"\n//表示 地理围栏\nlet kID = \"com.williamxie.AirLocate\"\n//蓝牙强度\nlet kPower = -59\n\nclass ViewController: UIViewController, CLLocationManagerDelegate &#123;\n    \n    @IBOutlet weak var lblRanging: UILabel!\n    \n    var locationManager : CLLocationManager!\n    //地理围栏区域\n    var region : CLBeaconRegion!\n    \n    override func viewDidLoad() &#123;\n        super.viewDidLoad()\n        self.locationManager = CLLocationManager()\n        self.locationManager.delegate = self\n        \n        let uuid = NSUUID(UUIDString: kUUID)\n        self.region = CLBeaconRegion(proximityUUID: uuid!, identifier: kID)\n        \n        self.locationManager.requestAlwaysAuthorization()\n    &#125;\n    //view 销毁的时候停止监听和距离检测\n    override func viewDidDisappear(animated: Bool) &#123;\n        super.viewDidDisappear(false)\n        self.locationManager.stopMonitoringForRegion(self.region)\n        self.locationManager.stopRangingBeaconsInRegion(self.region)\n    &#125;\n    \n    @IBAction func rangValue(sender: AnyObject) &#123;\n        let swc = sender as! UISwitch\n        if swc.on &#123;\n            //开始检测距离\n            self.locationManager.startRangingBeaconsInRegion(self.region)\n        &#125; else &#123;\n            //停止检测距离\n            self.locationManager.stopRangingBeaconsInRegion(self.region)\n        &#125;\n    &#125;\n    \n    \n    @IBAction func onClickMonitoring(sender: AnyObject) &#123;\n        //开始检测范围\n        self.locationManager.startMonitoringForRegion(self.region)\n    &#125;\n    \n    //MARK: --实现CLLocationManagerDelegate委托协议\n    //范围状态变化时候调用\n    func locationManager(manager: CLLocationManager, didDetermineState state: CLRegionState, forRegion region: CLRegion) &#123;\n        let notification = UILocalNotification()\n        //判断是在围栏外还是围栏内\n        if state == .Inside &#123;\n            notification.alertBody = \"你在围栏内\"\n        &#125; else if state == .Outside &#123;\n            notification.alertBody = \"你在围栏外\"\n        &#125; else &#123;\n            return\n        &#125;\n        //发送本地通知\n        UIApplication.sharedApplication().presentLocalNotificationNow(notification)\n     &#125;\n    //在设备将要进入到指定的地理围栏内时候调用\n    func locationManager(manager: CLLocationManager, didEnterRegion region: CLRegion) &#123;\n        let notification = UILocalNotification()\n        notification.alertBody = \"你进入围栏\"\n        UIApplication.sharedApplication().presentLocalNotificationNow(notification)\n    &#125;\n    //在设备将要退出到指定的地理围栏内时候调用\n    func locationManager(manager: CLLocationManager, didExitRegion region: CLRegion) &#123;\n        let notification = UILocalNotification()\n        notification.alertBody = \"你退出围栏\"\n        UIApplication.sharedApplication().presentLocalNotificationNow(notification)\n    &#125;\n    //在指定的围栏中Beacon设备位置变化时调用, beacons是多个beacon设备的数组\n    func locationManager(manager: CLLocationManager, didRangeBeacons beacons: [CLBeacon], inRegion region: CLBeaconRegion) &#123;\n       \n        let aryBeacons = beacons as NSArray\n        //逻辑查询条件对象,用来在内存中过滤集合对象,通过格式化Predicate字符串创建NSPredicate\n        var predicate = NSPredicate(format: \"proximity = %d\", CLProximity.Unknown.rawValue)\n        let unknownBeacons = aryBeacons.filteredArrayUsingPredicate(predicate)\n        if unknownBeacons.count > 0 &#123;\n            self.lblRanging.text = \"未检测到\"\n        &#125;\n        \n        predicate = NSPredicate(format: \"proximity = %d\", CLProximity.Immediate.rawValue)\n        let immediateBeacons = aryBeacons.filteredArrayUsingPredicate(predicate)\n        if immediateBeacons.count > 0 &#123;\n            self.lblRanging.text = \"最接近\"\n        &#125;\n        \n        predicate = NSPredicate(format: \"proximity = %d\", CLProximity.Near.rawValue)\n        let nearBeacons = aryBeacons.filteredArrayUsingPredicate(predicate)\n        if nearBeacons.count > 0 &#123;\n            self.lblRanging.text = \"近距离\"\n        &#125;\n        \n        predicate = NSPredicate(format: \"proximity = %d\", CLProximity.Far.rawValue)\n        let farBeacons = aryBeacons.filteredArrayUsingPredicate(predicate)\n        if farBeacons.count > 0 &#123;\n            self.lblRanging.text = \"远距离\"\n        &#125;\n        \n    &#125;\n&#125;\n\n要用到通知,所以配置通知的环境 在Info.plist 添加字段\n\n`AppDelegate.swift`\n```swift\n    func application(application: UIApplication, didFinishLaunchingWithOptions launchOptions: [NSObject: AnyObject]?) -> Bool &#123;\n        \n        let setting = UIUserNotificationSettings(forTypes: [.Alert, .Badge, .Sound], categories: nil)\n        UIApplication.sharedApplication().registerUserNotificationSettings(setting)\n        \n        return true\n    &#125;\n\n\n\n\n\n参考:\nCLBeaconRegion 类\npublic class CLBeaconRegion : CLRegion &#123;\n\t//identifier 是用来表示地理围栏的\n    public init(proximityUUID: NSUUID, identifier: String)\n    \n    public init(proximityUUID: NSUUID, major: CLBeaconMajorValue, identifier: String)\n    \n    public init(proximityUUID: NSUUID, major: CLBeaconMajorValue, minor: CLBeaconMinorValue, identifier: String)\n\n    public func peripheralDataWithMeasuredPower(measuredPower: NSNumber?) -> NSMutableDictionary\n\n  \t/// 接近UUID 一个128的唯一表示,表示一个或多个iBeacon基站 \n    public var proximityUUID: NSUUID &#123; get &#125;\n    // 主值 它是一个16位的无符号整数，用于区分有相同的接近UUID的 iBeacon基站\n    public var major: NSNumber? &#123; get &#125;\n    // 副值  它是一个16位的无符号整数，用于区分有相同的接近UUID和的主值的iBeacon基站 \n    public var minor: NSNumber? &#123; get &#125;\n    //\n    public var notifyEntryStateOnDisplay: Bool\n&#125;\n","slug":"iBeacon-微定位技术","date":"2016-08-10T11:01:39.000Z","categories_index":"iOS SDK","tags_index":"iBeacon","author_index":"William Xie"},{"id":"89f1cad59352c7f82ca21656f76e183c","title":"Multipeer connectivity 对等结构网络编程","content":"#对等结构网络 \n对等结构网络是苹果的Ad Hoc网络的一种,是在小空间里构建无限网络的解决方案。苹果公司的GameKit或Multipeer Connectivity(多点连接）框架中提供了开发这种网络的APi.\n在iOS7中，引入了一个全新的框架——Multipeer Connectivity(多点连接)。利用Multipeer Connectivity框架，即使在没有连接到WiFi（WLAN）或移动网络（xG）的情况下，距离较近的Apple设备（iMac/iPad/iPhone）之间可基于蓝牙和WiFi（P2P WiFi）技术进行发现和连接实现近场通信。\n\nMultipeer Connectivity扩充的功能与利用AirDrop传输文件非常类似，可以将其看作AirDrop不能直接使用的补偿，代价是需要自己实现。\n多点连接网络,每个点都足对等的,每个对等点都通过”广播服务”和”搜索服务”,\n“广播服务”的目的是为了能够被其他端点搜索到，”搜索服务”的目的是为了是能够搜索到其他端点。 \n当捜索到其他的端点,可以请求建立连接，连接一旦创建.会话（session)也就建义起来了。会话是与网络中运行应用的对等点对应的，每一对等点都会有一个PeerhId作为标示区别彼此。 \n多点连接网络在苹果设备之间进行连接时,链路层采用蓝牙或WiFi实现,并采用 Bonjour发现服务。这些对于开发人员是不可见的,开发人员不用关心它们的细节问题。另外，采用蓝牙连接的对等网络在数据传输时，传输的距离有限制。 \n\n\n\n\n\n\n\n\n\n在Multipeer connectivity框架中主要的类如下:\n\nMCSession:描述连接的会话对象，一个设备的应用创建了会话对象，就可以邀请其他设备加入。 \nMCNearbyServiceAdvertiser :服务广播对象，广播服务告诉附近的对等点，它可以被搜索到。\nMCAdvertiserAssistant:服务广播对象助手类,提供iOS标准要求的确认对话框界面。\nMCNearbyServiceBrowser:服务搜索对象，能够搜索附近发出广播服务的对等点，  \nMCBrowserViewController:提供ios标准搜索界面，通过该界面能够捜索到附近广播服务的对等点，并能够请求连接。\nMCPeerID:PeerId类，在多点连接网格中对等点的唯一标识peerld。 \n\n\n\n\n\n\n\n\n\n\nMultipeer Connectivity框架中上述类相关的协议：\n\nMCSessionDelegate: MCSession的委托协议。\nMCNearbyServiceAdvertiserDelcgale: MCNearbyServiceAdvertiser的委托协议。\nMCNearbvServiceBrowserDelegate: MCNearbyServiceBrowser的委托协议。 \nMCBrowserViewControllerDelegate: MCBrowserViewController的委托协议。\n\n#P2PGame游戏\nimport UIKit\nimport MultipeerConnectivity\n\nlet  GAMING = 0          //游戏进行中\nlet  GAMED  = 1          //游戏结束\n\nclass ViewController: UIViewController, MCSessionDelegate, MCBrowserViewControllerDelegate, UIAlertViewDelegate &#123;\n    \n    @IBOutlet weak var lblTimer: UILabel!\n    @IBOutlet weak var lblPlayer2: UILabel!\n    @IBOutlet weak var lblPlayer1: UILabel!\n    \n    @IBOutlet weak var btnConnect: UIButton!\n    @IBOutlet weak var btnClick: UIButton!\n    \n    var timer : NSTimer!\n    \n    let serviceType = \"P2PGame-service\"\n    \n    var serviceBrowser : MCBrowserViewController!\n    var assistant : MCAdvertiserAssistant!\n    var session : MCSession!\n    var peerID: MCPeerID!\n    \n    override func viewDidLoad() &#123;\n        super.viewDidLoad()\n        \n        self.clearUI()\n        \n        self.peerID = MCPeerID(displayName: UIDevice.currentDevice().name)\n        self.session = MCSession(peer: self.peerID)\n        self.session.delegate = self\n        \n        self.serviceBrowser = MCBrowserViewController(serviceType: serviceType, session: self.session)\n        self.serviceBrowser.delegate = self\n        \n        self.assistant = MCAdvertiserAssistant(serviceType: serviceType, discoveryInfo: nil, session: self.session)\n        self.assistant.start()\n        \n    &#125;\n    \n    override func didReceiveMemoryWarning() &#123;\n        super.didReceiveMemoryWarning()\n    &#125;\n    \n    @IBAction func onClick(sender: AnyObject) &#123;\n        \n        if var count:Int = Int(self.lblPlayer1.text!) &#123;\n            self.lblPlayer1.text = String(format: \"%i\", ++count)\n            \n            let sendStr = String(format:\"&#123;\\\"code\\\":%i,\\\"count\\\":%i&#125;\",GAMING,count)\n            let data = sendStr.dataUsingEncoding(NSUTF8StringEncoding, allowLossyConversion: true)\n            \n            var error : NSError?\n\n            try!  self.session.sendData(data!, toPeers: self.session.connectedPeers, withMode: .Unreliable)\n            \n            if error != nil &#123;\n                NSLog(\"Error sending data:  %@\", error!.localizedDescription)\n            &#125;\n        &#125;\n    &#125;\n    \n    \n    @IBAction func connect(sender: AnyObject) &#123;\n        self.presentViewController(self.serviceBrowser, animated: true, completion: nil)\n    &#125;\n    \n    //清除UI画面上的数据\n    func clearUI() &#123;\n        self.btnClick.enabled = false\n        self.lblPlayer1.text = \"0\"\n        self.lblPlayer2.text = \"0\"\n        self.lblTimer.text = \"30s\"\n        if self.timer != nil &#123;\n            self.timer.invalidate()\n        &#125;\n    &#125;\n    \n    //更新计时器\n    func updateTimer() &#123;\n        \n        var strRemainTime = self.lblTimer.text! as NSString\n        let len = strRemainTime.length\n        strRemainTime = strRemainTime.substringToIndex(len - 1)\n        \n        if var remainTime:Int = Int(strRemainTime as! String) &#123;\n            remainTime--\n            //剩余时间为0 比赛结束\n            if remainTime == 0 &#123;\n                \n                var player1 = Int(self.lblPlayer1.text!)\n                var player2 = Int(self.lblPlayer2.text!)\n                var msg = \"平手\"\n                \n                if player1 > player2 &#123;\n                    msg = \"我获胜\"\n                &#125; else if player1 &lt; player2 &#123;\n                    msg = \"对手获胜\"\n                &#125;\n                \n                let alerView = UIAlertView(title: \"Game Over.\", message:msg, delegate: self, cancelButtonTitle: \"OK\")\n                alerView.show()\n                \n                self.clearUI()\n                \n            &#125; else &#123;\n                self.lblTimer.text = String(format: \"%is\", remainTime)\n            &#125;\n        &#125;\n\n    &#125;\n    \n    //MARK: --实现UIAlertViewDelegate协议\n    func alertView(alertView: UIAlertView, clickedButtonAtIndex buttonIndex: Int) &#123;\n        \n        self.btnClick.enabled = true\n        self.timer = NSTimer.scheduledTimerWithTimeInterval(1.0, target: self,\n            selector: \"updateTimer\",\n            userInfo: nil, repeats: true)\n        \n    &#125;\n    \n    //MARK: --实现MCSessionDelegate协议\n    //端点状态变化\n    func session(session: MCSession!, peer peerID: MCPeerID!, didChangeState state: MCSessionState) &#123;\n  \n        var logmsg = \"\"\n        \n        switch state &#123;\n        case .NotConnected:\n            logmsg = \"断开连接\"\n            dispatch_async(dispatch_get_main_queue()) &#123;\n                self.btnClick.enabled = false\n            &#125;\n        case .Connecting:\n            logmsg = \"连接中...\"\n        case .Connected:\n            logmsg = \"已连接\"\n            dispatch_async(dispatch_get_main_queue()) &#123;\n                self.btnClick.enabled = true\n                self.timer = NSTimer.scheduledTimerWithTimeInterval(1.0, target: self,\n                    selector: \"updateTimer\",\n                    userInfo: nil, repeats: true)\n            &#125;\n        &#125;\n        NSLog(\"Peer [%@] changed state to %@\", peerID.displayName, logmsg)\n    &#125;\n    \n    //接收端点数据\n    func session(session: MCSession!, didReceiveData data: NSData!, fromPeer peerID: MCPeerID!) &#123;\n        \n       let jsonObj = try!  NSJSONSerialization.JSONObjectWithData(data,\n                options: NSJSONReadingOptions.MutableContainers) as! [String : AnyObject]\n        \n        let codeObj = jsonObj[\"code\"] as! Int\n        \n        if codeObj == GAMING &#123;\n            let countObj = jsonObj[\"count\"] as! Int\n            dispatch_async(dispatch_get_main_queue()) &#123;\n                self.lblPlayer2.text = String(format: \"%i\", countObj)\n            &#125;\n        &#125; else if codeObj == GAMED &#123;\n            dispatch_async(dispatch_get_main_queue()) &#123;\n                self.clearUI()\n            &#125;\n        &#125;\n    &#125;\n    \n    // 接收端点数据流方式\n    func session(session: MCSession!, didReceiveStream stream: NSInputStream!, withName streamName: String!, fromPeer peerID: MCPeerID!) &#123;\n        \n    &#125;\n    \n    // 开始端点接收资源\n    func session(session: MCSession!, didStartReceivingResourceWithName resourceName: String!, fromPeer peerID: MCPeerID!, withProgress progress: NSProgress!) &#123;\n        \n    &#125;\n    \n    // 接收端点资源完成\n    func session(session: MCSession!, didFinishReceivingResourceWithName resourceName: String!, fromPeer peerID: MCPeerID!, atURL localURL: NSURL!, withError error: NSError!) &#123;\n        \n    &#125;\n    \n    //MARK: --实现MCNearbyServiceBrowserDelegate协议\n    func browserViewControllerDidFinish(browserViewController: MCBrowserViewController!) &#123;\n        self.dismissViewControllerAnimated(true, completion: nil)\n    &#125;\n    \n    func browserViewControllerWasCancelled(browserViewController: MCBrowserViewController!) &#123;\n        self.dismissViewControllerAnimated(true, completion: nil)\n    &#125;\n    \n&#125;\n\n\n\n\n\n","slug":"Multipeer-connectivity-对等结构网络编程","date":"2016-08-10T10:58:32.000Z","categories_index":"iOS网络编程","tags_index":"Multipeer connectivity","author_index":"William Xie"},{"id":"0cc4b6da7e6dbc367d1a0f5f752f14d7","title":"Bonjour网络编程","content":"#Bonjour 介绍Bonjour(法语”你好’’的意思),它可以使应用不必指定眼务器端口和IP地址就可以以动态发现。 \n发现眼务是通过特定命名搜索服务的.例如”tony. _tonyipp. _tcp.local”这样的命名，发 现服务命名格式如下： &lt;服务名&gt;.〈服务类&gt;.&lt;传输协议名&gt;.&lt;域名&gt; \ntony为服务名,服务名是一个描述性的名字。tonyipp是服务类.可以由开发人员自己命名，也可使用已经注册的服务类型名，例如ipp是打印服务。目前已经注册的服务类型名有400多种，可以在http://www. dns-sd.org/ServiceTypes.html的网址查看。tcp是传输协议，local是本地域名。 \n苹果提供的Bonour编程比较简单，主要是两个类：NSNetServce和NSNetSeowser,以及它们的委托协议NSNetServiceDelegate和NSNetServiceBrowserDelegate。在服务器端需要发布五福,而客户端需要解析服务或查询服务。一旦连接建立起来,捷克语进行通信了,之后的事情和Bonjour无关了。\n\n\n#发布服务\n","slug":"Bonjour网络编程","date":"2016-08-10T10:53:34.000Z","categories_index":"iOS网络编程","tags_index":"Bonjour","author_index":"William Xie"},{"id":"10bb0d48f3c88565c60ee94c3f8f9c4f","title":"HomeKit 编程实例","content":"\n\n#HomeKit智能家居平台\n随着物联网技术的发展,构建智能家居的技术越来越成熟,苹果公司制定了HomeKit智能家居平台硬件规格标准,第三方设备制造商将可以为苹果设备推出大量智能家居产品.设备商都必须参加MFI 授权计划,并严格遵守此前公布的硬件规格要求.\nHomeKit 硬件标准涵盖了包括蓝牙低功耗连接,WiFi连接和安全等规格设计,目前HomeKit只能家居设备包括风扇,车库门,电灯,锁,电源插座,数字开关和韩文琦等家用设备.\n\n\n#HomeKit 开发框架苹果公司给出了HomeKit 平台标准的同时给出了基于HomeKit开发框架 HomeKit.framework. 通过HomeKit框架可以开发基于苹果的设备客户端程序,开发人员不需要关系具体的配件的固件信息,不要关心如何与配件进行通信.HomeKit框架使智能家居的应用开发更加轻松,更加简单.\n#HomeKit 术语\n\n\n\n\n\n\n\n\n\n1.Homes:家庭,用户可以有多个家庭,例如城市的商品房,郊外的别墅. 2.Rooms:家庭中的房间,例如卧室,客厅和厨房等,一个家庭中有多个房间(比如两室一厅). 3.Accessories:外部配件,它是实际智能家居配件,比如电风扇,车库门,电灯,油烟机.这些配件被安装在家庭中,并且又被分配给某个房间. 4.Services:服务,是由配件提供的给用户控制的服务,比如电风扇的电源,电灯的亮度,油烟机的风速大小等.单个配件可以有多个控制服务. 5.Zones: 区域,在家庭中可以对房间进行分组.这样便于控制.比如一楼的房间,孩子们的房间等.\n这些术语对应的对象,在创建的时候需要指定一个唯一的名字,这个名字不仅仅在程序中使用,还可以通过Siri 发出命令,进行语音控制.\nHomeKit APIHomeKit 提供了智能家居开发所需的类和协议:\n主要类:\n\n\n\n\n\n\n\n\n\n1.HMHomeManager:HMHomeManager对象管理一个或者多个家庭集合. 2.HMHome:HMHome对象允许在家庭中安装配件已经进行通信. 3.HMRoom:HMRoom对象被用来代表家庭的一个房间 4.HMAccessory:HMAccessory对象代表一个智能家居配件,比如灯,恒温器 5.HMAccessoryBrowser:HMAccessoryBrowser对象代表一个用来发现新配件的网络浏览器 6.HMService:HMService对象代表提供的服务 7.HMServiceGroup:HMServiceGroup对象代表配件提供的服务的集合,可以将多个服务当做一个实体处理. 8.HMCharacteristic:HMCharacteristic对象代表某个服务的特性,比如灯打开. 9.HMZone:HMZone对象代表一个家庭的集合区域.\n主要协议:\n\n\n\n\n\n\n\n\n\n1.HMHomeManagerDelegate:这个协议定义了HMHomeManager代理对象的接口 2.HMHomeDelegate:该协议定义了家庭委托对象的接口 3.HMAccessoryDelegate:该协议定义配件委托对象的接口,当配件状态更新时回调噶协议方法. 4.HMAccessoryBrowserDelegate:HMAccessoryBrowser委托对象的接口,当发现了新的配件回调改协议方法.\n#HomeKit 编程\nHomeKit编程的流程:\n\n\n\n\n\n\n\n\n\n1.创建家庭2.添加房间到家庭3.查找配件4.在家庭中安装配件5.分配配件到家庭6.从配件中找到服务7.从服务中找到特征8.通过特征读写配件状态*\n上述流程分为两个阶段,1.创建家庭和房间,2.配件查找和控制.创建家庭和房间包括:1,2.配件查找和控制包括:3,4,5,6,7,8\n#实例:Philips Light bulb 控制设计\n\n##配置Xcode 工程创建Philips Light bulb 的工程,开启HomeKit功能呢\n##核心代码\nViewController.swift\nimport UIKit\nimport HomeKit\n\nclass ViewController: UITableViewController &#123;\n    //家庭管理者\n    var homeManager = HMHomeManager()\n\n    override func viewDidLoad() &#123;\n        super.viewDidLoad()\n        self.homeManager.delegate = self\n        self.navigationItem.leftBarButtonItem = editButtonItem\n    &#125;\n    \n    override func viewDidAppear(_ animated: Bool) &#123;\n        super.viewDidAppear(animated)\n        tableView.reloadData()\n    &#125;\n    override func didReceiveMemoryWarning() &#123;\n        super.didReceiveMemoryWarning()\n        // Dispose of any resources that can be recreated.\n    &#125;\n&#125;\n\n// MARK: - UITableViewDelegate\nextension ViewController&#123;\n    \n    override func tableView(_ tableView: UITableView, commit editingStyle: UITableViewCellEditingStyle, forRowAt indexPath: IndexPath) &#123;\n        if editingStyle == .delete &#123;\n            //获取home\n            let home = homeManager.homes[(indexPath as NSIndexPath).row]\n            homeManager.removeHome(home, completionHandler: &#123; (error) -> Void in\n                if error != nil &#123;\n                    print(error)\n                &#125; else  &#123;\n                    tableView.deleteRows(at: [indexPath], with: .automatic)\n                &#125;\n            &#125;)\n        &#125;\n    &#125;\n&#125;\n// MARK: - UITableViewDataSource\nextension ViewController&#123;\n    override func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -> Int &#123;\n        return homeManager.homes.count\n    &#125;\n    override func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell &#123;\n        \n        let cell = tableView.dequeueReusableCell(withIdentifier: \"Cell\", for: indexPath)\n        \n        let home = homeManager.homes[(indexPath as NSIndexPath).row]\n        cell.textLabel!.text = home.name\n        \n        return cell\n    &#125;\n&#125;\n// MARK: - HMHomeManagerDelegate\nextension ViewController : HMHomeManagerDelegate&#123;\n    \n    func homeManagerDidUpdateHomes(_ manager: HMHomeManager) &#123;\n        print(\"home更新\")\n        tableView.reloadData()\n    &#125;\n    func homeManager(_ manager: HMHomeManager, didRemove home: HMHome) &#123;\n        print(\"home已经被移除\")\n    &#125;\n    override func prepare(for segue: UIStoryboardSegue, sender: AnyObject?) &#123;\n        super.prepare(for: segue, sender: sender)\n        if segue.identifier == \"addHome\" &#123;\n            let navController = segue.destination as! UINavigationController\n            let addHomeViewController = navController.topViewController as! AddHomeViewController\n            addHomeViewController.homeManager = homeManager\n            \n        &#125;else if segue.identifier == \"showRooms\"&#123;\n            \n            let listRoomsViewController = segue.destination as! ListRoomsViewController\n            let home = homeManager.homes[tableView.indexPathForSelectedRow!.row]\n            \n            \n            listRoomsViewController.home = home\n        &#125;\n    &#125;\n&#125;\n\nAddHomeViewController.swift\nimport UIKit\nimport HomeKit\nclass AddHomeViewController: UIViewController &#123;\n    \n    @IBOutlet weak var textField: UITextField!\n    \n    var homeManager : HMHomeManager!\n    var home: HMHome!\n    override func viewDidLoad() &#123;\n        super.viewDidLoad()\n        \n        // Do any additional setup after loading the view.\n    &#125;\n    \n    override func viewDidAppear(_ animated: Bool) &#123;\n        super.viewDidAppear(animated)\n        textField.becomeFirstResponder()\n    &#125;\n    \n    override func didReceiveMemoryWarning() &#123;\n        super.didReceiveMemoryWarning()\n        // Dispose of any resources that can be recreated.\n    &#125;\n    \n    @IBAction func save(_ sender: AnyObject) &#123;\n        //添加home\n        homeManager.addHome(withName: textField.text!, completionHandler: &#123;(home, error) -> Void in\n            \n            if error != nil&#123;\n                print(error)\n            &#125;else &#123;\n                self.dismiss(animated: true, completion: nil)\n            &#125;\n        &#125;)\n    &#125;\n    @IBAction func cancel(_ sender: AnyObject) &#123;\n        self.dismiss(animated: true, completion: nil)\n        \n    &#125;\n&#125;\n\nAddRoomViewController.swift\nimport UIKit\nimport HomeKit\nclass AddRoomViewController: UIViewController &#123;\n    \n    @IBOutlet weak var textField: UITextField!\n    \n    var home: HMHome!\n    \n    override func viewDidLoad() &#123;\n        super.viewDidLoad()\n    &#125;\n    \n    override func didReceiveMemoryWarning() &#123;\n        super.didReceiveMemoryWarning()\n    &#125;\n    \n    @IBAction func save(_ sender: AnyObject) &#123;\n        home.addRoom(withName: textField.text!, completionHandler: &#123; (room, error) -> Void in\n            if error != nil &#123;\n                print(error)\n            &#125; else  &#123;\n                self.dismiss(animated: true, completion: nil)\n            &#125;\n        &#125;)\n    &#125;\n    \n    @IBAction func cancel(_ sender: AnyObject) &#123;\n        self.dismiss(animated: true, completion: nil)\n    &#125;\n    \n&#125;\n\nDetailRoomViewController.swift\nimport UIKit\nimport HomeKit\nlet accessoryName = \"Light\"\n\nclass DetailRoomViewController: UIViewController, HMAccessoryBrowserDelegate &#123;\n    \n    var home: HMHome!\n    var room: HMRoom!\n    var lightAccessory: HMAccessory!\n    var accessoryBrowser = HMAccessoryBrowser()\n    \n    var brightnessCharacteristic: HMCharacteristic!\n    var powerStateCharacteristic: HMCharacteristic!\n    \n    @IBOutlet weak var powerSwitch: UISwitch!\n    @IBOutlet weak var brightnessSilder: UISlider!\n    @IBOutlet weak var brightnessValue: UILabel!\n    \n    override func viewDidLoad() &#123;\n        super.viewDidLoad()\n        self.accessoryBrowser.delegate = self\n        self.findAccessory()\n    &#125;\n    \n    override func didReceiveMemoryWarning() &#123;\n        super.didReceiveMemoryWarning()\n    &#125;\n    \n    override func viewDidDisappear(_ animated: Bool) &#123;\n        super.viewDidDisappear(animated)\n        self.accessoryBrowser.stopSearchingForNewAccessories()\n    &#125;\n    \n    func findAccessory()&#123;\n        \n            for accessory in room.accessories &#123;\n                if accessory.name == accessoryName &#123;\n                    self.lightAccessory = accessory\n                &#125;\n            &#125;\n        \n        // 开始查找配件\n        if self.lightAccessory == nil &#123;\n            self.accessoryBrowser.startSearchingForNewAccessories()\n        &#125; else &#123;\n            self.findServicesForAccessory(self.lightAccessory)\n        &#125;\n        \n    &#125;\n    //MARK: --实现HMAccessoryBrowserDelegate协议\n    func accessoryBrowser(_ browser: HMAccessoryBrowser, didFindNewAccessory accessory: HMAccessory) &#123;\n        NSLog(\"发现配件...\")\n        \n        if accessory.name == accessoryName &#123;\n            self.home.addAccessory(accessory, completionHandler: &#123; [weak self] (error) -> Void in\n                \n                if error != nil &#123;\n                    NSLog(\"安装配件失败。\")\n                &#125; else &#123;\n                    self!.home.assignAccessory(accessory, to: self!.room, completionHandler: &#123; (error) -> Void in\n                        self!.findServicesForAccessory(accessory)\n                    &#125;)\n                &#125;\n                \n                &#125;)\n        &#125;\n    &#125;\n    func findServicesForAccessory(_ accessory: HMAccessory)&#123;\n        NSLog(\"查找配件的服务...\")\n        for service in accessory.services &#123;\n            NSLog(\" 服务名 = \\(service.name)\")\n            NSLog(\" 服务类型 = \\(service.serviceType)\")\n            \n            NSLog(\" 查找服务中的特征...\")\n            findCharacteristicsOfService(service)\n        &#125;\n    &#125;\n    \n    func findCharacteristicsOfService(_ service: HMService)&#123;\n        for characteristic in service.characteristics &#123;\n            NSLog(\"   特征类型 = \\(characteristic.characteristicType)\")\n            \n            if characteristic.characteristicType == HMCharacteristicTypeBrightness&#123;\n                brightnessCharacteristic = characteristic\n                brightnessCharacteristic.readValue(completionHandler: &#123; [weak self] (error) -> Void in\n                    if error != nil &#123;\n                        print(error)\n                    &#125; else  &#123;\n                        let oldValue = self!.brightnessCharacteristic.value as! Float\n                        NSLog(\"oldValue : \\(oldValue)\")\n                        self!.brightnessSilder.value = oldValue\n                        self!.brightnessValue.text = String(format: \"%0.0f\", oldValue)\n                    &#125;\n                    &#125;)\n                \n            &#125; else if characteristic.characteristicType == HMCharacteristicTypePowerState &#123;\n                powerStateCharacteristic = characteristic\n                powerStateCharacteristic.readValue(completionHandler: &#123; [weak self] (error) -> Void in\n                    if error != nil &#123;\n                        print(error)\n                    &#125; else  &#123;\n                        let oldValue = self!.powerStateCharacteristic.value as! Bool\n                        NSLog(\"oldValue : \\(oldValue)\")\n                        self!.powerSwitch.setOn(oldValue, animated: true)\n                    &#125;\n                    &#125;)\n            &#125;\n        &#125;\n    &#125;\n    \n    \n    @IBAction func switchValueChanged(_ sender: AnyObject) &#123;\n        let newValue = self.powerSwitch.isOn\n        self.powerStateCharacteristic.writeValue(newValue, completionHandler: &#123;(error) -> Void in\n            if error != nil &#123;\n                print(\"Power状态写入失败: \\(error)\")\n            &#125;\n        &#125;)\n    &#125;\n    \n    @IBAction func silderValueChanged(_ sender: AnyObject) &#123;\n        let newValue = self.brightnessSilder.value\n        self.brightnessCharacteristic.writeValue(newValue, completionHandler: &#123;(error) -> Void in\n            if error != nil &#123;\n                print(\"亮度写入失败:\\(error)\")\n            &#125;\n        &#125;)\n        self.brightnessValue.text = String(format: \"%0.0f\", newValue)\n    &#125;\n    \n&#125;\n\nListRoomsViewController.swift\nimport UIKit\nimport HomeKit\n\nclass ListRoomsViewController: UITableViewController ,HMHomeDelegate&#123;\n    \n    var home: HMHome!\n    \n    override func viewDidLoad() &#123;\n        super.viewDidLoad()\n        home.delegate = self\n    &#125;\n    override func viewDidAppear(_ animated: Bool) &#123;\n        super.viewDidAppear(animated)\n        tableView.reloadData()\n    &#125;\n    override func didReceiveMemoryWarning() &#123;\n        super.didReceiveMemoryWarning()\n    &#125;\n    // MARK: - Table view data source\n    override func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -> Int &#123;\n        return home.rooms.count\n    &#125;\n    override func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell &#123;\n        let cell = tableView.dequeueReusableCell(withIdentifier: \"Cell\", for: indexPath)\n        \n        let room = home.rooms[(indexPath as NSIndexPath).row]\n        cell.textLabel!.text = room.name\n        \n        return cell\n    &#125;\n    \n    //MARK: --实现数据源协议\n    override func tableView(_ tableView: UITableView, commit editingStyle: UITableViewCellEditingStyle, forRowAt indexPath: IndexPath) &#123;\n        if editingStyle == .delete &#123;\n            let room = home.rooms[(indexPath as NSIndexPath).row]\n            home.removeRoom(room, completionHandler: &#123; (error) -> Void in\n                \n                if error != nil &#123;\n                    print(error)\n                &#125; else  &#123;\n                    tableView.deleteRows(at: [indexPath], with: UITableViewRowAnimation.automatic)\n                &#125;\n            &#125;)\n        &#125;\n    &#125;\n    \n    //MARK: --实现HMHomeDelegate协议\n    func home(_ home: HMHome, didAdd room: HMRoom) &#123;\n        print(\"一个房间被创建\")\n    &#125;\n    \n    func home(_ home: HMHome, didRemove room: HMRoom) &#123;\n        print(\"一个房间被删除\")\n    &#125;\n    \n    override func prepare(for segue: UIStoryboardSegue, sender: AnyObject!) &#123;\n        \n        super.prepare(for: segue, sender: sender)\n        \n        if segue.identifier == \"addRoom\"&#123;\n            \n            let navController = segue.destination as! UINavigationController\n            let addRoomViewController = navController.topViewController as! AddRoomViewController\n            addRoomViewController.home = home\n            \n        &#125; else if segue.identifier == \"showDetailRoom\" &#123;\n            \n            let detailRoomViewController = segue.destination as! DetailRoomViewController\n            detailRoomViewController.home = home\n            \n            let indexPath = self.tableView.indexPathForSelectedRow!\n            detailRoomViewController.room = home.rooms[indexPath.row]\n        &#125;\n    &#125;   \n&#125;\n\n##运行测试\n开发者网站下载HardwareIOTools_Xcode_xx.dmg\n\n\n打开模拟器\n点击加号\n创建一个配件\n添加一个服务\n\n选择Light\n\n运行App\n\n\n\n\n\n\n\n\n\n注意:info.plist 填写 NSHomeKitUsageDescription\n授权访问iCloud云端的homekit数据\n添加Home\n在刚刚添加的Home中添加Room\n授权添加配件\n添加room 和模拟器的配件进行配对完成配对,这个时候操作界面的开关,模拟器也会自动调整数据\n项目源代码GitHub\n项目源代码BaiduPan\n#iOS10 Home app使用Home app能够添加所有的HomeKit的配件.下面是一个门的例子\n\n","slug":"HomeKit编程实例","date":"2016-08-10T10:20:01.000Z","categories_index":"智能家居","tags_index":"HomeKit","author_index":"William Xie"},{"id":"3ea9c69504bb57a512c185577723226c","title":"Handoff 编程指南","content":"本文翻译自Apple官方文档：Handoff Programming Guide\n#关于Handoff\nHandoff是iOS 8 和 OS X v10.10中引入的功能，可以让同一个用户在多台设备间传递项目。\nHandoff能让用户从一台设备开始一个项目，然后切换至其他设备继续进行，这一切都是无缝的，每台设备都无需重新配置。例如，用户正在Mac上的Safari浏览一片长文章，随后他可以切换到附近一台已使用相同Apple ID 登入iCloud的iOS设备上，在这台iOS设备上的Safiri中继续浏览相同的网页，页面滚动的位置和原设备上的一样。\n\n\nApple的应用，比如Safari、邮件、地图、联系人、备忘录、日历和提醒事项，在iOS8 和 OS X v10.10中使用公共API来实现Handoff功能。第三方开发者也可以使用相同的API来在应用中实现Handoff，这些应用需要有同一个Team ID。此类应用必须通过App Store发布或者使用注册开发者签名。\n#Handoff交互\n传递用户的活动包括3个阶段：\n\n为用户在你的app中的每一个活动创建一个user activity 对象。\n定期使用用户的最新信息更新user activity 对象。\n当用户请求时，在不同的设备上继续用户的活动。\n\n基于文件的app（也就是基于NSDocument或者UIDocument子类的app）为Handoff的这3个阶段提供了内建支持。响应者对象（NSResponder和UIResponder的子类）为更新user activity和管理当前状态提供了内建支持。你的app可以直接创建、更新和继续user activity，特别是在app delegate中。\nHandoff主要是依赖Foundation中的一个类NSUserActivity，该类支持UIKit和AppKit中的一小部分API。app将用户活动的信息封装在NSUserActivity对象中，这些activity就用来在其他设备上继续活动。特定user activity的Handoff需要最开始的应用把活动的NSUserActivity对象指定为当前activity，保存相关信息，然后把数据发给另一台设备。Handoff只在设备间传递能描述用户活动的必要信息，而大规模的数据同步则由iCloud来处理。\n在“另一台”设备上，会通知用户有一项活动可以继续。如果用户选择继续该活动，系统会启动合适的app，并提供activity中的数据。user activity只能在与原app有相同Team ID 并且支持这种activity类型的app中继续。在app的Infp.plist中的NSUserActivityTypes键下可以设置支持的activity类型。所以，“另一台”设备选择启动哪个app是基于：目标Team ID，起始的NSUserActivity对象的activity type 属性，还可能包括activity对象的title属性。“另一台”设备上的app可以根据user activity对象中userInfo字典的内容来配置UI界面和状态，以实现用户活动的无缝切换。\n另外，如果继续一个activity需要更多的数据，不能使用第一种传输机制来高效传输，那么resuming app可以让起始app的user activity对象在应用间打开流来传输更多数据。例如，用户正在写一封含有图片的电子邮件，那么最好的方法就是流来把这些数据传输到另一台设备上。更多信息参见Using Continuation Streams。\niOS和OS X中基于文件的app已自动支持Handoff，详见Supporting a User Activity in Document-Based Apps（本文内）。\n#User Activity对象\nNSUserActivity对象封装了特定设备、特定应用中用户活动的状态，它是Handoff机制中主要的对象。起始app为每个它支持传递给另一台设备的用户活动创建一个user activity 对象。例如，网页浏览器会为每一个正在浏览网页的标签页或者窗口创建一个user activity 对象。但是只有在前台的标签页或者窗口对应的activity 对象才是当前有效的，只有当前有效的activity才能用于继续用户活动（continuation好难翻译。。。。。。。。）。\nNSUserActivity对象通过它的activityType和title属性来区分。NSUserActivity的userInfo字典里有状态数据，它还有一个叫needsSave的脏标志（dirty flag）来支持delegete的延迟更新状态。NSUserActivity的方法addUserInfoEntriesFromDictionary:允许delegate和其他委托（clients）把状态数据合并到userInfo字典里。\n更多信息参见NSUserActivity Class Reference。\n#User Activity 代理\nUser activity delegate是一个遵从NSUserActivityDelegate协议的对象。它通常是app中顶层对象，比如view controller 或者app delegate。delegate管理着activity与app的交互。\nNSUserActivity的delegate属性就是user activity delegate，负责更新NSUserActivity对象userInfo字典中的数据，以便它可以传递给另一台设备。当系统需要activity更新时，比如活动要在另一台设备上继续之前，系统会调用delegate的userActivityWillSave:方法。你可以实现这个回调来更新对象中承载数据的属性，例如userInfo、title等。一旦系统调用这个方法，它会把needsSave重置为NO。如果userInfo或者其他承载数据的属性又发生变化的话，把这个值改为YES。\n另一方面，除了实现上面所说的delegate的userActivityWillSave:方法之外，你还可以让UIKit或者AppKit自动管理user activity。通过设置响应者对象的userActivity属性，并且实现响应者的updateUserActivityState:回调，app就会选择自动管理user activity，详见Managing a User Activity With Responders（本文内）。选择一个合适你的实现方法。（This arrangement is preferred if it works for your user activity.）\n更多信息参见NSUserActivityDelegate Protocol Reference。\n#App框架支持\nUIKit和AppKit在document、responder和app delegate中为Handoff提供了支持。尽管不同平台之间有一些细小的差别，但是允许app保存和恢复user activity的基本机制是相同的，API也是相同的。\n##在基于文件的app中支持User Activity \n如果你在app的Info.plist里为每个CFBundleDocumentTypes入口添加一个NSUbiquitousDocumentUserActivityType键值对，这样iOS和OS X中基于文件的app就自动自动支持Handoff了。如果有这个键的话，NSDocument和UIDocument就会为特定文件类型的基于iCloud的文件，自动创建NSUserActivity对象。NSUbiquitousDocumentUserActivityType的值是一个字符串，表示NSUserActivity对象的activity type。也就是说，你为基于文件的app所支持的文件类型都提供了一个activity type。多个文件类型可以有同一个activity type。NSDocument和UIDocument会自动把fileURL属性放到activity对象userInfo字典的NSUserActivityDocumentURLKey键下。\n在OS X中，如果app delegate方法application:continueUserActivity:restorationHandler:返回NO，或者没有实现，那么AppKit可以自动恢复用上面方式创建的NSUserActivity对象。在这种情况，文件会使用NSDocumentController的方法openDocumentWithContentsOfURL:display:completionHandler: 来打开，并且会收到一条restoreUserActivityState: 消息。\n更多信息参见Adopting Handoff in Document-Based Apps、NSDocument Class Reference 和 UIDocument Class Reference。\n##用响应者来管理user activity\n如果你把user activity设置为一个响应者对象的userActivity属性，UIKit 和 AppKit就可以管理user activity。当响应者知道activity的状态是已修改（dirty）时，它必须要把activity对象的needsSave属性置为YES。系统会在合适时机自动保存NSUserActivity对象，首先会通过回调updateUserActivityState:给响应者一个机会来更新activity的状态。你的响应者子类必须重写updateUserActivityState:方法来给user activity对象添加状态数据。如果多个响应者共用一个NSUserActivity对象，当系统更新user activity对象时，它们都会收到updateUserActivityState:回调。在更新回调发送之前，activity对象的userInfo字典会被清空。\n在OS X中，NSUserActivity对象由AppKit管理，并与响应者相关联。根据main window 和响应者链，activity对象会自动变为当前有效，也就是在文件的window变为main window时。但是在iOS中，NSUserActivity对象由UIKit管理，你必须显式调用becomeCurrent或者当app进入前台时，给在视图层级中的UIViewController对象设置文件的NSUserActivity对象。\n响应者可以把它的userActivity属性置为nil来断开与activity的关联。当一个由app框架管理的NSUserActivity对象没有关联的响应者和文件时，它就自动无效了。\n更多信息参见Adopting Handoff in Responders、 NSResponder Class Reference 和 UIResponder Class Reference。\n##使用app delegate来继续activity\n在一个不是基于文件的app中，app delegate就是继续user activity的主要入口。当用户选择要继续一个activity时，Handoff会启动合适的app，然后给app delegate发送一条application:willContinueUserActivityWithType:消息。app让用户知道activity马上就可以继续。同时，当app delegate收到 application:continueUserActivity:restorationHandler: 消息时，NSUserActivity 对象会传递过来。你应该实现这个方法，通过user activity对象来恢复activity，配置app的界面。\napplication:continueUserActivity:restorationHandler:消息包括一个恢复处理block，如果你的app使用其他的响应者或者文件对象来恢复user activity，那你可以调用这个block。创建这些对象（如果已经有的话就不用创建了），传入block的NSarray参数中。系统会给每个对象发送一条restoreUserActivityState:消息，并传入user activity对象。每个对象可以用activity的userInfo数据来恢复。关于恢复处理block的更多信息，参见NSApplicationDelegate Protocol Reference中的application:continueUserActivity:restorationHandler: 方法。\n如果你没有实现application:continueUserActivity:restorationHandler:方法或者返回NO，并且你的app是基于文件的，AppKit可以自动恢复activity，这在Supporting User Activity in Document-Based Apps中有描述。更多信息参见Continuing an Activity。\n#Adopting Handoff\nUser activities can be shared among apps that are signed with the same developer team identifier and supporting a given activity type. If an app is document-based, it can opt to support Handoff automatically. Otherwise, apps must adopt a small API in Foundation, as described in this chapter.\n##Identifying User Activities\nThe first step in implementing Handoff is to identify the types of user activities that your app supports. For example, an email app could support composing and reading messages as two separate user activities. A list-handling app could support creating (and editing) list items as one user activity type, and it could support browsing lists and items as another. Your app can support as many activity types as you wish, whatever users do in your app. For each activity type, your app needs to identify when an activity of that type begins and ends, and it needs to maintain up-to-date state data sufficient to enable the activity to continue on another device.\nUser activities can be shared among any apps signed with the same team identifier, and you don’t need a one-to-one mapping between originating and resuming apps. For example, one app creates three different types of activities, and those activities are resumed by three different apps on the second device. This asymmetry can be a common scenario, given the preference for iOS apps to be smaller and more focused on a dedicated purpose than more comprehensive Mac apps.\n##Adopting Handoff in Document-Based Apps\nDocument-based apps on iOS and OS X automatically support Handoff by automatically creating NSUserActivity objects for iCloud-based documents if the app’s Info.plist property list file includes a CFBundleDocumentTypes key of NSUbiquitousDocumentUserActivityType, as shown in Listing 2-1. The value of NSUbiquitousDocumentUserActivityType is a string used for the NSUserActivity object’s activity type. The activity type correlates with the app’s role for the given document type, such as editor or viewer, and an activity type can apply to multiple document types. In Listing 2-1 the string is a reverse-DNS app designator with the name of the activity, editing, appended. If they are represented in this way, the activity type entries do not need to be repeated in the NSUserActivityTypes array of the app’s Info.plist.\nListing 2-1  Info.plist entry for Handoff in document-based apps\n&lt;key&gt;CFBundleDocumentTypes&lt;&#x2F;key&gt;\n&lt;array&gt;\n    &lt;dict&gt;\n        &lt;key&gt;CFBundleTypeName&lt;&#x2F;key&gt;\n        &lt;string&gt;NSRTFDPboardType&lt;&#x2F;string&gt;\n        . . .\n        &lt;key&gt;LSItemContentTypes&lt;&#x2F;key&gt;\n        &lt;array&gt;\n            &lt;string&gt;com.myCompany.rtfd&lt;&#x2F;string&gt;\n        &lt;&#x2F;array&gt;\n        . . .\n        &lt;key&gt;NSUbiquitousDocumentUserActivityType&lt;&#x2F;key&gt;\n        &lt;string&gt;com.myCompany.myEditor.editing&lt;&#x2F;string&gt;\n    &lt;&#x2F;dict&gt;\n&lt;&#x2F;array&gt;\nThe document’s URL is put into the userInfo dictionary with the NSUserActivityDocumentURLKey.\nThe automatically created user activity object is available through the document’s userActivity property and can be referenced by other objects in the app, such as a view controller in iOS or window controller in OS X. This referencing enables apps to track position in a document, for example, or to track the selection of particular elements. The app sets the activity object’s needsSave property to YES whenever that state changes and saves the state in its updateUserActivityState: callback.\nThe userActivity property can be used from any thread. It conforms to the key-value observing (KVO) protocol so that a userActivity object can be shared with other objects that need to be kept in sync as the document moves into and out of iCloud. A document’s user activity objects are invalidated when the document is closed.\n##Implementing Handoff Directly\nAdopting Handoff in your app requires you to write code that uses APIs in UIKit and AppKit provided for creating a user activity object, updating the state of the object to track the activity, and continuing the activity on another device.\n###Creating the User Activity Object\nEvery user activity that can potentially be handed off to a continuing device or designated as searchable is represented by a user activity object instantiated from the NSUserActivity class. An originating app creates a user activity object for each user activity it supports. The nature of those user activities depends on the app. For example, a web browser might designate the user browsing a web page as one activity. The app creates an NSUserActivity instance, as shown in Listing 2-2, whenever the user opens a new window or tab displaying content from a URL, placing the URL in the activity object’s userInfo dictionary, along with the scroll position of the page. Place this code in a controller object such as a window or view controller that has knowledge of the current state of the activity and that can update the state data in the activity object as necessary.\nListing 2-2  Creating the user activity object\nNSUserActivity *myActivity = [[NSUserActivity alloc]\n                             initWithActivityType: @\"com.myCompany.myBrowser.browsing\"];\nmyActivity.userInfo = @&#123; ... &#125;;\nmyActivity.title = @\"Browsing\";\nTo designate an activity as searchable, you can amend the code in Listing 2-2 to include code that provides more information about the activity and sets its eligibility, as shown in Listing 2-3.\nListing 2-3  Designating an activity as searchable\n  myActivity.keywords = [NSSet setWithArray:@[…]];\n// Enable the activity to participate in search results.\n  myActivity.eligibleForSearch = YES;\nAfter setting up an activity, set its state to current, as shown here:\n  [myActivity becomeCurrent];\nWhen your app is finished with an NSUserActivity object, it should call invalidate before deallocating the object. This makes the object disappear from all devices (if it was present) and frees up any system resources devoted to that user activity object.\n###Specifying an Activity TypeThe activity type identifier is a short string appearing in your app’s Info.plist property list file in its NSUserActivityTypes array, which lists all the activity types your app supports. The same string is passed when you create the activity, as shown in Listing 2-2 where the activity object is created with the activity type of com.myCompany.myBrowser.browsing, a reverse-DNS-style notation meant to avoid collisions. When the user chooses to continue the activity, the activity type (along with the app’s Team ID) determines which app to launch on the receiving device to continue the activity.\nNote: You specify the activity type of an NSUserActivity object when you create the instance. You cannot change the activity type of the object after it is created.For example, a Reminders-style app serializes the reminder list the user is looking at. When the user clicks on a new reminder list, the app tracks that activity in the NSUserActivityDelegate. Listing 2-4 shows a possible implementation of a method that gets called whenever the user switches to a different reminder list. This app appends an activity name to the app’s bundle identifier to create the activity type to use when it creates its NSUserActivity object.\nListing 2-4  Tracking a user activity\n // UIResponder and NSResponder have a userActivity property\n NSUserActivity *currentActivity = [self userActivity];\n \n// Build an activity type using the app's bundle identifier\n NSString *bundleName = [[NSBundle mainBundle] bundleIdentifier];\n NSString *myActivityType =\n                 [bundleName stringByAppendingString:@\".selected-list\"];\n \n if(![[currentActivity activityType] isEqualToString:myActivityType]) &#123;\n     [currentActivity invalidate];\n \n     currentActivity = [[NSUserActivity alloc]\n                                   initWithActivityType:myActivityType];\n     [currentActivity setDelegate:self];\n     [currentActivity setNeedsSave:YES];\n \n     [self setUserActivity:currentActivity];\n \n &#125; else &#123;\n \n     // Already tracking user activity of this type\n     [currentActivity setNeedsSave:YES];\n \n &#125;\n\nThe code in Listing 2-4 uses the setNeedsSave: accessor method to mark the user activity object as needing to to be updated. This enables the system to coalesce updates and perform them lazily.\n###Populating the Activity Object’s User Info Dictionary\nThe activity object has a user info dictionary that contains whatever data is needed to hand off the activity to the continuing app. The user info dictionary can contain NSArray, NSData, NSDate, NSDictionary, NSNull, NSNumber, NSSet, NSString, and NSURL objects. The system modifies NSURL objects that use the file: scheme and point at iCloud documents to point to those same items in the corresponding container on the receiving device.\nNote: Transfer as small a payload as possible in the userInfo dictionary—3KB or less. The more payload data you deliver, the longer it takes the activity to resume.Listing 2-5 shows an example that creates a user activity object for an app that reads documents on a website. The activity type, set when the object is created, is shown in reverse-DNS-style notation that specifies the company, app, and finally the particular activity. The webpageURL property represents the URL where the document being read is located, and the user info dictionary is populated with keys and values representing the document’s name and the current page number and scroll position. As the reader progresses through a document, your app needs to keep that information current.\nListing 2-5  Initializing a user info dictionary\nNSUserActivity* myActivity = [[NSUserActivity alloc]\n                      initWithActivityType: @\"com.myCompany.myReader.reading\"];\n \n// Initialize userInfo\nNSURL* webpageURL = [NSURL URLWithString:@\"http://www.myCompany.com\"];\nmyActivity.userInfo = @&#123;\n             @\"docName\" : currentDoc,\n             @\"pageNumber\" : self.pageNumber,\n             @\"scrollPosition\" : self.scrollPosition\n&#125;;\n###Adopting Handoff in RespondersYou can associate responder objects (inheriting from NSResponder on OS X or UIResponder on iOS) with a given user activity if you set the activity as the responder’s userActivity property. The system automatically saves the NSUserActivity object at appropriate times, calling the responder’s updateUserActivityState: override to add current data to the user activity object using the activity object’s addUserInfoEntriesFromDictionary: method.\nListing 2-6  Responder override for updating an activity’s state\n- (void)updateUserActivityState:(NSUserActivity *)userActivity &#123;\n    . . .\n    [userActivity setTitle: self.activityTitle];\n    [userActivity addUserInfoEntriesFromDictionary: self.activityUserInfo];\n&#125;\n##Continuing an Activity\nHandoff automatically advertises user activities that are available to be continued on iOS and OS X devices that are in physical proximity to the originating device and signed into the same iCloud account as the originating device. When the user chooses to continue a given activity, Handoff launches the appropriate app and sends the app delegate messages that determine how the activity is resumed, as described in Continuing an Activity Using the App Delegate.\nImplement the application:willContinueUserActivityWithType: method to let the user know the activity will continue shortly. Use the the application:continueUserActivity:restorationHandler: method to configure the app to continue the activity. The system calls this method when the activity object, including activity state data in its userInfo dictionary, is available to the continuing app.\nNote: For URLs transferred in the userInfo dictionary of an NSUserActivity object, you must call startAccessingSecurityScopedResource and it must return YES before you can access the URL. Call stopAccessingSecurityScopedResource when you are done using the file.Exceptions to this requirement are URLs of UIDocument documents and those of NSDocument that are automatically created for apps specifying NSUbiquitousDocumentUserActivityType and returning NO from application:continueUserActivity:restorationHandler: (or leaving it unimplemented). See Adopting Handoff in Document-Based Apps.Additional configuration of your app for continuing the activity can optionally be performed by objects you give to the restoration handler block that is passed in with the application:continueUserActivity:restorationHandler: message. Listing 2-7 shows a simple implementation of this method.\nListing 2-7  Continuing a user activity\n- (BOOL)application:(NSApplication *)application\n             continueUserActivity: (NSUserActivity *)userActivity\n             restorationHandler: (void (^)(NSArray *))restorationHandler &#123;\n \n    BOOL handled = NO;\n \n    // Extract the payload\n    NSString *type = [userActivity activityType];\n    NSString *title = [userActivity title];\n    NSDictionary *userInfo = [userActivity userInfo];\n \n    // Assume the app delegate has a text field to display the activity information\n    [appDelegateTextField setStringValue: [NSString stringWithFormat:\n        @\"User activity is of type %@, has title %@, and user info %@\",\n        type, title, userInfo]];\n \n    restorationHandler(self.windowControllers);\n    handled = YES;\n \n    return handled;\n&#125;\nIn this case, the app delegate has an array of NSWindowController objects, windowControllers. These window controllers know how to configure all of the app’s windows to resume the activity. After you pass that array to the restorationHandler block, Handoff sends each of those objects a restoreUserActivityState: message, passing in the resuming activity’s NSUserActivity object. The window controllers inherit the restoreUserActivityState: method from NSResponder, and each controller object overrides that method to configure its window, using the information in the activity object’s userInfo dictionary.\nTo support graceful failure, the app delegate should implement the application:didFailToContinueUserActivityWithType:error: method. If you don’t implement that method, the app framework nonetheless displays diagnostic information contained in the passed-in NSError object.\nNote: The UIApplicationDelegate methods for handoff, described in this section, are not called when either of the application delegate methods application:willFinishLaunchingWithOptions: or application:didFinishLaunchingWithOptions: returns NO.\n##Native App–to–Web Browser Handoff\nWhen using a native app on the originating device, the user may want to continue the activity on another device that does not have a corresponding native app. If there is a web page that corresponds to the activity, it can still be handed off. For example, video library apps enable users to browse movies available for viewing, and mail apps enable users to read and compose email, and in many cases users can do the same activity though a web-page interface. In this case, the native app knows the URL for the web interface, possibly including syntax designating a particular video being browsed or message being read. So, when the native app creates the NSUserActivity object, it sets the webpageURL property, and if the receiving device doesn’t have an app that supports the user activity’s activityType, it can resume the activity in the default web-browser of the continuing platform.\nA web browser on OS X that wants to continue an activity in this way should claim the NSUserActivityTypeBrowsingWeb activity type (by entering that string in its NSUserActivityTypes array in the app’s Info.plist property list file). This ensures that if the user selects that browser as their default browser, it receives the activity object instead of Safari.\n##Web Browser–to–Native App Handoff\nIn the opposite case, if the user is using a web browser on the originating device, and the receiving device is an iOS device with a native app that claims the domain portion of the webpageURL property, then iOS launches the native app and sends it an NSUserActivity object with an activityType value of NSUserActivityTypeBrowsingWeb. The webpageURL property contains the URL the user was visiting, while the userInfo dictionary is empty.\nThe native app on the receiving device must opt into this behavior by claiming a domain in the com.apple.developer.associated-domains entitlement. The value of that entitlement has the format :, for example, activitycontinuation:example.com. In this case the service must be activitycontinuation. To match all subdomains of an associated domain, you can specify a wildcard by prefixing *. before the beginning of a specific domain (the period is required). Add the value for the com.apple.developer.associated-domains entitlement in Xcode in the Associated Domains section under the Capabilities tab of the target settings. You specify should specify no more than about 20 to 30 domains.\nIf that domain matches the webpageURL property, Handoff downloads a list of approved app IDs from the domain. Domain-approved apps are authorized to continue the activity. On your website, you list the approved apps in a JSON file named apple-app-site-association, for example, https://example.com/apple-app-site-association. (You must use an actual device, rather than the simulator, to test downloading the JSON file.) Handoff first searches for the file in the .well-known subdirectory (for example, https://example.com/.well-known/apple-app-site-association), falling back to the top-level domain if you don’t use the .well-known subdirectory.\nThe JSON file contains a dictionary that specifies a list of app identifiers in the format . in the General tab of the target settings, for example, YWBN8XTPBJ.com.example.myApp. Listing 2-8 shows an example of such a JSON file formatted for reading.\nListing 2-8  Server-side web credentials\n&#123;\n    \"activitycontinuation\": &#123;\n    \"apps\": [    \"YWBN8XTPBJ.com.example.myApp\",\n                 \"YWBN8XTPBJ.com.example.myOtherApp\" ]\n    &#125;\n&#125;\nNote: In apps that run in iOS 9.3.1 and later, the size of the apple-app-site-association file (uncompressed) must be no greater than 128 KB, regardless of whether the file is signed. Because the list of paths in the association file should be kept short, you can use wildcard matching to match larger sets of paths.If your app runs in iOS 9 or later, the apple-app-site-association file may be a JSON file with a MIME type of application/json, and you don’t need to sign it. If your app runs in iOS 8, the file must be CMS signed by a valid TLS certificate and have a MIME type of application/pkcs7-mime. To sign the JSON file, put the content into a text file and sign it. You can perform this task with Terminal commands such as those shown in Listing 2-9, removing the white space from the text for ease of manipulation, and using the openssl command with the certificate and key for an identity issued by a certificate authority trusted by iOS (that is, listed at http://support.apple.com/kb/ht5012). It need not be the same identity hosting the web credentials (https://example.com in the example listing), but it must be a valid TLS certificate for the domain name in question.\nListing 2-9  Signing the credentials file\necho '&#123;\"activitycontinuation\":&#123;\"apps\":[\"YWBN8XTPBJ.com.example.myApp\",\"YWBN8XTPBJ.com.example.myOtherApp\"]&#125;&#125;' > json.txt\n \ncat json.txt | openssl smime -sign -inkey example.com.key\n                             -signer example.com.pem\n                             -certfile intermediate.pem\n                             -noattr -nodetach\n                             -outform DER > apple-app-site-association\nThe output of the openssl command is the JSON file that you put on your website at the apple-app-site-association URL, in this example, https://example.com/apple-app-site-association.\nAn app can set the webpageURL property to any web URL, but it only receives activity objects whose webpageURL domain is in its com.apple.developer.associated-domains entitlement. Also, the scheme of the webpageURL must be http or https. Any other scheme throws an exception.\n###Using Continuation Streams\nIf resuming an activity requires more data than can be efficiently transferred by the initial Handoff payload, a continuing app can call back to the originating app’s activity object to open streams between the apps and transfer more data. In this case, the originating app sets its NSUserActivity object’s Boolean property supportsContinuationStreams to YES, sets the user activity delegate, then calls becomeCurrent, as shown in Listing 2-10.\nListing 2-10  Setting up streams\nNSUserActivity* activity = [[NSUserActivity alloc] init];\nactivity.title = @\"Editing Mail\";\nactivity.supportsContinuationStreams = YES;\nactivity.delegate = self;\n[activity becomeCurrent];\nOn the continuing device, after users indicate they want to resume the activity, the system launches the appropriate app and begins sending messages to the app delegate. The app delegate can then request streams back to the originating app by sending its user activity object the getContinuationStreamsWithCompletionHandler: message, as shown in the override implementation in Listing 2-11.\nListing 2-11  Requesting streams\n- (BOOL)application:(UIApplication *)application\n        continueUserActivity: (NSUserActivity *)userActivity\n        restorationHandler: (void(^)(NSArray *restorableObjects))restorationHandler\n&#123;\n    [userActivity getContinuationStreamsWithCompletionHandler:^(\n                        NSInputStream *inputStream,\n                        NSOutputStream *outputStream, NSError *error) &#123;\n \n        // Do something with the streams\n \n        &#125;];\n \n    return YES;\n&#125;\nOn the originating device, the user activity delegate receives the streams in a callback to its userActivity:didReceiveInputStream:outputStream: method, which it implements to provide the data needed to continue the user activity on the resuming device using the streams.\nNSInputStream provides read-only access to stream data, and NSOutputStream provides write-only access. Therefore, data written to the output stream on the originating side is read from the input stream on the continuing side, and vice versa. Streams are meant to be used in a request-and-response fashion; that is, the continuing side uses the streams to request more continuation data from the originating side which then uses the streams to provide the requested data.\nContinuation streams are an optional feature of Handoff, and most user activities do not need them for successful continuation. Even when streams are needed, in most cases there should be minimal back and forth between the apps. A simple request from the continuing app accompanied by a response from the originating app should be enough for most continuation events.\n##Best Practices\nImplementing successful continuation of activities requires careful design because numerous and various components, apps, software objects, and platforms can be involved.\n\nTransfer as small a payload as possible in the userInfo dictionary—3KB or less. The more payload data you deliver, the longer it takes the activity to resume.\n\nWhen a large amount of data transfer is unavoidable, use streams, but recognize that they have a cost in terms of network setup and overhead.\n\nPlan for different versions of apps on different platforms to work well with each other or fail gracefully. Remember that the complementary app design can be asymmetrical—for example, a monolithic Mac app can route each of its activity types to smaller, special-purpose apps on iOS.\n\nUse reverse-DNS notation for your activity types to avoid collisions. If the activity pertains only to a single app, you can use the app identifier with an extra field appended to describe the activity type. For example, use a format such as com..., as in com.myCompany.myEditor.editing. If you have a user activity that works across more than one app, you can drop the app field, as in com.myCompany.editing.\n\nTo update the activity object’s userInfo dictionary efficiently, configure its delegate and set its needsSave property to YES whenever the userInfo needs updating. At appropriate times, Handoff invokes the delegate’s userActivityWillSave: callback, and the delegate can update the activity state.\n\nBe sure the delegate of the continuing app implements its application:willContinueUserActivityWithType: to let the user know the activity will be continued. The user activity object may not be available instantly.In addition to these best practices, there are a few things you should do to ensure that users have a great search experience.\n\nWhen users tap a result, take them directly to the appropriate area in your app. As much as possible, avoid presenting intervening screens or experiences that delay users from reaching the content they’re interested in.\n\nAvoid over-indexing your app content or adding unrelated keywords and attributes in an attempt to improve the ranking of your results. Items that users don’t find useful are quickly identified and can eventually stop showing up in results.\n\nIn general, provide a thumbnail image and a succinct title for each activity to enrich the search results.\n\n\nIf you also use Core Spotlight APIs to index user content in your app, use a unique ID to relate a user activity and an item. (To learn more about Core Spotlight APIs, see Core Spotlight Framework Reference.) For example:\n// Create an attribute set that specifies a related unique ID for a Core Spotlight item.\nCSSearchableItemAttributeSet *attributes = [[CSSearchableItemAttributeSet alloc] initWithItemContentType:@\"public.image\"];\nattributes.relatedUniqueIdentifier = coreSpotlightUniqueIdentifier;\n\n// Use the attribute set to create an NSUserActivity that's related to a Core Spotlight item.\n\nNSUserActivity *myActivity = [[NSUserActivity alloc] initWithActivityType:@“com.mycompany.viewing-message”];\nmyActivity.contentAttributeSet = attributes;\n","slug":"Handoff-编程指南","date":"2016-08-10T10:10:28.000Z","categories_index":"iOS SDK","tags_index":"Handoff","author_index":"William Xie"},{"id":"79d37eeff247a26cb1e49e04acbf72e8","title":"HomeKit 开发指南","content":"#第一部分：简介\n该文档旨在帮你编写HomeKit app。HomeKit库是用来沟通和控制家庭自动化配件的，这些家庭自动化配件都支持苹果的HomeKit Accessory Protocol。HomeKit应用程序可让\n用户发现兼容配件并配置它们。用户可以创建一些action来控制智能配件（例如恒温或者光线强弱），对其进行分组，并且可以通过Siri触发。HomeKit 对象被存储在用户iOS设备的数据库中，并且通过iCloud还可以同步到其他iOS设备。HomeKit支持远程访问智能配件，并支持多个用户设备和多个用户。HomeKit 还对用户的安全和隐私做了处理。\n\n\n\n\n\n\n\n\n\n\n\n\n注意：如果你是开发设计HomeKit硬件的供应商，你可以去Hardware Developers下的HomeKit页面了解MFi Program相关信息，也可以阅读 External Accessory Programming Topics\n另请参阅\n以下资源提供了更多关于创建HomeKit应用程序的信息：HomeKit User Interface Guidelines 提供了用户界面设计指南App Store Review Guidelines: HomeKit 提供了加快app审核的技巧HomeKit Framework Reference 描述了HomeKit框架中的类和方法External Accessory Framework Reference 列出了系统提供的发现和配置无线智能家居产品UIHomeKit Catalog 提供示例演示HomeKit特性WWDC 2014: Introducing HomeKit 对HomeKit更高层次的分析iOS Security 描述HomeKit如何处理iOS上的安全和隐私\n\n#第二部分：启用HomeKit\nHomeKit应用服务只提供给通过App Store发布的app应用程序。在你的Xcode工程中， HomeKit应用程序需要额外的配置，你的app必须有开发证书和代码签名才能使用HomeKit。在Xcode的Capabilities面板使用HomeKit，可避免代码签名的问题。你无需直接在Xcode或者会员中心编辑授权文件（entitlements）。\n##设置\n为了完成本文档中所有步骤，你需要：\n\n\n\n\n\n\n\n\n\n1.一个安装Xcode 6 或者Xcode 6 以上版本的Mac电脑。 2.为了获得最佳体验，你的Mac电脑上最好安装最新的OS X 系统和最新的Xcode 版本。 3.加iOS开发者计划。 4.在Member Center 拥有创建代码签名和资源配置的权限。\n在你开始使用HomeKit之前，请确保你已经完成以下任务。创建你团队的配置文件（Provisioning Profile），请参阅：App Distribution Quick Start.\n\n当你成功地完成了之前的任务后，General面板中Team弹出菜单中的错误信息和问题修复按钮将会消失。代码签名配置被成功创建后会展示下方的General面板。\n\n解决代码签名和证书配置问题，请参阅 App Distribution Guide文档中Troubleshooting这一节。\n##启用HomeKit\n想要使用HomeKit，首先要启用它。Xcode将会添加HomeKit权限到你的工程授权文件中和会员中心的App ID授权文件中，也会将HomeKit框架添加到你的工程中。HomeKit 需要一个明确的App ID, 这个App ID是为了你完成这些步奏而创建的。\n启用HomeKit的步骤如下：\n\n\n\n\n\n\n\n\n\n1.在Xcode中，选择View &gt; Navigators &gt; Show Project Navigator。 2.从Project/Targets弹出菜单中target（或者从Project/Targets的侧边栏） 3.点击Capabilities查看你可以添加的应用服务列表。 4.滑到HomeKit 所在的行并打开关。\n##下载HomeKit Accessory Simulator\n无需为了开发Homekit 应用程序而购买硬件产品。你可以使HomeKit Accessory Simulator来测试HomeKit app和模拟配件设备之间的通信。HomeKit Accessory Simulator不是和Xcode一起发布的。 \n下载HomeKit Accessory Simulator步骤如下：\n\n\n\n\n\n\n\n\n\n1.在Capabilities面板的HomeKit分区，点击Download HomeKit Accessory Simulator按钮。（或者选择Xcode &gt; Open Developer Tool &gt; More Developer Tools） 2.在浏览器中搜索并且下载”Hardware IO Tools for Xcode “.dmg文件。 3.在 Finder中双击~/Downloads中的.dmg文件。 4.把HomeKit Accessory Simulator拖拽到/Application文件中。\n之后，你将可以使用HomeKit Accessory Simulator测试你的HomeKit应用程序，正如Testing YourHomeKit App中描述的那样。\n#第三部分：创建Home布局\nHomeKit 允许用户创建一个或者多个Home布局。每个Home（HMHome）代表一个有网络设备的住所。用户拥有Home的数据并可通过自己的任何一台iOS设备进行访问。用户也可以和客户共享一个Home，但是客户的权限会有更多限制。被指定为primary home的home默认是Siri指令的对象，并且不能指定home。\n每个Home一般有多个room，并且每个room一般会有多个智能配件。在home(HMHome) 中，每个房间是独立的room，并具有一个有意义的名字，例如“卧室”或者“厨房”，这些名字可以在Siri 命令中使用。一个accessory（HMAccessory）代表实际家庭中的自动化设备，例如车库开门器。一个sevice（HMService）是accessory提供的?种实际服务，例如打开或者关闭车库，或者车库上的灯。\n\n如果你的app 缓存了home布局的信息，那么当其布局发声改变的时候，app就需要更新这些信息。使用HMHomeManager对象可以从HomeKit数据库获取HMHome和其他相关的对象。本章描述的API获取对象后，你应该通过代理回调函数保持获取对象和HomeKit数据库同步，具体描述请参看“Observing HomeKit Database Changes“.\n##创建 Home Manager对象使用Home Manager—一个HMHomeManager对象的访问home、room、配件、服务以及其他HomeKit对象。在创建家庭对象管理器（home manager）之后，直接设置它的代理，以便获取到这些对象之后及时的通知到你。\nself.homeManager = [[HMHomeManager alloc] init];\nself.homeManager.delegate = self;\n\n当你创建一个home manager对象时，HomeKit就开始从HomeKit数据库获取这些homes和相关对象，例如room和accessory对象。当HomeKit正在获取那些对象时，home manager 的primaryHome属性是nil，并且homes属性是个空数组。你的app应该处理用户还没有完成创建home的情况，但是app应该等待直到HomeKit完成初始化。当获取对象完成之后，HomeKit 会发送homeManagerDidUpdateHomes:消息给home manager的代理。\n\n\n\n\n\n\n\n\n\n注意：当app进入前台或者在后台Home manager属性发生改变时，这个homeManagerDidUpdateHomes:方法就会被调用，详情请参阅“Observing Changes to the Collection of Homes”。\n##获取Primary Home和 Homes集合通过home manager的primaryHome属性，可以得到primary home，代码如下：\nHMHome *home = self.homeManager.primaryHome;\n\n使用home manager的homes属性可以得到用户的所有home的集合；例如自家主要居所、度假别墅以及办公室。每个home都对应一个独立的home对象。\nHMHome *home;\n for(home in self.homeManager.homes )&#123;\n ...\n&#125;\n\n##获取 Home中的所有room在一个home中，rooms属性定义accessories的物理位置。用home的rooms属性可以枚举home中的所room。\nHMHome *home = self.homeManager.primaryHome;\n HMRome *room;\n for(room in home.rooms)&#123;\n     ...\n &#125;\n\n##获取Room 中的AccessoriesAccessories 数组属于home，但是被指定给了home中的room。假如用户没有给一个accessory指定room，那么这个accessories被指定一个默认的room ,这个room是roomForEntireHome方法的返回值。用room的accessories属性可以枚举room中所有的accessory。代码如下：\nHMAccessory *accessory;\n for(accessory in room.accessories)&#123;\n …\n &#125;\n\n如果你要展示一个个accessory的相关信息或者允许用户控制它，可设置accessory的代理方法并实现这个代理方法，详情请见“Observing Changes to Accessories”.一旦你获取到一个accessory对象，你就可以访问它的服务和对象，详情请参阅“Accessing Services and Characteristics”。\n##获取Home中的Accessories属性使用HMHome类中的accessories的方法，可以直接从Home对象中获取所有的accessory对象，而不用枚举home中的所有room对象（详情请见“Getting the Accessories in a Room”)。\n#第四部分：创建Homes和添加Accessories\nHomeKit对象被保存在一个可以共享的HomeKit数据库里，它可以通过HomeKit框架被多个应英程序访问。所有HomeKit调用的方法都是异步写入的，并且这些方法都包含一个完成处理后的参数。如果这个方法处理成功了，你的应用将会在完成处理函数里更新本地对象。应用程序启动时，HomeKit对象发生改变的并不能收到代理回调?法，只能接受处理完成后的回调函数。\n想要观察其他应用程序启动时HomeKit对象的变化，请参阅：Observing HomeKit Database Changes。查阅异步消息完成处理后传过来的错误码的信息，请参阅：HomeKit Constants Reference.\n##对象命名规则\nHomeKit对象的名字，例如home、room和zone对象都可以被Siri识别，这一点已经在文档中指出。以下几点是HomeKit对象的命名规则：\n\n\n\n\n\n\n\n\n\n1.对象名字在其命名空间内必须是唯一的。2.属于用户所有的home名字都在一个命名空间内。3.一个home对象及其所包含的对象在另一个命名空间内。4.名字只能包含数字、字母、空格以及省略号字符。5.名字必须以数字或者字母字符开始。6.在名字比较的时候,空格或者省略号是忽略的（例如home1和home 1 同一个名字）。7.名字没有大小写之分。\n想了用户可以使用哪些语言与Siri进行交互，请参阅HomeKit User Interface Guidelines文档中的”Siri Integration”\n##创建Homes\n在HMHomeManager类中使用addHomeWithName:completionHandler:异步方法可以添加一个home。作为参数传到那个方法中的home的名字，必须是唯一独特的，并且是Siri可以识别的home名字。\n[self.homeManager addHomeWithName:@&quot;My Home&quot; completionHandler:^(HMHome *home, NSError *error) &#123;\n    if (error != nil) &#123;\n        // Failed to add a home\n    &#125; else &#123;\n        // Successfully added a home\n    &#125; \n&#125;];\n\n在else语句中，写入代码以更新你应的程序的视图。为了获取home manager对象，请参阅Getting the Home Manager Object.\n##在Home中增加一个Room\n使用addRoomWithName:completionHandler:异步方法可以在一个home中添加一个room对象。作为参数传到那个方法中的room的名字，必须是唯一独特的，并且是Siri可识别的room名字。\nNSString *roomName = @&quot;Living Room&quot;;\n[home addRoomWithName:roomName completionHandler:^(HMRoom *room, NSError *error) &#123;\n    if (error != nil) &#123;\n        // Failed to add a room to a home\n    &#125; else &#123;\n        // Successfully added a room to a home\n    &#125; \n&#125;];\n\n在else语句中，写入代码更新应用程序的视图。\n##发现配件\nAccessories封装了物理配件的状态，因此它不能被用户创建。想要允许用户给家添加新的配件，我们可以使HMAccessoryBrowser对象找到一个与home没有关联的配件。HMAccessoryBrower对象在后台搜寻配件，当它找到配件的时候，使用委托来通知你的应用程序。只有在startSearchingForNewAccessories方法调用之后或者stopSearchingForNewAccessories方法调用之前，HMAccessoryBrowserDelegate消息才被发送给代理对象。\n发现home中的配件1.在你的类接口中添加配件浏览器委托协议，并且添加一个配件浏览器属性。代码如下：\n@interface EditHomeViewController ()&lt;HMAccessoryBrowserDelegate&gt;\n@property HMAccessoryBrowser *accessoryBrowser;\n@end\n\n用你自己的类名代替EditHomeViewController\n2.创建配件浏览器对象，并设置它的代理\nself.accessoryBrowser = [[HMAccessoryBrowser alloc] init];\nself.accessoryBrowser.delegate = self;\n\n3.开始搜寻配件\n[ self.accessoryBrowser startSearchingForNewAccessories];\n\n4.将找到的配件添加到你的收藏里\n- (void)accessoryBrowser:(HMAccessoryBrowser *)browser didFindNewAccessory:(HMAccessory *)accessory &#123;\n    // Update the UI per the new accessory; for example,reload a picker view.\n    [self.accessoryPicker reloadAllComponents];\n&#125;\n\n用你自己的代码实现上面的accessoryBrowser:didFindNewAccessory:方法。 当然也可以实现accessoryBrowser:didRemoveNewAccessory: 这个方法来移除配件，这个配件对你的视图或者收藏来说不再是新的。\n5.停止搜寻配件\n如果一个视图控制器正在开始搜寻配件，那么可以通过重写viewWillDisappear:方法来停止搜寻配件。代码如下：\n- (void)viewWillDisappear:(BOOL)animated &#123;\n\n    [self.accessoryBrowser stopSearchingForNewAccessories];\n&#125;\n\n\n\n\n\n\n\n\n\n\n注意： 在WiFi网络环境下，为了安全地获取新的并且能够被HomeKit发现的无线配件，请参阅External Accessory Framework Reference.\n##为Home和room添加配件（Accessory）\n配件归属于home，并且它可以被随意添加到home中的任意一个room中。使用addAccessory:completionHandler:这个异步方法可以在home中添加配件。这个配件的名字作为一个参数传递到上述异步方法中，并且这个名字在配件所属的home中必须是唯一的。使用assignAccessory:toRoom:completionHandler: 这个异步方法可以给home中的room添加配件。配件默认的room是roomForEntireHome这个方法返回值room。下面的代码演示了如何给home和room添加配件:\n// Add an accesory to a home and a room\n// 1. Get the home and room objects for the completion handlers.\n\n__block HMHome *home = self.home;\n__block HMRoom *room = roomInHome;\n\n// 2. Add the accessory to the home\n[ home addAccessory:accessory completionHandler:^(NSError *error) &#123;\n    if (error) &#123;\n        // Failed to add accessory to home\n    &#125; else &#123;\n        if (accessory.room != room) &#123;\n            // 3. If successfully, add the accessory to the room\n\n            [home assignAccessory:accessory toRoom:room completionHandler:^(NSError *error) &#123;\n                if (error) &#123;\n                        // Failed to add accessory to room\n                &#125; &#125;];\n        &#125; &#125;\n&#125;];\n\n配件可提供一项或者多项服务，这些服务的特性是由制造商定义。想了解配件的服务和特性目的，请参阅 Accessing Services and Characteristics.\n##更改配件名称\n使用updateName:completionHandler: 异步方法可以改变配件的名称，代码如下：\n[accessory updateName:@&quot;Kid&#39;s Night Light&quot; completionHandler:^(NSError *error) &#123;\n    if (error) &#123;\n        // Failed to change the name\n    &#125; else &#123;\n        // Successfully changed the name\n    &#125;\n&#125;];\n\n##为Homes和Room添加Bridge（桥接口）\n桥接口是配件中的一个特殊对象，它允许你和其他配件交流，但是不允许你直接和HomeKit交流。例如一个桥接口可以是控制多个灯的枢纽，它使用的是自己的通信协议，而不是HomeKit配件通信协议。想要给home添加多个桥接口 ，你可以按照Adding Accessories to Homes and Rooms中所描述的步骤，添加任何类型的配件到home中。当你给home添加一个桥接口时，在桥接口底层的配件也会被添加到home中。正如Observing HomeKit Database Changes中所描述的那样，每次更改通知设计模，home的代理不会接收到桥接口的home:didAddAccessory: 代理消息，而是接收一个有关于配件的home:didAddAccessory:代理消息。在home中，要把桥接口后的配件和任何类型的配件看成一样的–例如，把它们加入配件列表的配置表中。相反的是，当你给room增添一个桥接口时，这个桥接口底层的配件并不会自动地添加到room中，原因是桥接口和它的的配件可以位于到不同的room中。\n##创建分区\n分区 (HMZone) 是任意可选的房间（rooms）分组；例如楼上、楼下或者卧室。房间可以被添加到一个或者多个区域。\n\n可使用addZoneWithName:completionHandler: 异步方法创建分区。所创建的作为参数传递到这个方法中分区的名称，在home中必须是唯一的，并且应该能被Siri识别。代码如下：\n__block HMHome *home = self.home;\nNSString *zoneName = @&quot;Upstairs&quot;;\n[home addZoneWithName:zoneName completionHandler:^(HMZone *zone, NSError *error)&#123;\n    if (error) &#123;\n        // Failed to create zone\n    &#125; else &#123;\n        // Successfully created zone, now add the rooms\n    &#125;\n&#125;];\n\n可使用addRoom:completionHandler:异步方法给分区添加一个room，代码如下：\n__block HMRoom *room = roomInHome;\n[zone addRoom:room completionHandler:^(NSError *error) &#123;\n    if (error) &#123;\n        // Failed to add room to zone\n    &#125; else &#123;\n        // Successfully added room to zone\n    &#125; \n&#125;];\n\n#第五部分：观察HomeKit数据库的变化\n每个Home都有一个HomeKit数据库。如下图所示，HomeKit数据库会安全地和home授权的用户的iOS设备以及潜在的客人的iOS设备进行同步。为了给用户展示当前最新的数据，你的应用需要观察HomeKit数据库的变化。\n\n##HomeKit代理方法\nHomKit使用代理设计模式（delegation design pattern）来通知应用程序HomeKit对象的改变。一般来讲，如果你的应用程序调用了一个带有完成处理参数的HomeKit方法，并且这个方法被成功调用了，那么相关联的代理消息就会被发送给其他HomeKit应用，无论这些应用是安装在同一台iOS设备上还是远程iOS设备上。这些应用甚至可以运行在客人的iOS设备上。如果你的应用发起了数据改变，但是代理消息并没有发送到你的应用，那么添加代码到完成处理方法和相关联的代理方法中来刷新数据和更新视图就成为必须了。如果home布局发生了显著变化，那么就重新加载关于这个home的所有信息。在完成程序处理的情况下，请在更新应用之前检查那个方法是否成功。Homkit也会调用代理方法来通知你的应用程序home网络状态的改变。\n例如，下图演示了使用代理方法的过程：响应用户的操作，你的应用程序调用了addRoomWithName:completionHandler:方法，并且没有错误发生，完成处理程序应当更新home的所有视图。如果成功了，homeKit将会发送home:didAddRoom:消息给其他应用中homes的代理。因此，你实现的这个home:didAddRoom:方法也应该更新home的所有视图。\n\n应用程序只有在前台运行的时候才能接受代理消息。当你的应用在后台时，HomeKit数据库的改变并不会成批处理。也就是说，如果你的应用在后台，当其他的应用成功地添加一个room到home中的时候，你的应用程序并不会接收到home:didAddRoom: 消息。当你的应用程序到前台运行时，你的应用程序将会接收到homeManagerDidUpdateHomes:消息，这个消息是表示你的应用程序要重新加载所有的数据。\n##观察Homes集合的改变\n设置home manager的代理并且实现HMHomeManagerDelegate协议，当primary home或者home集合发生改变时，可以接收代理消息。\n所有的应用都需要实现homeManagerDidUpdateHomes:方法，这个方法在完成最初获取homes之后被调用。对新建的home manager来说，在这个方法被调用之前，primaryHome属性的值是nil，homes数组是空的数组。当应用程序开始在前台运行时也会调用 homeManagerDidUpdateHomes: 方法，当其在后台运行时数据发生改变。该homeManagerDidUpdateHomes:方法会重新加载与homes相关联的所有数据。\n观察homes的变化\n1.在你的类接口中添加HMHomeManagerDelegate代理和homeManager属性。代码如下：\n@interface AppDelegate ()&lt;HMHomeManagerDelegate&gt;\n@property (strong, nonatomic) HMHomeManager *homeManager;\n@end\n\n2.创建home manager对象并设置其代理\n- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions&#123;\n    self.homeManager = [[HMHomeManager alloc] init];\n    self.homeManager.delegate = self;\n    return YES;\n&#125;\n\n3.实现homes发生改变时调用的代理方法。例如：如果多个视图控制器展示了homes相关信息，你可以发布一个更改通知去更新所有视图。\n- (void)homeManagerDidUpdateHomes:(HMHomeManager *)manager &#123;\n    // Send a notification to the other objects\n    [[NSNotificationCenter defaultCenter]\n    postNotificationName:@&quot;UpdateHomesNotification&quot; object:self];\n&#125;\n- (void)homeManagerDidUpdatePrimaryHome:(HMHomeManager *)manager &#123;\n    // Send a notification to the other objects\n    [[NSNotificationCenter defaultCenter]\n    postNotificationName:@&quot;UpdatePrimaryHomeNotification&quot; object:self];\n&#125;\n\n视图控制器注册更改通知并且执行适当的操作。\n[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(updateHomes:) name:@&quot;UpdateHomesNotification&quot; object:nil];\n\n[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(updatePrimaryHome:) name:@&quot;UpdatePrimaryHomeNotification&quot; object:nil];\n\n##观察个别home的变化\n展示home信息的视图控制器应该成为home对象的代理，并且当home发生改变时更新视图控制器的视图。\n观察特定home对象的改变\n1.在类接口中添加home代理协议。\n@interface HomeViewController ()&lt;HMHomeDelegate&gt;\n\n@end\n\n2.设置配件代理\nhome.delegate = self;\n\n3.实现HMHomeDelegate协议\n例如：实现home:didAddAccessory:和home:didRemoveAccessory: 方法来更新展示配件的视图。用HMAccessory类的room属性可以获得配件所属的room。（对配件来说，默认的room是roomForEntireHome这个方法的返回值。）\n\n\n\n\n\n\n\n\n\nBridge Note:当你为home添加桥接口时，桥接口底层的配件会自动被添加到home中。你的代理会接收到桥接口后每个配件的 home:didAddAccessory:消息，但是你的代理不会接收到桥接口的home:didAddAccessory:消息。\n##观察配件的变化\n配件的状态可以在任何时间发生变化。配件可能不能被获得，可以被移除，或者被关闭。请更新用户界面以反映配件状态的更改，尤其是如果你的app允许用户控制配件时。\n这以下步骤中，我们假设你已经从HomeKit数据库中检索到了配件对象，正如Getting the Accessories in a Room中描述的那样。\n观察个别配件的变化\n1.在类接口中添加配件代理协议。\n@interface AccessoryViewController ()&lt;HMAccessoryDelegate&gt;  \n\n@end\n\n2.设置配件的代理\naccessory.delegate = self;\n\n3.实现 HMAccessoryDelegate 协议\n比如，执行accessoryDidUpdateReachability:方法以启用或者禁用配件控制。\n- (void)accessoryDidUpdateReachability:(HMAccessory *)accessory &#123;\n    if (accessory.reachable == YES) &#123;\n           // Can communicate with the accessory\n    &#125; else &#123;\n           // The accessory is out of range, turned off, etc\n    &#125;\n&#125;\n\n如果你展示了配件的服务状态和特性，那么请执行以下代理方法来相应地更新其视图：\naccessoryDidUpdateServices:\naccessory:service:didUpdateValueForCharacteristic:\n想了解配件的服务，请参阅Accessing Services and Their Characteristics.\n#第六部分：访问服务和特性\n服务(HMService)代表了一个配件(accessory)的某个功能和一些具有可读写的特性(HMCharacteristic)。一个配件可以拥有多项服务,一个服务也可以有很多特性。比如一个车库开门器可能拥有一个照明和开关的服务。照明服务可能拥有打开/关闭和调节亮度的特性。用户不能制造智能家电配件和它们的服务-配件制造商会制造配件和它们的服务-但是用户可以改变服务的特性。一些拥有可读写属性的特性代表着某种物理状态，比如，一个恒温器中的当前温度就是一个只可读的值，但是目标温度又是可读写的。苹果预先定义了一些服务和特性的名称，以便让Siri能够识别它们。\n##获得配件的服务和属性\n在依照Getting the Accessroties in a Room中描述，你创建了一个配件对象之后,你可以获得配件的服务和特性。当然你也可以直接从home中按照类型获得不同的服务。\n\n\n\n\n\n\n\n\n\n重要:不要暴露匿名服务-比如固件升级服务-给用户\n通过HMAccessory类对象的services属性，我们可以获得一个配件的服务。\nNSArray *services = accessroy.services;\n\n要获得一个home当中配件提供的特定服务，使用HMHome类对象的servicesWithTypes:方法。\n//Get all lights and thermostats in a home\nNSArray *lightServices = [home servicesWithTypes:[HMServicesTypeLightbulb]];\nNSArray *thermostatServices = [home servicesWithTypes:[HMServicesTypeThermostat]];\n\n使用HMServices类对象的name属性来获得服务的名称\nNSString *name = services.name;\n\n要获得一个服务的特性，请使用characteristics属性。\nNSArray *characteristics = service.characteristics\n\n使用servicesType属性来获得服务的类型\nNSString *serviceType = service.serviceType;\n\n苹果定义了一些服务类型，并能被Siri识别:\n\n\n\n\n\n\n\n\n\n1.门锁(Door locks) 2.车库开门器(Garage door openers) 3.灯光(Lights) 4.插座(Outlets) 5.恒温器(Thermostats)\n##改变服务名称\n使用updateName:completionHandler:异步方法来改变服务名称。传入此方法的服务名称参数必须在一个home当中是唯一的，并且服务名可被Siri识别。\n[service updateName:@&quot;Garage 1 Opener&quot; completionHandler:^(NSError *error) &#123;\n    if (error) &#123;\n        // Failed to change the name\n    &#125; else &#123;\n        // Successfully changed the name\n    &#125;\n&#125;];\n\n##访问特性的值\n特性代表了一个服务的一个参数，它要么是只读、可读写或者只写。它提供了这个参数可能的值的信息，比如，一个布尔或者一个范围值。恒温器中的温度就是只读的，而目标温度又是可读写的。一个执行某个任务的命令且不要求任何返回-比如播放一段声音或者闪烁一下灯光来确认某个配件-可能就是只写的。\n苹果定义了一些特性的类型，并能被Siri识别:\n\n\n\n\n\n\n\n\n\n1.亮度(Brightness) 2.最近温度(Current temperature) 3.锁的状态(Lock state) 4.电源的状态(Power state) 5.目标状态(Target state) 6.目标温度(Target temperature)\n比如，对于一个车库开门器来说，目标状态就是打开或者关闭。对于一个锁来说，目标状态又是上锁和未上锁。\n在你获得了一个HMService对象之后,如 Getting Services and Their Properties所描述的,你可以获得每个服务的特性的值。因为这些值是从配件中获得的，这些读写的方法都是异步的，并可以传入一个完成回调的block。\n使用readValueWithCompletionHandler:异步方法来读取一个特性的值。\n[characteristic readValueWithCompletionHandler:^(NSError *error) &#123;\n    if (error == nil) &#123;\n           // Successfully read the value\n           id value = characteristic.value;\n    &#125;\n    else &#123;\n           // Unable to read the value\n    &#125;\n&#125;];\n\n在if语句块中，加入你的代码以更新app的视图。\n使用writeValue:completionHandler:异步方法来向一个特性写入值。\n[self.characteristic writeValue:@42 withCompletionHandler:^(NSError *error) &#123;\n    if (error == nil) &#123;\n           // Successfully wrote the value\n    &#125;else &#123;\n           // Unable to write the value\n    &#125;\n&#125;];\n\n不要以为函数调用完成就意味着写入成功，实际上只有在当完成回调执行并没有错误产生时才表示写入成功。比如，直到一个开关的特性改变之前都不要改变这个开关的状态。在if语句块中，加入你的代码，以更新app的视图。\n另外，在别的app更新了特性的值时也需要更新视图，在Observing Changes to Accessories中有描述。\n##创建服务组\n一个服务组(HMServiceGroup)提供了控制不同配件的任意数量服务的快捷方式-比如，当用户离开家之后控制家中的某些灯。\n\n在你创建了一个HMHome对象之后,如Getting the Primary Home and Collection of Homes中描述,你也就在这个家中创建一个服务组。\n为了创建一个服务组,我们使用HMHome类对象的addServiceGroupWithName:completionHandler:方法。方法中参数服务组的名称必须在此家中唯一，并可以被Siri识别。\n[self.home addServiceGroupWithName:@&quot;Away Lights&quot; completionHandler:^(HMServiceGroup *serviceGroup, NSError *error) &#123;\n    if (error == nil) &#123;\n           // Successfully created the service group\n    &#125; else &#123;\n           // Unable to create the service group\n       &#125;\n&#125;];\n\n我们使用HMServiceGroup类对象的addService:completionHandler:方法来向服务组中添加一个服务。服务可以在一个或多个服务组中。\n[serviceGroup addService:service completionHandler:^(NSError *error) &#123;\n    if (error == nil) &#123;\n           // Successfully added service to service group\n    &#125;\n       // Unable to add the service to the service group\n&#125;];\n\n通过HMHome类对象的serviceGroups属性，来获得这个家的所有服务组。\nNSArray *serviceGroups = self.home.serviceGroups;通过HMServiceGroup类对象的accessory属性，我们获得服务所对应的智能电器。\nHMAccessory *accessory = service.accessory;\n\n和配件类似，代理方法在别的app改变服务组时也会被调用。如果你的app使用了服务组，请阅读HMHomeDelegate Protocol Reference文档，获悉你应该实现哪些方法以观察这些变化。\n#第七部分：测试HomeKitApp\n如果你没有智能电器(智能配件），你可以使用HomeKit Accessroy Simulator来模拟home中的智能电器。每个模拟配件都拥有服务和特性，你可以从你的App当中控制它。你的App在HomeKit数据库中创建对象和关系。它可以创建home布局，可以添加新的配件到模拟的home环境当中，最后向home中的每个房间添加智能配件。然后，你的app就能控制这些在HomeKit Accessory Simulator展示的模拟智能配件了。为了使用HomeKit Accessory Simulator，请在iOS模拟器中运行你的应用程序，或者使用Xcode在iOS设备上运行应用程序。\nHomeKit Accessory Simulator是一个附加的开发者工具，不过并没有安装在Xcode当中。请按照Download HomeKit Accessory Simulator中所述的安装HomeKit Accessory Simulator。\n##添加智能电器（配件）\n使用HomeKit Accessory Simulator来添加智能电器到模拟网络中。\n向网络中添加智能电器配件，请按照下面的步骤添加：\n\n\n\n\n\n\n\n\n\n1.在HomeKit Accessory Simulator中，点击底部左边‘+’按钮。 2.从弹出菜单中选择添加智能电器(Add Accessory) 3.输入智能电器的名字和制造商。\n\n4.点击完成\n如果想删除一个智能电器，请选择一个智能电器然后点击键盘上的Delete键。\n##向智能电器（配件）中添加服务\n一个智能电器需要一项服务和特性，你可以从app控制它。从预定义了服务列表中选择一项服务，并自定义特性。\n按照下面步骤向智能电器中添加服务\n1.在HomeKit Accessory Simulator中，选择Accessories列中的某个配件。该配件的服务信息会展示在一个详情界面中。\n\n\n\n\n\n\n\n\n\n\n注意:所有智能电器都有一个Accessory Information，显示在所有其他服务的下方。你可以向这个Accessory Information服务添加特性，但你不能删除默认的特性。\n2.点击添加服务(Add Service)，并从弹出视图中选择一个服务类型。\n新添加的服务会在右边详细显示。HomeKit Accessory Simulator为每种服务创建通用的特性。比如一个灯光服务的默认特性为色彩(Hue)，饱和度(Saturation)，亮度(Brightness)和开关。(开关特性和电源状态特性是一样的,正如 Accessing Values of Characteristics中描述的那样。）一些特性是强制性的有一些也是可选择的。比如，开关特性就是强制性的，而色彩，饱和度，亮度这些特性都是可选择的。\n\n##向服务中添加特性\n你可以向服务中添加预定义的特性，或者自定义的特性。每种特性你都只能添加一个。\n按照下面的步骤向服务中添加特性：\n1.在HomeKit Accessory Simulator中，服务详情视图，点击添加特性(Add Characteristic)\n2.在特性类型菜单中，选择一个类型或者自定义类型。\n\n3.在其他文本框中输入此特性的其他信息，并点击完成(Finish).\n新添加的特性会在详细视图展示出来。\n点击特性右边的减号来删除一个特性。如果特性右边并没有减号显示，这说明这个特性对这个服务来说是必须的。比如，你可以删除电灯服务中的色彩(Hue)，饱和度(Saturation)和亮度(Brightness)，但是你不可以删除开关特性。\n##通过你的App向家庭中添加智能电器（配件）\n在你通过HomeKit Accessory Simulator创建了一个智能电器后，运行你的App然后添加一个新的智能电器到你的家庭。\n如何配对家庭中的智能电器：\n\n 在Xcode中，点击Run并调用addAccessory:completionHandler:方法(如Adding Accessories to Homes and Rooms中描述的那样).\n\n 如果弹出了一个Add HomeKit Accessory对话框声明这个智能电器未被信任(这在HomeKit Accessory Simulator中是被允许的)，不用管它，点击Add Anyway。\n\n\n\n\n 在接下来显示的Add HomeKit Accessory对话框中，输入智能电器的setup code然后点击Add。\n\n在HomeKit Accessory Simulator，setup code显示在详情界面智能电器名称下。\n\n关于如何编写代码来添加一个智能电器到家庭和房间请阅读Creating Homes and Adding Accessoris。\n##控制智能电器（配件）\n在HomeKit Accessory Simulator中，你可以获得智能电器的服务，并在其他HomeKit App中设置服务的特性值来模拟控制这个智能电器，或者手动地模拟控制智能电器。\n想要控制一个智能电器你需要:\n1.在HomeKit Accessory Simulator中的智能电器列表（Accessories column）中选择一个智能电器。这个智能电器的服务和特性会被展示在详情界面。\n2.操作一个特性的控件来改变它的值。\n比如，为了改变一个灯泡的颜色（Hue），饱和度（Saturation）和亮度（Brightness），请滑动这个滑块。为了打开这个灯泡请选择On选项。\n\n如果你的app展示了一个服务的特性，比如灯泡的开关状态，当你在HomeKit Accessory Simulator中改变这些特性的值时，它应当更新视图。\n为了观察HomeKit数据库的变化，请阅读Observing HomeKit Database Changes。如果你想从app中通过编写代码来控制一个智能电器，请阅读Accessing Services and Characteristics。\n##添加桥接口\n为了模拟那些不支持HomeKit Accessory Protocol协议的智能电器，需要添加一个虚拟桥接口，然后将智能电器添加到这个虚拟桥接口。配置虚拟桥接口底层的智能电器和配置其他类型的智能电器差不多。\n添加一个虚拟桥接口到网络\n添加一个代表这个虚拟桥接口的智能电器。\n为了添加一个虚拟桥接口到网络你需要:\n1.在HomeKit Accessory Simulator中，点击智能电器列表底部的“+”按钮。\n2.在弹出框中选择Add 虚拟桥接口。\n3.输入一个智能电器的名称和制造商。\n4.点击完成\n##向虚拟桥接口添加智能电器配件\n可向一个虚拟桥接口添加一个或多个智能电器。\n为了向一个虚拟桥接口添加一个智能电器，需要:\n1.在HomeKit Accessory Simulator左边的列表中，选择虚拟桥接口中的一个虚拟桥接口。\n2.在详情页面选择Add Accessory。\n3.输入一个智能电器名字和制造商。\n4.点击完成。\n想要了解虚拟桥接口中的智能电器的详细信息，请选择虚拟桥接口部分中的智能电器。如果需要的话你可以点击虚拟桥接口旁边的查看详情来查看这个虚拟桥接口的智能电器。在你添加了一个服务和特性到这些智能电器之后，如Adding Services to Accessories和Adding Characteristics to Services中描述。它们会在这个虚拟桥接口被选择之后被展示出来。\n\n##在你的App中添加虚拟桥接口到home\n将虚拟桥接口和home匹配的过程和将一个智能电器配置到一个home的过程是一样的，如Adding Accessories to a Home in Your App描述的。在虚拟桥接口底层的智能电器配件也一样被加入到了home，如 Adding Bridges to Homes and Rooms所描述。\n##控制虚拟桥接口底层的智能电器\n如何控制虚拟桥接口底层的智能电器和直接控制智能电器的步骤一致，如Controlling Accessories in HomeKit Accessory Simulator中描述，除了你直接选择虚拟桥接口下的智能电器之外。\n##在多设备和多用户环境中测试\n在iOS模拟器中你不能测试分享HomeKit数据库到多个iOS设备和用户。你应该安装你的App到多台iOS设备上，在这些设备中输入iCloud证书，然后运行你的App。或者，使用ad hoc授权来在多台注册设备中测试你的app，如Distributing Your App Using Ad Hoc Provisioning in App Distribution Guide描述。\n\n\n\n\n\n\n\n\n\n1.为了测试单用户多设备环境，你应该使用同一个iCloud账户在多台设备登陆。 2.为了测试多用户使用同一家庭的智能电器，你应该在多台设备使用不同的iCloud账户登陆。\n你的App应该应该可以允许一个用户邀请客人到你的家中，如Managing Users所述。\n#第八部分：创建动作集（Action Sets）和触发器（Triggers）\n一个动作集合HMActionSet和触发器HMTimerTrigger允许你同时控制多个智能电器。比如，一个动作集合可能会在用户上床休息之前执行一组动作HMAction。一个写动作向一个特性写入了值。动作集合中的动作是以不确定的顺序执行的。一个触发器会在一个特定的时间出发一个动作集并可以重复执行。每一个动作集合在一个家庭中都有唯一的名称并可被Siri识别。\n\n##创建写入动作\n写入动作会向一个服务的特性写入值并被加入到动作集合中去。HMAction类是HMCharacteristicWriteAction具体类的抽象基类。一个动作有一个相关联的特性对象，你可以通过Accessing Services and Characteristics中描述的来获取相关的服务和特性，然后创建这个HMCharacteristicWriteAction。\n为了创建一个动作，我们使用HMCharacteristicWriteAction类中的initWithCharacteristic:targetValue:方法。\nHMCharacteristicWriteAction *action = [[HMCharacteristicWriteAction alloc] initWithCharacteristic:characteristic targetValue:value];\n\n在你的代码中，你使用对应的特性的期望来替换value参数，并使用对应的HMCharacteristic对象来替换characteristic参数。\n##创建并执行动作集\n一个动作集就是一个共同执行的动作的集合。比如一个夜间动作集合可能包含关闭电灯，调低恒温水平和锁上房门。\n为了创建一个动作集我们使用addActionSetWithName:completionHandler:异步方法。\n[self.home addActionSetWithName:@&quot;NightTime&quot; completionHandler:^(HMActionSet *actionSet, NSError *error) &#123;\n    if (error == nil) &#123;\n        // 成功添加了一个动作集\n    &#125; else &#123;\n        // 添加一个动作集失败\n    &#125;\n&#125;];\n\n为了添加一个动作到动作集，我们使用addAction:completionHandler:异步方法。\n[actionSet addAction:action completionHandler:^(NSError *error) &#123;\n    if (error == nil) &#123;\n        // 成功添加了一个动作到动作集\n    &#125; else &#123;\n        // 添加一个动作到动作集失败\n    &#125;\n&#125;];\n\n想要移除一个动作，可使用removeAction:completionHandler:方法。\n想要执行一个动作集，可使用HMHome类的executeActionSet:completionHandler:方法。比如，用户希望控制所有的节日彩灯。我们就创建一个动作集来打开所有的节日彩灯，另外一个动作集来关闭所有的节日彩灯。为了打开所有的节日彩灯，发送executeActionSet:completionHandler:消息给home对象，并传递”打开节日彩灯”动作集。\n##创建并开启触发器\n触发器会执行一个或多个动作集。iOS会在后台管理和运行你的触发器。HMTrigger类是HMTimerTrigger具体类的抽象类。当你创建一个定时触发器时，你需要指定触发时间和触发的周期。创建并开启一个定时触发器需要多个步骤来完成。\n遵循下面几步来创建并启动一个定时触发器\n创建一个定时触发器\n1.创建定时触发器。\nself.trigger = [[HMTimerTrigger alloc] \ninitWithName:name \nfireDate:fireDate \ntimeZone:niL \nrecurrence:nil \nrecurrenceCalendar:nil];\n\n触发时间必须设置在将来的某个时刻，第二个参数必须为0.如果你设置了一个周期，周期的最小值是5分钟，最大值是5周。关于如何使用NSDateComponents和NSCalendar来设置周期，请阅读Date and Time Programming Guide\n2.添加一个动作集到触发器。\n使用HMTrigger基类方法addActionSet:completionHandler:，来添加一个动作集到触发器。\n3.添加一个触发器到家庭。\n使用HMHome类中的addTrigger:completionHandler:方法来添加一个触发器到家庭。\n4.启动触发器。\n新创建的触发器默认是未启动的。需要使用enable:complationHandler:方法启动触发器。\n一个定时触发器被启动后，会周期性的运行它的动作集。\n#第十部分：用户管理\n创建home的用户是该home的管理员，可以执行所有操作，包括添加一个客人用户到home。任何管理员添加到这个home的用户(HMUser)都有一个有限的权限。客人不能更改家庭的布局，但是可以执行下面的动作：\n识别智能电器读写特性观察特性值变化执行动作集比如，一个家庭的户主可以创建一个home布局并向其中添加家庭成员。每个家庭成员必须拥有一个iOS设备和Apple ID以及相关的iCloud账户。iCloud需要个人输入的Apple ID和户主提供的Apple ID相吻合，以便让他们访问这个home。考虑到隐私问题，Apple ID对你的App是不可见的。\n管理员需要遵从以下步骤来添加一个客人到home中：\n\n\n\n\n\n\n\n\n\n1.管理员调用一个动作将客人添加到home中。2.你的App调用addUserWithCompletionHandler:异步方法。3.HomeKit展示一个对话框，要求输入客人的Apple ID。4.用户输入客人的Apple ID。5.在完成回调中返回一个新的用户。6.你的App展示客人的名字。\n添加一个客人到home，需要在客人的iOS设备上做以下操作：\n\n\n\n\n\n\n\n\n\n1.用户在iCloud偏好设置中输入iCloud凭证(Apple ID和密码)。2.用户启动你的App。3.你的App通过home manager object获得一个home集合。4.如果iCloud的凭证和管理员输入的Apple ID相同，那么管理员的home将会出现在homes属性中。\n客人执行的操作可能会失败。如果一个异步方法中出现HMErrorCodeInsufficientPrivileges错误码的话，这就意味着用户没有足够的权限来执行动作-也许这个用户只是客人，而不是管理员。\n为了测试你的App是否正确处理了客人用户，请阅读Testting Multiple iOS Devices and Users。\n##添加和移除用户\n为了添加一个客人用户到home，请使用addUserWithCompletionHandler:异步方法。\n[self.home addUserWithCompletionHandler:^(HMUser *user, NSError *error) &#123;\n    if (error == nil) &#123;\n        // Successfully added a user\n    &#125;\n    else &#123;\n           // Unable to add a user\n    &#125;\n&#125;];\n\n想要移除home中的用户，请使用HMHome类的removeUser:completionHandler:方法。\n通过实现HMHomeDelegate协议中的home:didAddUser:和home:didRemoveUser:协议方法检查新添加和移除的用户并更新视图。关于如何创建一个delegate，请阅读Observing Changes to Individual Homes。\n##获得用户名\n出于隐私的考虑，你的app对用户名只有读得权限，并不能读写用户的Apple ID。使用HMHome对象的users属性来获取用户。使用HMUser类的name属性来获取用户名\n","slug":"HomeKit-开发指南","date":"2016-08-10T05:08:12.000Z","categories_index":"智能家居","tags_index":"HomeKit","author_index":"William Xie"},{"id":"a234db355cc14ca7a21f932753cfdf5a","title":"CFNetwork 编程指南之七: 使用网络诊断(Using Network Diagnostics)","content":"#使用网络诊断\n在许多基于网络的应用中，会发生基于网络的错误，这些错误与你的应用无关。然而，大多数用户可能不知道为什么应用失败。CFNetDiagnostics API为你提供一种快速而简单的方法来帮助用户解决网络问题。\n如果你的应用使用一个CFStream 对象，然后调用CFNetDiagnosticCreateWithStreams函数创建一个网络诊断引用(CFNetDiagnosticRef) 。CFNetDiagnosticCreateWithStreams有一个分配器，读取流和写入流作为参数。如果你的应用只使用读取流或写入流，未使用的参数设置为NULL。\n如果不存在流，你还可以直接从URL创建一个网络诊断引用。要做到这一点，调用CFNetDiagnosticCreateWithURL 函数，并传递一个分配器，URL到CFURLRef。它将返回一个网络诊断引用供你使用。\n为了通过网络诊断助手诊断问题，调用CFNetDiagnosticDiagnoseProblemInteractively 函数并传递网络诊断引用。列表6-1展示了如何使用CFNetDiagnostics 诊断在运行循环上实现的流。\n列表6-1 当发生流错误时使用CFNetDiagnostics API\ncase kCFStreamEventErrorOccurred: \n\n    CFNetDiagnosticRef diagRef =\n        CFNetDiagnosticCreateWithStreams(NULL, stream, NULL); \n\n    (void)CFNetDiagnosticDiagnoseProblemInteractively(diagRef);\n    CFStreamError error = CFReadStreamGetError(stream);\n    reportError(error);\n    CFReadStreamClose(stream);\n    CFRelease(stream);\n    break;\n\nCFNetworkDiagnostics 同样可以检索问题的状态，而不是使用网络诊断助手。通过调用CFNetDiagnosticCopyNetworkStatusPassively，便可以完成。该函数返回一个常数例如kCFNetDiagnosticConnectionUp 或kCFNetDiagnosticConnectionIndeterminate。\n官方原文地址：CFNetwork Programming Guide\n","slug":"CFNetwork-编程指南之七-使用网络诊断-Using-Network-Diagnostics","date":"2016-08-10T03:59:13.000Z","categories_index":"iOS网络编程","tags_index":"CFNetwork","author_index":"William Xie"},{"id":"4fe0927b9d7f454761510969d0dea921","title":"CFNetwork 编程指南之六: 使用FTP服务器(Working with FTP Servers)","content":"#使用FTP服务器\n本文揭示了如何使用CFFTP API的一些基本特性。管理FTP事务是异步执行的，而管理文件传输是同步实现的。\n##下载文件使用CFFTP类似于CFHTTP ，因为它们都是基于CFStream。与其他任何异步使用CFStream的API一样，使用CFFTP下载一个文件要求你为文件创建一个读取流和一个回调函数。当读取流接收数据时，回调函数将运行，你需要适当的下载字节。这个过程通常执行两个函数：一个用来设置流，另一个充当回调函数。\n###设置FTP流首先使用CFReadStreamCreateWithFTPURL 函数创建一个读取流并传入要下载远程服务器上文件的URL字符串。URL字符串的例子ftp://ftp.example.com/file.txt。注意：字符串包含服务器名称、路径和文件。接下来，在文件下载的位置创建一个本地写入流。这个过程使用CFWriteStreamCreateWithFile 函数完成，传入要下载文件的路径。\n\n\n由于读写流必须保持同步，创建一个包含所有共同信息，例如代理字典、文件大小、写入字节数、剩余字节数和缓存区的结构。结构如列表5-1所示\n列表5-1 流结构\ntypedef struct MyStreamInfo &#123;\n\nCFWriteStreamRef  writeStream;\nCFReadStreamRef  readStream;\nCFDictionaryRef  proxyDict;\nSInt64            fileSize;\nUInt32            totalBytesWritten;\nUInt32            leftOverByteCount;\nUInt8            buffer[kMyBufferSize];\n&#125; MyStreamInfo;\n\n为你刚刚创建的读写流初始化结构。可以定义流客户端内容(CFStreamClientContext)的info字段执行结构。这在以后非常有用。\n用CFWriteStreamOpen 函数打开你的写入流，这样你可以开始写入本地文件。确保流正常打开，调用CFWriteStreamGetStatus 函数检查返回kCFStreamStatusOpen 或kCFStreamStatusOpening。\n写入流打开后，将回调函数与读取流结合。调用CFReadStreamSetClient 函数并传递读取流，你的回调函数要接收的网络事件，回调函数名称和CFStreamClientContext 对象。在之前设置客户端环境流中的info 字段，在运行时结构将发送到回调函数。\n一些FTP服务可能需要用户名，其他可能还需要密码。如果访问的服务器需要用户名进行验证，调用CFReadStreamSetProperty 函数并传递读取流，kCFStreamPropertyFTPUserName 属性和包含用户名的CFString 对象的引用。此外，如果需要设置密码，设置kCFStreamPropertyFTPPassword 属性。\n一些网络配置也可以使用FTP代理。获取代理信息的方式取决于你的代码是运行在OS X 还是iOS上。\n\n在OS X 中，可以调用SCDynamicStoreCopyProxies 函数在字典中检索代理设置并传递NULL。\n\n在iOS中，可以调用CFNetworkCopyProxiesForURL来检索代理设置。\n\n\n这些函数返回一个动态存储引用。可以使用这个值来设置读取流的kCFStreamPropertyFTPProxy 属性。设置代理服务器，指定端口并返回一个布尔值，该值表明FTP流是否执行被动模式。\n除了提到的属性，还有一些其他的属性用于FTP流。完整的列表如下。\n\nkCFStreamPropertyFTPUserName ——使用用户名登陆（可设置并可检索；匿名FTP连接不要设置）\n\nkCFStreamPropertyFTPPassword ——使用密码登陆（可设置并可检索；匿名FTP连接不要设置）\n\nkCFStreamPropertyFTPUsePassiveMode ——是否采用被动模式（可设置并可检索）\n\nkCFStreamPropertyFTPResourceSize ——下载项目的预期大小，如果可用（可检索；只有FTP读取流可用）\n\nkCFStreamPropertyFTPFetchResourceInfo ——是否要求资源信息，例如大小，开始下载前是否需要该信息（可设置并可检索）；设置这个属性可能会影响性能\n\nkCFStreamPropertyFTPFileTransferOffset ——开始转移的文件偏移量（可设置并可检索）\n\nkCFStreamPropertyFTPAttemptPersistentConnection ——是否尝试重用连接（可设置并可检索）\n\nkCFStreamPropertyFTPProxy ——包含代理字典的键值对（可设置并可检索）的CFDictionary 类型\n\nkCFStreamPropertyFTPProxyHost ——FTP代理主机名称（可设置并可检索）\n\nkCFStreamPropertyFTPProxyPort ——FTP代理主机端口号（可设置并可检索）\n\n\n读取流分配正确的属性后，使用CFReadStreamOpen 函数打开流。假设并不返回一个错误，所有的流都正确设置。\n###实现回调函数回调函数将接收三个参数：读取流，事件类型和MyStreamInfo 结构。事件的类型决定了采取什么行动。\n最常见的事件是kCFStreamEventHasBytesAvailable，当读取流从服务器接收到字节时，将发送该事件。首先，调用CFReadStreamRead 函数检查读取了多少字节。确保返回值不小于0（错误）或者等于0（已经下载完）。如果返回值为正，然后你可以开始将读取流中的数据写入到磁盘中。\n调用CFWriteStreamWrite 函数写入数据到写入流。有时候在没有写入所有读取流中的数据是，CFWriteStreamWrite 可以返回。出于这个原因，只要还在写入数据，设置一个运行循环。代码见列表5-2，其中的info 是设置流（Setting up the Streams）中的MyStreamInfo 结构。写入到写入流的方法使用阻塞流。通过写入流事件驱动可以实现更好的性能，但代码比较复杂。\n列表5-2 将数据从读取流中写入到写入流\nbytesRead = CFReadStreamRead(info->readStream,   \ninfo->buffer, kMyBufferSize);\n//...make sure bytesRead > 0 ...\nbytesWritten = 0; \nwhile (bytesWritten &lt; bytesRead) &#123; \n\nCFIndex result;\n\nresult = CFWriteStreamWrite(info->writeStream,\ninfo->buffer + bytesWritten, bytesRead - bytesWritten); \nif (result &lt;= 0) &#123;\n    fprintf(stderr, \"CFWriteStreamWrite returned %ld\\n\", result);\n    goto exit;\n&#125;\nbytesWritten += result;\n&#125;info->totalBytesWritten += bytesWritten;\n\n\n只要在读取流中有可用的直接，重复整个过程。\n要当心其他两个事件kCFStreamEventErrorOccurred 和kCFStreamEventEndEncountered。如果出现错误，使用CFReadStreamGetError 检索错误然后退出。如果在文件末尾发生错误，下载已经完成可以退出。\n确保一切完成并且没有其他过程使用流后删除所有流。首先，关闭写入流并设置客户端为NULL。然后从运行循环上取消流并释放。当完成后，从运行循环上删除流。\n##上传文件上传文件类似下载文件。正如下载文件一样，你需要一个读取流和一个写入流。然而，当上传文件，读取流为本地文件而写入流为远程文件。按照设置流（Setting up the Streams）中的说明，但无论在任何地方引用读取流，将代码应用到写入流，反之亦然。\n在回调函数中查找kCFStreamEventCanAcceptBytes事件，而不是查找kCFStreamEventHasBytesAvailable 事件。首先，使用读取流并将数据放到MyStreamInfo中缓冲区，从文件中读取字节。然后，运行CFWriteStreamWrite 函数将字节从缓冲区写入到写入流。CFWriteStreamWrite 返回写入流的字节数。如果写入的字节数少于从文件读取的数目，计算出剩余的字节并将它们存储到缓冲区。在接下来的写入周期，如果有剩余的直接，将它们写入到写入流而不是从读取流中加载新数据。只要写入流可以接受字节（CFWriteStreamCanAcceptBytes），重复整个过程。循环代码见列表5-3.\n列表5-3 写入数据到写入流\ndo &#123; \n\n// Check for leftover data\nif (info->leftOverByteCount > 0) &#123;\n    bytesRead = info->leftOverByteCount;\n&#125; else &#123;\n    // Make sure there is no error reading from the file\n    bytesRead = CFReadStreamRead(info->readStream, info->buffer,\n                                kMyBufferSize);\n    if (bytesRead &lt; 0) &#123;\n        fprintf(stderr, \"CFReadStreamRead returned %ld\\n\", bytesRead);\n        goto exit;\n    &#125;\n    totalBytesRead += bytesRead;\n&#125;\n\n// Write the data to the write stream\nbytesWritten = CFWriteStreamWrite(info->writeStream,\ninfo->buffer, bytesRead); \nif (bytesWritten > 0) &#123;\n\n    info->totalBytesWritten += bytesWritten;\n\n    // Store leftover data until kCFStreamEventCanAcceptBytes event occurs again\n    if (bytesWritten &lt; bytesRead) &#123;\n        info->leftOverByteCount = bytesRead - bytesWritten;\n        memmove(info->buffer, info->buffer + bytesWritten,\n                info->leftOverByteCount);\n    &#125; else &#123;\n        info->leftOverByteCount = 0;\n    &#125;\n&#125; else &#123;\n    if (bytesWritten &lt; 0)\n        fprintf(stderr, \"CFWriteStreamWrite returned %ld\\n\",\nbytesWritten); \n    break;\n&#125;\n&#125; while (CFWriteStreamCanAcceptBytes(info->writeStream));\n\n\n就像下载文件时，会有kCFStreamEventErrorOccurred 和kCFStreamEventEndEncountered 事件。\n##创建远程目录在远程服务器上创建目录，设置一个写入流正如你要上传文件。然而，提供一个目录路径而非文件，CFURL 对象传递到CFWriteStreamCreateWithFTPURL 函数。用斜杠’/’结束路径。例如，一个适当的目录路径为ftp://ftp.example.com/newDirectory/，而非 ftp://ftp.example.com/newDirectory/newFile.txt。当运行循环执行回调函数，将发送kCFStreamEventEndEncountered事件，这表明已经创建了目录（或者kCFStreamEventErrorOccurred，表明发生错误）\n每次调用CFWriteStreamCreateWithFTPURL只可以创建一个目录级别。只有你有正确的服务器权限，才能创建目录。\n##下载目录列表通过FTP下载目录列表与下载或上传文件略有不同。这是由于传入的数据必须被解析。首先，建立一个读取流来获取目录列表。对于下载文件这个必须完成：创建流，注册回调函数，运行循环上安排流（如果有必要，设置用户名、密码和代理信息），最后打开流。在接下来的例子中，当检索目录列表时，你不需要读取和写入流，因为传入的数据将要显示到屏幕上而非文件中。\n在回调函数中，当心kCFStreamEventHasBytesAvailable 事件。从读取流中加载数据前，确保上次回调函数运行后的流中没有剩余数据。从MyStreamInfo 结构的leftOverByteCount字段加载偏移。然后，从流中读取数据，考虑你计算的偏移。缓冲区大小和读取的字节数也需要计算。如列表5-4所示。\n列表5-4 加载目录列表数据\n// If previous call had unloaded data\nint offset = info->leftOverByteCount;\n// Load data from the read stream, accounting for the offset\nbytesRead = CFReadStreamRead(info->readStream, info->buffer + offset,\nkMyBufferSize - offset);\nif (bytesRead &lt; 0) &#123;\n\nfprintf(stderr, \"CFReadStreamRead returned %ld\\n\", bytesRead);\nbreak;\n&#125; else if (bytesRead == 0) &#123;\nbreak;\n\n&#125;\n\nbufSize = bytesRead + offset;\ntotalBytesRead += bufSize;\n\n数据被读取到缓冲区后，设置一个循环来解析数据。解析的数据不一定是整个目录列表；它可以（可能）是大块的列表。使用CFFTPCreateParsedResourceListing函数创建解析数据的循环，需传入缓冲区数据，缓冲区大小和字典引用。它返回解析的字节数。只要这个值大于0，继续循环。CFFTPCreateParsedResourceListing 字典创建包含所有目录列表信息；关于更多可用键参阅设置流（ Setting up the Streams）。\nCFFTPCreateParsedResourceListing 有可能返回一个正数，而不是创建一个解析字典。例如，如果在列表的末尾包含的信息不能被解析，CFFTPCreateParsedResourceListing 将返回一个正数告诉调用者数据已经消耗。然而，CFFTPCreateParsedResourceListing 不创建一个解析字典，因为它无法理解数据。\n如果创建一个解析字典，重新计算读取的字节数和缓存区大小，如列表5-5所示。\n列表5-5 加载目录列表并解析\ndo&#123; \n\nbufRemaining = info->buffer + totalBytesConsumed;\n\nbytesConsumed = CFFTPCreateParsedResourceListing(NULL, bufRemaining,\n                                                bufSize, &amp;parsedDict);\nif (bytesConsumed > 0) &#123;\n\n    // Make sure CFFTPCreateParsedResourceListing was able to properly\n    // parse the incoming data\n    if (parsedDict != NULL) &#123;\n        // ...Print out data from parsedDict...\n        CFRelease(parsedDict);\n    &#125;\n\n    totalBytesConsumed += bytesConsumed;\n    bufSize -= bytesConsumed;\n    info->leftOverByteCount = bufSize;\n\n&#125; else if (bytesConsumed == 0) &#123;\n\n    // This is just in case. It should never happen due to the large buffer size\n    info->leftOverByteCount = bufSize;\n    totalBytesRead -= info->leftOverByteCount;\n    memmove(info->buffer, bufRemaining, info->leftOverByteCount);\n\n&#125; else if (bytesConsumed == -1) &#123;\n    fprintf(stderr, \"CFFTPCreateParsedResourceListing parse failure\\n\");\n    // ...Break loop and cleanup...\n&#125;\n&#125; while (bytesConsumed > 0);\n\n\n当流没有更多的可用字节，清理所有流并从运行循环删除它们。\n官方原文地址：CFNetwork Programming Guide\n","slug":"CFNetwork-编程指南之六-使用FTP服务器-Working-with-FTP-Servers","date":"2016-08-10T03:58:41.000Z","categories_index":"iOS网络编程","tags_index":"CFNetwork","author_index":"William Xie"},{"id":"e4b9eca156b9b591c912ba6382a5ef7f","title":"CFNetwork 编程指南之五: 与身份验证HTTP服务器通信(Communicating with Authenticating HTTP Servers)","content":"#与身份验证HTTP服务器通信\n本文描述了如何利用CFHTTPAuthentication API与需要身份验证的HTTP服务器通信。它解释了如何找到匹配的验证对象和证书，并将它们应用到HTTP请求，然后存储以供以后使用。\n一般来说，如果一个HTTP服务器返回一个401或407响应你的HTTP请求，这表明服务器进行身份验证需要证书。在CFHTTPAuthentication API中，每个证书组存储在CFHTTPAuthentication 对象中。因此，每个不同的身份认证服务器和每个不同用户连接的服务器需要一个单独的CFHTTPAuthentication 对象。与服务器通信，你需要应用CFHTTPAuthentication 对象到HTTP请求。接下来更加详细的解释这些步骤。\n\n\n##处理身份验证添加身份验证支持将允许你的应用和身份验证服务器（如果服务器返回401或407响应）进行交互。尽管HTTP身份验证不是一个难的概念，它是一个复杂的过程。步骤如下：\n\n\n\n\n\n\n\n\n\n1.客户端向服务器发送一个HTTP请求。2.服务器返回一个验证给客户端。3.客户端将原始请求的证书打包并发送给服务器。4.在客户端和服务器之间谈判5.当服务器验证了客户端身份，返回请求的响应。\n执行这个过程需要多个步骤。整个过程如图4-1和4-2.\n\n\n当一个HTTP请求返回一个401或407响应，第一步是为客户端找到一个有效的CFHTTPAuthentication 对象。一个身份验证对象包括证书和其他信息，当应用到HTTP消息请求，与服务器验证你的身份。如果你已经与服务器进行过身份验证，你会有一个有效的身份验证对象。然而，在大多数情况下，你需要使用CFHTTPAuthenticationCreateFromResponse 函数来创建一个对象。见列表4-1.\n\n\n\n\n\n\n\n\n\n注意：所有关于身份验证的示例代码改编自ImageClient 应用。\n列表4-1 创建一个身份验证对象\nif (!authentication) &#123;   \n\nCFHTTPMessageRef responseHeader =\n    (CFHTTPMessageRef) CFReadStreamCopyProperty(\n        readStream,\n        kCFStreamPropertyHTTPResponseHeader\n    );\n\n// Get the authentication information from the response.\nauthentication =\nCFHTTPAuthenticationCreateFromResponse(NULL, responseHeader);   \nCFRelease(responseHeader);\n&#125;\n\n如果新身份验证对象有效，那么你已经完成可以继续图4-1的第二步。如果身份验证对象无效，然后扔掉身份验证对象和证书，检查证书。关于证书的更多信息，阅读安全证书（Security Credentials）。\n不好的证书意味着服务器不接受登陆信息，它将继续监听新的证书。然而，如果证书是好的，但服务器仍然拒绝你的请求，然后服务器拒绝与你通信，你必须放弃。加上证书是不好的，重试整个过程，先创建身份验证对象直到你得到有效的证书和有效的验证对象。这个过程类似于列表4-2中的代码。\n列表4-2 查找一个有效的身份验证对象\nCFStreamError err;\n\nif (!authentication) &#123;\n\n// the newly created authentication object is bad, must return\nreturn;\n&#125; else if (!CFHTTPAuthenticationIsValid(authentication, &amp;err)) &#123;\n// destroy authentication and credentials\nif (credentials) &#123;\n    CFRelease(credentials);\n    credentials = NULL;\n&#125;\nCFRelease(authentication);\nauthentication = NULL;\n\n// check for bad credentials (to be treated separately)\nif (err.domain == kCFStreamErrorDomainHTTP &amp;&amp;\n    (err.error == kCFStreamErrorHTTPAuthenticationBadUserName\n    || err.error == kCFStreamErrorHTTPAuthenticationBadPassword))\n&#123;\n    retryAuthorizationFailure(&amp;authentication);\n    return;\n&#125; else &#123;\n    errorOccurredLoadingImage(err);\n&#125;\n&#125;\n\n现在你有一个有效的身份验证对象，继续图4-1中的流程。首先，考虑你是否需要证书。如果你不需要，则应由身份验证对象到HTTP请求。身份验证对象应用到HTTP请求详见列表4-4（resumeWithCredentials）。\n未存储证书（在内存中保存证书（Keeping Credentials in Memory ）和在永久性仓库中存储证书（Keeping Credentials in a Persistent Store）中有解释），获取有效证书的唯一方法是提示用户。大多数情况下，证书需要用户名和密码。通过传递身份验证对象到CFHTTPAuthenticationRequiresUserNameAndPassword 函数，你可以看到用户名和密码是必须的。如果证书需要用户名和密码，提示用户输入用户名和密码并在证书字典里存储。对于一个NTLM服务器，证书还需要一个域。在你有新的证书后，你可以调用列表4-4的函数resumeWithCredentials ，应用身份验证对象到HTTP请求。整个过程见列表4-3。\n\n\n\n\n\n\n\n\n\n注意：在代码列表中，前面有省略号的注释表明这个功能超出了本文的范围，但是需要实现。这不同与正常的注释描述正在发生什么功能。\n列表4-3 查找证书（如果需要）并应用它们\n// ...continued from Listing 4-2\nelse &#123;    cancelLoad();\n\nif (credentials) &#123;\n    resumeWithCredentials();\n&#125;\n// are a user name &amp; password needed?\nelse if (CFHTTPAuthenticationRequiresUserNameAndPassword(authentication))\n    &#123;\n    CFStringRef realm = NULL;\n    CFURLRef url = CFHTTPMessageCopyRequestURL(request);\n\n     // check if you need an account domain so you can display it if necessary\n    if (!CFHTTPAuthenticationRequiresAccountDomain(authentication)) &#123;\n        realm = CFHTTPAuthenticationCopyRealm(authentication);\n    &#125;\n    // ...prompt user for user name (user), password (pass)\n    // and if necessary domain (domain) to give to the server...\n\n    // Guarantee values\n    if (!user) user = CFSTR(\"\");\n    if (!pass) pass = CFSTR(\"\");\n\n    CFDictionarySetValue(credentials,\nkCFHTTPAuthenticationUsername, user);\n\n    CFDictionarySetValue(credentials,\nkCFHTTPAuthenticationPassword, pass);\n   // Is an account domain needed? (used currently for NTLM only)\n   if (CFHTTPAuthenticationRequiresAccountDomain(authentication)) &#123;\n       if (!domain) domain = CFSTR(\"\");\n       CFDictionarySetValue(credentials, kCFHTTPAuthenticationAccountDomain, domain);\n   &#125;\n   if (realm) CFRelease(realm);\nCFRelease(url);\n&#125; else &#123;\n   resumeWithCredentials();\n   &#125;\n&#125;\n列表4-4 应用身份验证对象到请求\nvoid resumeWithCredentials() &#123;   \n\n// Apply whatever credentials we've built up to the old request\nif (!CFHTTPMessageApplyCredentialDictionary(request, authentication,\n                                            credentials, NULL)) &#123;\n    errorOccurredLoadingImage();\n&#125; else &#123;\n    // Now that we've updated our request, retry the load\n    loadRequest();\n&#125;\n&#125;\n\n##在内存中存储证书如果你打算经常与一个身份验证服务器进行通信，重用证书可以来避免多次提示用户服务器用户名和密码。本章解释了一次性使用身份验证代码（例如处理身份验证（Handling Authentication））需要作出的变更，在内存中存储证书以便重用。\n重用证书，你的代码中需要更改三个数据结构。\n1.创建一个可变的数组来保存所有的身份验证对象。\nCFMutableArrayRef authArray;\n\n代替：\nCFHTTPAuthenticationRef authentication;\n\n2.使用字典，创建身份验证对象到证书的映射。\nCFMutableDictionaryRef credentialsDict;\n\n代替：\nCFMutableDictionaryRef credentials;\n\n3.保持这些结构在你原来修改当前身份验证对象和当前证书的地方。\nCFDictionaryRemoveValue(credentialsDict, authentication);\n\n代替：\nCFRelease(credentials);\n\n现在，创建HTTP请求后，在每次加载前，查找一个匹配的身份验证对象。查找适合对象的一个简单的非优化方法见列表4-5.\n列表4-5 查找一个匹配的身份验证对象\nCFHTTPAuthenticationRef findAuthenticationForRequest &#123;   \n\nint i, c = CFArrayGetCount(authArray);\nfor (i = 0; i &lt; c; i ++) &#123;\n    CFHTTPAuthenticationRef auth = (CFHTTPAuthenticationRef)\n            CFArrayGetValueAtIndex(authArray, i);\n    if (CFHTTPAuthenticationAppliesToRequest(auth, request)) &#123;\n        return auth;\n    &#125;\n&#125;\n   return NULL;\n&#125;\n\n\n如果身份验证数组有一个匹配的身份验证对象，然后检查证书仓库是否有正确的证书可用。这样做可以防止你需要再次提示用户输入用户名和密码。调用CFDictionaryGetValue 函数可以查找证书，如列表4-6所示。\n列表4-6 搜索证书仓库\ncredentials = CFDictionaryGetValue(credentialsDict, authentication);\n\n然后应用你的匹配的身份验证对象和证书到你原始的HTTP请求并重新发送。\n\n\n\n\n\n\n\n\n\n警告：在接收到服务器验证前，不要应用证书到HTTP请求。在你上次认证后，服务器可能改变，你可能会有一个安全风险。\n有了这些变更，你的应用可以在内存中存储身份验证对象和证书以便未来使用。\n##在永久性仓库中存储证书在内存中存储证书可以防止用户在特定应用启动时重新输入服务器用户名和密码。然而，当应用退出，这些证书被释放。为了避免丢失证书，将它们保存到永久性仓库，这样每个服务器证书只需要生成一次。推荐用钥匙链来存储证书。即使你有很多个钥匙链，本文档中的钥匙链指的是用户默认的钥匙链。使用钥匙链表明你存储的身份验证信息可以用于其他试图访问同一个服务器的应用中，反之亦然。\n在钥匙链中存储和检索证书需要两个函数：一个用于查找证书字典用于身份验证，另一个保存最近请求的证书。本文中这些函数声明如下：\nCFMutableDictionaryRef findCredentialsForAuthentication( CFHTTPAuthenticationRef auth);\nvoid saveCredentialsForRequest(void);\nfindCredentialsForAuthentication 函数首先检查内存中的证书字典本地缓存是否有证书。如何实现见列表4-6。\n如果内存中没有证书的缓存，然后搜索钥匙链。使用SecKeychainFindInternetPassword函数搜索钥匙链。该函数需要大量的参数。参数和一段简短的描述HTTP身份验证证书如何使用它们，如下：\nkeychainOrArray\nNULL 指定用户默认钥匙链列表。\nserverNameLength\nserverName的长度，通常是strlen(serverName)。\nserverName\n从HTTP请求解析到的服务器名称\nsecurityDomainLength\n安全域的长度，或0表示没有域。在示例代码中， realm ? strlen(realm) : 0向账户传递两种情形。\nsecurityDomain\n利用CFHTTPAuthenticationCopyRealm 函数获取身份验证对象范围\naccountNameLength\naccountName的长度。由于accountName是NULL，值为0\naccountName\n当读取钥匙链记录时没有账户名，该字段为NULL。\npathLength\npath的长度，如果没有路径则为0.在示例代码中，path ? strlen(path) : 0向账户传递两种情形。\npath\n利用CFURLCopyPath 函数从身份验证对象获取路径。\nport\n利用CFURLGetPortNumber函数获取端口号。\nprotocol\n代表协议类型的字符串，例如HTTP或HTTPS。通过CFURLCopyScheme 函数获取协议类型。\nauthenticationType\n利用CFHTTPAuthenticationCopyMethod函数获取身份验证类型。\npasswordLength\n0，因为在读取钥匙链记录时不需要密码。\npasswordData\nNULL，因为在读取钥匙链记录时不需要密码。\nitemRef\n查找到正确的钥匙链记录，返回钥匙链记录引用对象SecKeychainItemRef。\n当正确的调用，代码如列表4-7所示。\n列表4-7 搜索钥匙链\ndidFind =   \n\nSecKeychainFindInternetPassword(NULL,\n                                strlen(host), host,\n                                realm ? strlen(realm) : 0, realm,\n                                0, NULL,\n                                path ? strlen(path) : 0, path,\n                                port,\n                                protocolType,\n                                authenticationType,\n                                0, NULL,\n                                &amp;itemRef);\n\n\n假设SecKeychainFindInternetPassword 成功返回，创建一个包含单独钥匙链属性(SecKeychainAttribute)的钥匙链属性列表(SecKeychainAttributeList)。钥匙链实现列表将包含用户名和密码。为了加载钥匙链属性列表，调用SecKeychainItemCopyContent 函数并将SecKeychainFindInternetPassword返回的钥匙链记录引用对象(itemRef)传递给它。该函数将用账号的用户名和密码void **填充到钥匙链属性中。\n用户名和密码可以用来创建一组新证书。列表4-8展示了这个过程。\n列表4-8 从钥匙链价值服务器证书。\nif (didFind == noErr) &#123;\n\nSecKeychainAttribute    attr;\nSecKeychainAttributeList attrList;\nUInt32                  length;\nvoid                    *outData;\n\n// To set the account name attribute\nattr.tag = kSecAccountItemAttr;\nattr.length = 0;\nattr.data = NULL;\n\nattrList.count = 1;\nattrList.attr = &amp;attr;\n\nif (SecKeychainItemCopyContent(itemRef, NULL, &amp;attrList,\n&amp;length, &amp;outData)== noErr) &#123;\n    // attr.data is the account (username) and outdata is the password\n    CFStringRef username =\n        CFStringCreateWithBytes(kCFAllocatorDefault, attr.data,\n                                attr.length, kCFStringEncodingUTF8, false);\n    CFStringRef password =\n        CFStringCreateWithBytes(kCFAllocatorDefault, outData, length,\n                                kCFStringEncodingUTF8, false);\n    SecKeychainItemFreeContent(&amp;attrList, outData);\n\n    // create credentials dictionary and fill it with the user name &amp; password\n    credentials =\n        CFDictionaryCreateMutable(NULL, 0,\n                                  &amp;kCFTypeDictionaryKeyCallBacks,\n                                  &amp;kCFTypeDictionaryValueCallBacks);\n    CFDictionarySetValue(credentials, kCFHTTPAuthenticationUsername,\n                        username);\n    CFDictionarySetValue(credentials, kCFHTTPAuthenticationPassword,\n                        password);\n\n    CFRelease(username);\n    CFRelease(password);\n&#125;\nCFRelease(itemRef);\n&#125;\n\n\n\n如果你可以先存储证书到钥匙链中，从钥匙链中检索证书才有用。首先，查看证书是否已经存储在钥匙链中。调用SecKeychainFindInternetPassword，传递用户名到accountName ，传递accountName 的长度到accountNameLength``。\n如果记录存在，修改它来改变密码。设置钥匙链属性的数据字段包含用户名，主要你可以修改正确的属性。然后调用SecKeychainItemModifyContent 函数并传递钥匙链记录引用对象(itemRef)，钥匙链属性列表和新密码。通过修改钥匙链记录而非重写，钥匙链记录会正确的更新其他相关数据也将保留。记录如列表4-9所示。\n列表4-9 修改钥匙链记录\n// Set the attribute to the account name   \nattr.tag = kSecAccountItemAttr; \nattr.length = strlen(username); \nattr.data = (void*)username;\n// Modify the keychain entry   \nSecKeychainItemModifyContent(itemRef, &amp;attrList, strlen(password),   \n(void *)password);\n\n如果记录不存在，你将需要从头开始创建它。SecKeychainAddInternetPassword 函数完成该任务。它的参数与SecKeychainFindInternetPassword相同，但与调用SecKeychainFindInternetPassword相比，你提供用户名和密码给SecKeychainAddInternetPassword 。释放钥匙链记录引用对象成功后调用SecKeychainAddInternetPassword ，除非你需要在其他地方使用。见列表4-10函数调用。\n列表4-10 存储一个新的钥匙链记录\nSecKeychainAddInternetPassword(NULL,   \n\n                          strlen(host), host,\n                          realm ? strlen(realm) : 0, realm,\n                          strlen(username), username,\n                          path ? strlen(path) : 0, path,\n                          port,\n                          protocolType,\n                          authenticationType,\n                          strlen(password), password,\n                          &amp;itemRef);\n\n\n\n身份验证防火墙身份验证防火墙与身份验证服务器非常相似，处理必须检查每个失败的HTTP请求的代理身份验证和服务器身份验证。这以为着，你需要单独存储（本地和永久）代理服务器和源服务器。因此，失败的HTTP响应的过程如下：\n\n确定响应的状态码是否为407（代理怀疑）。如果是，检查当地代理仓库和永久性代理仓库查找一个匹配的身份验证对象和证书。如果这些都没有一个匹配的对象和证书，然后请求用户证书。应用身份验证对象到HTTP请求并重试。\n\n确定响应的状态码是否为401（服务器怀疑）。如果是，遵循与407响应相同的过程，但是用原始服务器存储。\n\n\n使用代理服务器有些细微的差别。首先，钥匙链调用的参数来自于代理主机和端口，而非一个源服务器的URL。第二，当要求用户输入用户名和密码，确保清楚的提示是什么密码。\n通过这些指令，你的应用应该可以使用身份验证防火墙。\n官方原文地址：CFNetwork Programming Guide\n","slug":"CFNetwork-编程指南之五-与身份验证HTTP服务器通信-Communicating-with-Authenticating-HTTP-Servers","date":"2016-08-10T03:58:03.000Z","categories_index":"iOS网络编程","tags_index":"CFNetwork","author_index":"William Xie"},{"id":"07ef757033d0429be6d914103f281624","title":"CFNetwork 编程指南之四: 与HTTP服务器通信(Communicating with HTTP Servers)","content":"#与HTTP服务器通信\n本文解释了如何创建、发送和接收HTTP请求和响应。\n##创建一个CFHTTP请求HTTP请求是一个消息，这个消息由远程服务器执行的方法，操作的对象（URL），消息头和消息体。方法通常是下面之一：GET, HEAD, PUT, POST, DELETE, TRACE, CONNECT 或OPTIONS。用CFHTTP创建一个HTTP请求分为四个步骤：\n\n使用CFHTTPMessageCreateRequest 函数生成CFHTTP消息对象\n使用CFHTTPMessageSetBody函数设置消息体\n使用CFHTTPMessageSetHeaderFieldValue 函数设置消息头\n通过调用CFHTTPMessageCopySerializedMessage函数序列化消息\n\n\n\n示例代码类似列表3-1中的代码。\n列表3-1 创建一个HTTP请求\nCFStringRef bodyString = CFSTR(\"\"); // Usually used for POST data \nCFDataRef bodyData =     \nCFStringCreateExternalRepresentation     \n(kCFAllocatorDefault,bodyString,kCFStringEncodingUTF8, 0);\n\nCFStringRef headerFieldName = CFSTR(\"X-My-Favorite-Field\");\nCFStringRef headerFieldValue = CFSTR(\"Dreams\");\n\nCFStringRef url = CFSTR(\"http://www.apple.com\");\nCFURLRef myURL = CFURLCreateWithString(kCFAllocatorDefault, url, NULL);\n\nCFStringRef requestMethod = CFSTR(\"GET\");\nCFHTTPMessageRef myRequest =\nCFHTTPMessageCreateRequest(kCFAllocatorDefault, requestMethod, myURL,\n                          kCFHTTPVersion1_1);\n\nCFDataRef bodyDataExt =\nCFStringCreateExternalRepresentation(kCFAllocatorDefault,     \nbodyData, kCFStringEncodingUTF8, 0);   \nCFHTTPMessageSetBody(myRequest, bodyDataExt);     \n\nCFHTTPMessageSetHeaderFieldValue(myRequest,\nheaderFieldName, headerFieldValue);\nCFDataRef mySerializedRequest =       \nCFHTTPMessageCopySerializedMessage(myRequest);\n\n在此示例代码中，通过调用CFURLCreateWithString，url 是首先转换成一个CFURL对象。然后调用CFHTTPMessageCreateRequest ，有四个参数：kCFAllocatorDefault 指定默认系统内存分配器用来创建消息应用，requestMethod 指定方法，例如POST方法，myURL 用来指定URL，例如，http://www.apple.com，kCFHTTPVersion1_1指定消息HTTP版本是1.1.\nCFHTTPMessageCreateRequest 返回的消息对象引用(myRequest)和消息体(bodyData)一起发送到CFHTTPMessageSetBody 。然后调用CFHTTPMessageSetHeaderFieldValue 使用相同消息对象引用，头(headerField)名称和设置的值(value)。头参数是个CFString对象，例如Content-Length,值参数是一个CFString对象例如1260.最后，调用CFHTTPMessageCopySerializedMessage序列化消息，通过写入流发送到接受者，例子详见http://www.apple.com\n\n\n\n\n\n\n\n\n\n注意：请求主体通常省略。请求主体通常用于一个包含POST数据的POST请求。它也可以用于其他有关HTTP扩展的请求类型，例如WebDAV。更多信息参见RFC 2616。\n当不再需要消息，释放消息对象并序列化消息。见列表3-2的示例代码\n列表3-2 释放一个HTTP请求\nCFRelease(myRequest);   \nCFRelease(myURL); \nCFRelease(url); \nCFRelease(mySerializedRequest); \nmyRequest = NULL; \nmySerializedRequest = NULL;\n\n\n##创建一个CFHTTP响应创建一个HTTP响应的步骤与创建一个HTTP请求的步骤几乎完全相同。唯一的区别是，调用函数CFHTTPMessageCreateResponse ，而不是CFHTTPMessageCreateRequest，两者使用相同的参数\n反序列化传入的HTTP请求反序列化一个传入的HTTP请求，使用CFHTTPMessageCreateEmpty 函数，创建一个空消息，isRequest 参数设为TRUE 指定创建一个空的请求消息。然后调用CFHTTPMessageAppendBytes函数将传入的消息添加到空消息中。CFHTTPMessageAppendBytes反序列化消息并移除任何可能包含的控制信息。\n继续这样做直到CFHTTPMessageIsHeaderComplete 函数返回TRUE。如果你不检查CFHTTPMessageIsHeaderComplete 是否返回TRUE，消息可能是不完整的或不可信的。列表3-3可以看到这两个函数使用的例子。\n列表3-3 反序列化消息\nCFHTTPMessageRef myMessage =   \nCFHTTPMessageCreateEmpty(kCFAllocatorDefault, TRUE);   \nif (!CFHTTPMessageAppendBytes(myMessage, &amp;data, numBytes)) &#123;   \n\n//Handle parsing error\n&#125;\n\n\n\n在示例中，data 是添加的数据而numBytes 是的data 长度。调用CFHTTPMessageIsHeaderComplete 验证附加消息的头是完整的。\nif (CFHTTPMessageIsHeaderComplete(myMessage)) &#123; \n\n// Perform processing.\n&#125;\n\n\n\n\n消息反序列化后，你可以调用如下函数从消息中提取信息：\n\nCFHTTPMessageCopyBody 用来获取消息主体\nCFHTTPMessageCopyHeaderFieldValue 用来获取特定头字段值\nCFHTTPMessageCopyAllHeaderFields 用来获取所有消息头字段\nCFHTTPMessageCopyRequestURL 用来获取消息URL\nCFHTTPMessageCopyRequestMethod 用来获取消息请求方法\n\n当你不再需要该消息，释放并恰当的处理它。\n##反序列化传入的HTTP响应正如创建HTTP请求类似于创建HTTP响应一样，反序列化传入的HTTP请求与反序列化传入的HTTP响应类似。唯一重要的区别是，当调用CFHTTPMessageCreateEmpty，你必须给isRequest 参数传入FALSE 来指定将要创建的消息是响应消息。\n##使用读取流序列化并发送HTTP请求你可以使用CFReadStream对象来序列化和发送CFHTTP请求。当你使用CFReadStream对象来发送一个CFHTTP请求时，打开流因为消息必须在同一步中序列化好发送。使用CFReadStream 对象来发送CFHTTP请求，使获取请求的响应更加容易，因为响应作为流的属性是可用的。\n###序列化并发送一个HTTP请求使用CFReadStream 对象序列化并发送HTTP请求，首先创建一个CFHTTP请求并设置消息主体和头，在创建CFHTTP请求（Creating a CFHTTP Request）中有描述。然后，调用CFReadStreamCreateForHTTPRequest 函数创建一个CFReadStream 对象，传递你刚刚创建的请求。最后，通过CFReadStreamOpen打开读取流。\n当调用CFReadStreamCreateForHTTPRequest ，复制一份传入的CFHTTP请求对象。因此，如果有必要，你可以在调用CFReadStreamCreateForHTTPRequest 之后立即释放CFHTTP请求对象。\n因为当创建CFHTTP请求时，读取流打开一个套接字连接myUrl 参数指定的服务器，两者之间允许有些时间差。打开读取流也会导致请求被序列化和发送。\n列表3-4是一个关于如何序列化和发送HTTP请求的例子\n列表3-4 读取流序列化HTTP请求\nCFStringRef url = CFSTR(\"http://www.apple.com\"); \nCFURLRef myURL = CFURLCreateWithString(kCFAllocatorDefault, url, NULL); \nCFStringRef requestMethod = CFSTR(\"GET\"); \nCFHTTPMessageRef myRequest =     \nCFHTTPMessageCreateRequest(kCFAllocatorDefault,   \nrequestMethod, myUrl, kCFHTTPVersion1_1); \nCFHTTPMessageSetBody(myRequest, bodyData); \nCFHTTPMessageSetHeaderFieldValue(myRequest, headerField, value); \nCFReadStreamRef myReadStream =     \nCFReadStreamCreateForHTTPRequest(kCFAllocatorDefault, myRequest); \nCFReadStreamOpen(myReadStream);\n\n###检查响应在你安排请求到运行循环后，你将最终会得到一个头完成回调。在这一点上，你可以调用CFReadStreamCopyProperty 从读取流获取消息响应。\nCFHTTPMessageRef myResponse = (CFHTTPMessageRef)CFReadStreamCopyProperty(myReadStream,kCFStreamPropertyHTTPResponseHeader);\n\n你可以通过调用CFHTTPMessageCopyResponseStatusLine函数，从消息响应获取完整状态行：\nCFStringRef myStatusLine = CFHTTPMessageCopyResponseStatusLine(myResponse);\n\n通过调用CFHTTPMessageGetResponseStatusCode函数获取消息响应的状态码：\nUInt32 myErrCode = CFHTTPMessageGetResponseStatusCode(myResponse);\n\n\n\n\n\n\n\n\n\n\n注意：如果你正在同步使用这个类（没有安排到运行循环），你必须在调用CFReadStreamCopyProperty之前调用CFReadStreamRead ，先读取消息。CFReadStreamRead 调用一直阻塞直到数据可用（或连接失败）。不要在你的主应用线程中使用。\n###处理身份验证错误如果CFHTTPMessageGetResponseStatusCode 函数返回的状态码是401（远程服务器需要身份验证信息）或407（代理服务器需要身份验证），你需要将身份验证信息附加到请求并重新发送。关于如何处理身份验证的信息，请查看与需要身份验证HTTP服务器通信（ Communicating with Authenticating HTTP Servers）。\n###处理重定向错误当CFReadStreamCreateForHTTPRequest 创建一个读取流，默认情况下流的自动重定向是禁用的。如果请求发送的统一资源定位符或URL重定向到另一个URL，发送该请求将导致一个错误，状态码在300到307之间。如果你接收到一个重定向错误，你需要关闭流，创建流，启用重定向并打开流。参见列表3-5.\n列表3-5 重定向HTTP流\nCFReadStreamClose(myReadStream);\nCFReadStreamRef myReadStream =\nCFReadStreamCreateForHTTPRequest(kCFAllocatorDefault, myRequest);\nif (CFReadStreamSetProperty(myReadStream,\nkCFStreamPropertyHTTPShouldAutoredirect, kCFBooleanTrue) == false) &#123;\n\n// something went wrong, exit\n\n&#125;\nCFReadStreamOpen(myReadStream);\n\n当你创建一个读取流，你可能想要启用自动重定向。\n##取消一个待定请求一旦请求已经发送，不能阻止远程服务器处理它。然而，你不再关心响应数据，你可以关闭流。\n\n\n\n\n\n\n\n\n\n重要：如果另一个线程正在等待某个线程的流的内容，则不要关闭该流。如果你需要终止请求时，你应该使用非阻塞 I/O，在使用流时防止阻塞（Preventing Blocking When Working with Streams）中有描述。确保在关闭流之前从你的运行循环上移除流。\n官方原文地址：CFNetwork Programming Guide\n","slug":"CFNetwork-编程指南之四-与HTTP服务器通信-Communicating-with-HTTP-Servers","date":"2016-08-10T03:57:31.000Z","categories_index":"iOS网络编程","tags_index":"CFNetwork","author_index":"William Xie"},{"id":"2ceaaff5f996f8ed02b5f1f94c9c06a5","title":"CFNetwork 编程指南之三: 使用流(Working with Streams)","content":"#Working with Streams\n本文讨论如何创建、打开和检查读写流错误。它还描述了如何从读取流读取信息，如何从写入信息到写入流，如何在读取或写入流时防止阻塞以及如何通过代理服务器导航到流。\n##使用读取流核心基础流可用于读取或写入文件或使用网络套接字。除了创建这些流过程中的异常，其他行为类似。\n###创建一个读取流首先创建一个读取流。列表2-1为一个文件创建读取流。\n列表2-1 为一个文件创建读取流\nCFReadStreamRef myReadStream = CFReadStreamCreateWithFile(kCFAllocatorDefault, fileURL);\n\n在这个列表中，kCFAllocatorDefault 参数指定当前默认系统分配器来为流分配内存，fileURL 参数指定读取流创建到的文件名称，例如 file:///Users/joeuser/Downloads/MyApp.sit\n类似的，你可以通过调用CFStreamCreatePairWithSocketToCFHost（在使用运行循环阻止阻塞（Using a Run Loop to Prevent Blocking）中有描述）或者CFStreamCreatePairWithSocketToNetService（在NSNetServices and CFNetServices 编程指南（NSNetServices and CFNetServices Programming Guide）中有描述）来创建一对基于网络服务的流。\n现在，你已经创建流，你可以打开它。打开流将导致流保留需要的任何系统资源，例如打开文件所需的文件描述符。列表2-1是一个打开读取流的例子。\n列表2-2 打开读取流\nif (!CFReadStreamOpen(myReadStream)) &#123;  \n     CFStreamError myErr = CFReadStreamGetError(myReadStream);  \n       // An error has occurred.     \n     if (myErr.domain == kCFStreamErrorDomainPOSIX) &#123;  \n         // Interpret myErr.error as a UNIX errno.    \n     &#125; else if (myErr.domain == kCFStreamErrorDomainMacOSStatus) &#123;   \n        // Interpret myErr.error as a MacOS error code.  \n        OSStatus macError = (OSStatus)myErr.error;     \n        // Check other error domains.    \n     &#125;\n&#125;\n\nCFReadStreamOpen 函数返回TRUE 表示成功，FALSE 表示由于某种原因打开失败。如果CFReadStreamOpen 返回FALSE，例子调用CFReadStreamGetError 函数，将返回CFStreamError 类型结构，包含两个值：一个域代码和一个错误代码。域代码表明错误代码应该如何解释。例如，如果域代码是kCFStreamErrorDomainPOSIX，错误代码是UNIX errno值。其他错误域是kCFStreamErrorDomainMacOSStatus，表明错误代码是一个定义在MacErrors.h中的OSStatus 值，kCFStreamErrorDomainHTTP表明错误代码是CFStreamErrorHTTP 枚举中定义的值。\n打开一个流是一个漫长的过程，所以CFReadStreamOpen 函数和CFWriteStreamOpen 函数返回TRUE 表明打开流的过程已经开始，来避免阻塞。为了检查打开的装填，可以调用CFReadStreamGetStatus 和CFWriteStreamGetStatus函数，如果仍处于打开过程则返回``kCFStreamStatusOpening，如果已经打开则返回kCFStreamStatusOpen ，如果已经打开但失败了则返回kCFStreamStatusErrorOccurred。在大多数情况下，打开是否完成无关紧要，因为CFStream`函数的读写将会阻塞直到打开流。\n###从读取流中读取信息从读取流中读取信息，调用函数CFReadStreamRead，这个函数类似于UNIX read() 系统调用。两者都采用缓存区和缓存区长度作为参数。两者都返回读取的字节数，在流或文件末尾则返回0，错误发生则返回-1.两者都阻塞直到可以读取一个字节并继续读取。列表2-3是从读取流中读取信息的例子。\n列表2-3 从读取流（blocking）中读取信息\nCFIndex numBytesRead;\ndo &#123;   \n   UInt8 buf[myReadBufferSize]; \n    // define myReadBufferSize as desired  \n    numBytesRead = CFReadStreamRead(myReadStream, buf, sizeof(buf)); \n\n    if( numBytesRead > 0 ) &#123;     \n      handleBytes(buf, numBytesRead);  \n    &#125; else if( numBytesRead &lt; 0 ) &#123;  \n      CFStreamError error = CFReadStreamGetError(myReadStream);       \n           reportError(error);    \n    &#125;\n\n&#125; while( numBytesRead > 0 );\n\n\n\n###释放读取流当所有数据都被读取，你可以调用CFReadStreamClose 函数关闭流，从而释放有关系统资源。然后通过调用CFRelease函数释放流引用。你可以设置引用为NULL使其无效。如列表2-4的例子。\n列表2-4 释放读取流\nCFReadStreamClose(myReadStream);\nCFRelease(myReadStream);\nmyReadStream = NULL;\n\n\n##使用写入流使用写入流类似于使用读取流。一个主要的区别是CFWriteStreamWrite 函数并不能保证接收你传递给它的所有字节。相反，CFWriteStreamWrite 返回它接收的字节数。你会看到列表2-5中的实例代码，如果写入的字节数与需要写入的总字节数不一致，缓存区会调整并适应这一点。\n列表2-5 创建、打开、写入并释放写入流\nCFWriteStreamRef myWriteStream =\n        CFWriteStreamCreateWithFile(kCFAllocatorDefault, fileURL);\nif (!CFWriteStreamOpen(myWriteStream)) &#123;\n    CFStreamError myErr = CFWriteStreamGetError(myWriteStream);\n    // An error has occurred.\n    if (myErr.domain == kCFStreamErrorDomainPOSIX) &#123;\n    // Interpret myErr.error as a UNIX errno.\n    &#125; else if (myErr.domain == kCFStreamErrorDomainMacOSStatus) &#123;\n        // Interpret myErr.error as a MacOS error code.\n        OSStatus macError = (OSStatus)myErr.error;\n        // Check other error domains.\n    &#125;\n&#125;\nUInt8 buf[] = “Hello, world”;\nCFIndex bufLen = (CFIndex)strlen(buf);\n \nwhile (!done) &#123;\n    CFIndex bytesWritten = CFWriteStreamWrite(myWriteStream, buf, (CFIndex)bufLen);\n    if (bytesWritten &lt; 0) &#123;\n        CFStreamError error = CFWriteStreamGetError(myWriteStream);\n        reportError(error);\n    &#125; else if (bytesWritten == 0) &#123;\n        if (CFWriteStreamGetStatus(myWriteStream) == kCFStreamStatusAtEnd) &#123;\n            done = TRUE;\n        &#125;\n    &#125; else if (bytesWritten != bufLen) &#123;\n        // Determine how much has been written and adjust the buffer\n        bufLen = bufLen - bytesWritten;\n        memmove(buf, buf + bytesWritten, bufLen);\n \n        // Figure out what went wrong with the write stream\n        CFStreamError error = CFWriteStreamGetError(myWriteStream);\n        reportError(error);\n \n    &#125;\n&#125;\nCFWriteStreamClose(myWriteStream);\nCFRelease(myWriteStream);\nmyWriteStream = NULL;\n\n\n##使用流时防止阻塞\n当使用流来通信时，特别是基于套接字的流，数据传输可能需要很长时间。如果你同步执行你的流，你的整个应用将被迫等待数据传输。因此，强烈建议你的代码使用替代方法来防止阻塞。\n当读取或写入一个CFStream对象时，有两种方法可以防止阻塞：\n\n使用一个运行循环——注册账户接收stream-related 事件并安排流到一个运行循环上。当stream-related 事件发生时，调用你的回调函数（注册调用时指定）。\n\n轮询——对于读取流，在读取流之前找出是否有需要读取的字节。对于写入流，在写入流之前找出流是否可以无阻塞的写入。\n\n\n将在以下章节中讨论这些方法。\n###使用运行循环防止阻塞使用流的首选方法是运行循环。运行循环在你的主线程上执行。等待事件发生，然后调用与给定事件相关的函数。\n在网络传输的情况下，当你的注册事件发生时，你的回调函数被运行循环执行。这样你可以不必轮询你的套接字流，可以减缓线程。\n关于运行循环的更多信息，参阅线程编程指南（Threading Programming Guide）。\n这个例子首先创建一个套接字读取流：\nCFStreamCreatePairWithSocketToCFHost(kCFAllocatorDefault, host,port,\n                                  &amp;myReadStream, NULL);\n\n\nCFHost对象引用、host指定远程主机为读取流的主机，port 参数指定主机使用的端口号。CFStreamCreatePairWithSocketToCFHost 函数返回新的读取流引用myReadStream。最后一个参数NULL表明调用者不希望创建写入流。如果你想创建一个写入流，最后一个参数为&amp;myWriteStream。\n在打开套接字读取流之前，创建一个内容，这样当你注册接收 stream-related事件时可以使用。\nCFStreamClientContext myContext = &#123;0, myPtr, myRetain, myRelease, myCopyDesc&#125;;\n\n\n第一个参数是0指定版本号。info 参数myPtr是你想要传递给回调函数的数据指针。通常，myPtr是一个指向结构体的指针，在结构体中你定义了包含有关流的信息。参数retain 是一个指向函数的指针，可以保留参数info 。所以在函数中设置为myRetain，在上面的代码中，CFStream 将调用myRetain(myPtr)来保留info 指针。同样，release 参数myRelease是一个指向函数的指针，释放参数info 。当流与内容分离，CFStream将调用 myRelease(myPtr)。最后，copyDescription 是函数的一个参数，该函数提供流的描述。例如，如果你是调用上文所示的CFCopyDesc(myReadStream) ，CFStream将调用myCopyDesc(myPtr)。\n客户端环境允许你设置retain, release和copyDescription 参数为NULL。如果你设置retain 和参数release 为NULL，系统将认为info 指针指向的内存一直存在直到流本身被销毁。如果你将copyDescription 参数设置为NULL，如果有要求，系统将提供info 指针所指向内存的基本信息。\n设置好客户端环境后，调用函数CFReadStreamSetClient 注册接收有关流事件。CFReadStreamSetClient 要求你指定回调函数和你想接收的事件。列表2-6中的例子指定回调函数和接收的kCFStreamEventHasBytesAvailable,kCFStreamEventErrorOccurred和kCFStreamEventEndEncountered 事件。然后调用CFReadStreamScheduleWithRunLoop函数安排流到一个运行循环上。例子见列表2-6.\n列表2-6 安排流到运行循环上\nCFOptionFlags registeredEvents = kCFStreamEventHasBytesAvailable |\n        kCFStreamEventErrorOccurred | kCFStreamEventEndEncountered;\nif (CFReadStreamSetClient(myReadStream, registeredEvents, myCallBack, &amp;myContext))\n&#123;\n    CFReadStreamScheduleWithRunLoop(myReadStream, CFRunLoopGetCurrent(),\n                                    kCFRunLoopCommonModes);\n&#125;\n\n流安排到运行循环上后，你可以准备打开流，如列表2-7所示。\n列表2-7 打开非阻塞读取流\nif (!CFReadStreamOpen(myReadStream)) &#123;\n    CFStreamError myErr = CFReadStreamGetError(myReadStream);\n    if (myErr.error != 0) &#123;\n    // An error has occurred.\n        if (myErr.domain == kCFStreamErrorDomainPOSIX) &#123;\n        // Interpret myErr.error as a UNIX errno.\n            strerror(myErr.error);\n        &#125; else if (myErr.domain == kCFStreamErrorDomainMacOSStatus) &#123;\n            OSStatus macError = (OSStatus)myErr.error;\n            &#125;\n        // Check other domains.\n    &#125; else\n        // start the run loop\n        CFRunLoopRun();\n&#125;\n\n\n现在，等待你的回调函数执行。在你的回调函数中，检查事件代码并采取适当的行动。见列表2-8.\n列表2-8 网络事件回调函数\nvoid myCallBack (CFReadStreamRef stream, CFStreamEventType event, void *myPtr) &#123;\n    switch(event) &#123;\n        case kCFStreamEventHasBytesAvailable:\n            // It is safe to call CFReadStreamRead; it won’t block because bytes\n            // are available.\n            UInt8 buf[BUFSIZE];\n            CFIndex bytesRead = CFReadStreamRead(stream, buf, BUFSIZE);\n            if (bytesRead > 0) &#123;\n                handleBytes(buf, bytesRead);\n            &#125;\n            // It is safe to ignore a value of bytesRead that is less than or\n            // equal to zero because these cases will generate other events.\n            break;\n        case kCFStreamEventErrorOccurred:\n            CFStreamError error = CFReadStreamGetError(stream);\n            reportError(error);\n            CFReadStreamUnscheduleFromRunLoop(stream, CFRunLoopGetCurrent(),\n                                              kCFRunLoopCommonModes);\n            CFReadStreamClose(stream);\n            CFRelease(stream);\n            break;\n        case kCFStreamEventEndEncountered:\n            reportCompletion();\n            CFReadStreamUnscheduleFromRunLoop(stream, CFRunLoopGetCurrent(),\n                                              kCFRunLoopCommonModes);\n            CFReadStreamClose(stream);\n            CFRelease(stream);\n            break;\n    &#125;\n&#125;\n\n\n\n当回调函数接收kCFStreamEventHasBytesAvailable 事件代码，它会调用CFReadStreamRead` 来读取数据。\n当回调函数接收kCFStreamEventErrorOccurred 事件代码，它会调用CFReadStreamGetError 来获取错误和自己的错误函数 (reportError)来处理错误。\n当回调函数接收kCFStreamEventEndEncountered 事件代码，它调用自己的函数 (reportCompletion)来处理最终的数据然后调用CFReadStreamUnscheduleFromRunLoop 函数从指定运行循环上移除流。然后运行CFReadStreamClose 函数来关闭流，CFRelease 来释放流引用。\n###轮询网络流一般来说，轮询网络流是不明智的。然而，在某些罕见的情况下，它非常有用。为了轮询流，你首先检查流是否可以读取或写入，然后在流上执行一个读取或写入的操作。\n当写入到一个写入流中，你通过调用CFWriteStreamCanAcceptBytes可以决定流是否接受数据。如果返回TRUE，那么你可以确定随后调用的CFWriteStreamWrite 函数将立即发送数据而没有阻塞。\n同样，对于读取流，在调用CFReadStreamRead之前，调用CFReadStreamHasBytesAvailable函数。\n列表2-9 是一个轮询读取流的例子\n列表2-9 轮询读取流\nwhile (!done) &#123;\n    if (CFReadStreamHasBytesAvailable(myReadStream)) &#123;\n        UInt8 buf[BUFSIZE];\n        CFIndex bytesRead = CFReadStreamRead(myReadStream, buf, BUFSIZE);\n        if (bytesRead &lt; 0) &#123;\n            CFStreamError error = CFReadStreamGetError(myReadStream);\n            reportError(error);\n        &#125; else if (bytesRead == 0) &#123;\n            if (CFReadStreamGetStatus(myReadStream) == kCFStreamStatusAtEnd) &#123;\n                done = TRUE;\n            &#125;\n        &#125; else &#123;\n            handleBytes(buf, bytesRead);\n        &#125;\n    &#125; else &#123;\n        // ...do something else while you wait...\n    &#125;\n&#125;\n\n\n列表2-10 轮询写入流的例子\n列表2-10 轮询写入流\nUInt8 buf[] = “Hello, world”;\nUInt32 bufLen = strlen(buf);\n \nwhile (!done) &#123;\n    if (CFWriteStreamCanAcceptBytes(myWriteStream)) &#123;\n        int bytesWritten = CFWriteStreamWrite(myWriteStream, buf, strlen(buf));\n        if (bytesWritten &lt; 0) &#123;\n            CFStreamError error = CFWriteStreamGetError(myWriteStream);\n            reportError(error);\n        &#125; else if (bytesWritten == 0) &#123;\n            if (CFWriteStreamGetStatus(myWriteStream) == kCFStreamStatusAtEnd)\n            &#123;\n                done = TRUE;\n            &#125;\n        &#125; else if (bytesWritten != strlen(buf)) &#123;\n            // Determine how much has been written and adjust the buffer\n            bufLen = bufLen - bytesWritten;\n            memmove(buf, buf + bytesWritten, bufLen);\n \n            // Figure out what went wrong with the write stream\n            CFStreamError error = CFWriteStreamGetError(myWriteStream);\n            reportError(error);\n        &#125;\n    &#125; else &#123;\n        // ...do something else while you wait...\n    &#125;\n&#125;\n\n\n##导航防火墙有两种方式设置流的防火墙。对于大多数流，你可以使用SCDynamicStoreCopyProxies 函数来检索代理设置，然后设置kCFStreamHTTPProxy （或kCFStreamFTPProxy）属性将结果应用于流。SCDynamicStoreCopyProxies 函数是系统配置框架的一部分，因此你需要在你的项目中使用该函数时需导入&lt;SystemConfiguration/SystemConfiguration.h&gt;。然后当你完成后，释放代理字典引用。整个过程如列表2-11所示。\n列表2-11 通过代理服务器导航一个流\nCFDictionaryRef proxyDict = SCDynamicStoreCopyProxies(NULL);\nCFReadStreamSetProperty(readStream, kCFStreamPropertyHTTPProxy, proxyDict);\n然而，如果你经常需要使用代理设置多个流，这将变得更加复杂。在这种情况下，检索用户机器防火墙设置需要五个步骤：\n\n为动态存储会话SCDynamicStoreRef，创建一个持久的句柄。\n\n将句柄添加到运行循环中的动态存储会话上，这样可以收到代理更改的通知。\n\n使用SCDynamicStoreCopyProxies 检索最新的代理设置。\n\n当被告知变更，更新你的代理。\n\n当通过后，清理SCDynamicStoreRef。\n\n\n为动态存储会话创建句柄，使用SCDynamicStoreCreate 函数并传递一个分配器，一个名字来描述你的过程，一个回调函数和一个动态存储环境SCDynamicStoreContext。当初始化应用时运行。代码如列表2-12所示.\n列表2-12 为动态存储会话创建一个句柄\nSCDynamicStoreContext context = &#123;0, self, NULL, NULL, NULL&#125;;\nsystemDynamicStore = SCDynamicStoreCreate(NULL,\n                                          CFSTR(\"SampleApp\"),\n                \t                      proxyHasChanged,\n           \t\t\t\t\t\t\t\t  &amp;context);\n创建动态存储引用后，你需要将其添加到运行循环上。首先，采用动态存储引用 对 代理的任何更改 设置监控。使用SCDynamicStoreKeyCreateProxies 和SCDynamicStoreSetNotificationKeys函数可完成该功能。然后，你可以调用SCDynamicStoreCreateRunLoopSource 和CFRunLoopAddSource函数添加动态存储引用到运行循环上。代码如列表2-13所示。\n列表2-13 添加一个动态存储引用到运行循环\n// Set up the store to monitor any changes to the proxies\nCFStringRef proxiesKey = SCDynamicStoreKeyCreateProxies(NULL);\nCFArrayRef keyArray = CFArrayCreate(NULL,\n                                    (const void **)(&amp;proxiesKey),\n                                    1,\n                                    &amp;kCFTypeArrayCallBacks);\nSCDynamicStoreSetNotificationKeys(systemDynamicStore, keyArray, NULL);\nCFRelease(keyArray);\nCFRelease(proxiesKey);\n \n// Add the dynamic store to the run loop\nCFRunLoopSourceRef storeRLSource =\n    SCDynamicStoreCreateRunLoopSource(NULL, systemDynamicStore, 0);\nCFRunLoopAddSource(CFRunLoopGetCurrent(), storeRLSource, kCFRunLoopCommonModes);\nCFRelease(storeRLSource);\n\n一旦动态存储引用添加到运行循环上，调用SCDynamicStoreCopyProxies函数，用它来预加载代理字典当前代理设置。如列表2-14所示\n列表2-14 加载代理字典\ngProxyDict = SCDynamicStoreCopyProxies(systemDynamicStore);\n\n\n由于动态存储引用添加到运行循环上，每次代理改变，你的回调函数会运行。释放当前代理字典并使用新的代理设置重新加载。回调函数示例代码如列表2-15所示。\n列表2-15 代理回调函数\nvoid proxyHasChanged() &#123;\nCFRelease(gProxyDict);\n   gProxyDict = SCDynamicStoreCopyProxies(systemDynamicStore);\n&#125;\n因为所有代理信息是最新的。创建读取或写入流后，通过调用CFReadStreamSetProperty 和CFWriteStreamSetProperty函数，设置kCFStreamPropertyHTTPProxy 代理。如果流是叫做的readStream读取流，函数调用如列表2-16所示。\n列表2-16 添加代理信息到流\nCFReadStreamSetProperty(readStream, kCFStreamPropertyHTTPProxy, gProxyDict);\n\n\n当代理设置完成，确保释放字典和动态存储引用并从运行循环上删除动态存储引用。见列表2-17.\n列表2-17 清理代理信息\nif (gProxyDict) &#123;\nCFRelease(gProxyDict);&#125;\n// Invalidate the dynamic store's run loop source\n// to get the store out of the run loop\nCFRunLoopSourceRef rls = SCDynamicStoreCreateRunLoopSource(NULL, systemDynamicStore, 0);\nCFRunLoopSourceInvalidate(rls);\nCFRelease(rls);\nCFRelease(systemDynamicStore);\n官方原文地址：CFNetwork Programming Guide\n","slug":"CFNetwork-编程指南之三-使用流-Working-with-Streams","date":"2016-08-10T03:57:01.000Z","categories_index":"iOS网络编程","tags_index":"CFNetwork","author_index":"William Xie"},{"id":"a332cbc6e65f305f252e6ab66fc98405","title":"CFNetwork 编程指南之二: CFNetwork概念（CFNetwork Concepts)","content":"#CFNetwork概念\nCFNetwork是一个低级别高性能的框架，使你能够精细的控制协议栈。它是BSD套接字的扩展，标准套接字抽象API提供对象来简化任务，例如与FTP和HTTP服务器通信或解析DNS主机。CFNetwork物理上和理论上都基于BSD套接字。\n正如CFNetwork依赖与BSD套接字，有大量的Cocoa类依赖CFNetwork（例如，NSURL）。此外，Cocoa类的web工具包用来在窗口显示网页内容。这两个类是高层级，并实现大部分的网络协议。因此，软件层的结构如图1-1所示。\n\n\n##何时使用CFNetworkCFNetwork相对BSD套接字有很多优点，它提供了run-loop集成，因此，如果你的应用程序是基于运行循环，你可以使用网络协议，而不用实现线程。CFNetwork还包含大量的对象可帮助你使用网络协议，而不用实现具体的细节。例如，你可以使用FTP协议，而不用实现CFFTP API的所有细节。如果你了解网络协议，需要它们提供低级别的控制，但是不想自己实现，这时CFNetwork可能是正确的选择。\n使用CFNetwork替代Foundation 级别网络API有很多好处。CFNetwork更侧重于网络协议，而Foundation 级别API侧重于数据访问，例如通过HTTP或FTP传输数据。虽然框架API提供了一些可配置性，但CFNetwork提供了更多。关于框架网络类的更多信息，请参阅URL Session Programming Guide。\n现在你已了解CFNetwork如何与其他OS X网络API交互，可以开始了解CFNetwork API和形成CFNetwork基础的两个API。\n##CFNetwork基础在学习CFNetwork API之前，你首先需要了解API，这些API是CFNetwork的基础。CFNetwork依赖的两个API：CFSocket和CFStream是核心基础框架的一部分。理解这两个API对使用CFNetwork至关重要。\n###CFSocket API套接字是网络通信的底层。一个套接字类似于电话插孔。它允许你连接到另一个套接字（通过本地或网络）并发送数据给该套接字。\n最常见的套接字是BSD套接字。CFSocket是BSD套接字的一个抽象概念。CFSocket提供几乎BSD套接字的所有功能，使用很少的开销将套接字集成到一个运行循环中。CFSocket并不局限于基于流套接字（例如，TCP），它可以处理任何类型的套接字。\n你可以使用CFSocketCreate 函数从头创建一个CFSocket对象，或者使用CFSocketCreateWithNative函数创建。然后你可以使用函数CFSocketCreateRunLoopSource 创建一个运行循环源，并使用函数CFRunLoopAddSource将其添加到运行循环。这样，当CFSocket对象接收到一条消息时，你的CFSocket回调函数会运行起来。\n关于更多CFSocket API的信息，可阅读CFSocket参考（CFSocket Reference）。\n###CFStream API读写流提供一种简单的方法以与设备无关的方式来与各种媒体进行数据交换。你可以为内存中、文件中或网络中（使用套接字）的数据创建流，并且你可以使用流而无需将所有的数据加载到内存中。\n流是一个字节序列串行传输的通信路径。流是单向路径，所以需要一个双向通信，一个输入（读取）流和一个输出（写入）流。除了基于文件的流，你不能寻找一个流；一旦数据流被提供或消耗，不能从流中重新取回。\nCFStream是一个API，它为两个新CFType对象：CFReadStream 和CFWriteStream提供了一个抽象。这两种类型的流遵守所有常见核心基础API约定。关于核心基础类型的更多信息，可参阅核心基础设计概念（Core Foundation Design Concepts）。\nCFStream构建在CFSocket之上，在CFHTTP和CFFTP之下。如图1-2可以看出，尽管CFStream不是CFNetwork正式的部分，但它是几乎所有CFNetwork的基础。\n\n你可以像使用UNIX文件描述符一样使用读写流。首先，你指定流类型（内存、文件或套接字）实例化流并设置选项。接下来，你可以多次打开流并进行读写。流存在时，可以访问属性获得流信息。流属性是关于流的所有信息，例如它的源或目标，但不是实际写入或读取的数据。当你不再需要流时，关闭并处理它。\n用于读写流的CFStream函数将暂停或阻塞当前进程，直到数据可以读取或写入。为了避免在流阻塞的时候试图读取或写入流，使用异步函数并安排流到一个运行循环上。当可以无阻塞的读取和写入时，将调用你的回调函数。\n此外，CFStream内置支持安全套接字层（SSL）协议。你可以设置包含流SSL信息的字典，例如属性的安全级别或自签证书。然后传递它给你的流，正如kCFStreamPropertySSLSettings属性设置流为SSL流。\n使用流（Working with Streams）章节描述了如何使用读写流。\n##CFNetwork API 概念为了理解CFNetwork框架，你需要熟悉构建它的block。CFNetwork框架分成单独的API，每个API覆盖一个特定的网络协议。这些API可以结合使用或分开使用，这取决于你的应用。API大多数编程约定是常见的，所以理解他们很重要。\n###CFFTP API使用CFFTP与FTP服务器通信会更加容易，使用CFFTP API，你可以创建FTP读取流（下载）和FTP写入流（上传）。使用FTP读写流，你可以执行如下功能：\n\n从FTP服务器下载文件\n\n上传文件到FTP服务器\n\n从FTP服务器下载目录清单\n\n在FTP服务器上创建目录。\n\n\nFTP流就像其他CFNetwork流一样工作。例如，你可以通过调用CFReadStreamCreateWithFTPURL 函数，创建一个FTP读取流。然后，你可以在任何时候调用CFReadStreamGetError 函数来检查流的状态。\n通过设置FTP流的属性，你可以为特定应用调整你的流。例如，如果流连接的服务器需要一个用户名和密码，你需要设置特定的属性这样流可以正常工作。关于FTP流不同属性的更多信息，请参阅Setting up the Streams。\n可以同步或异步使用CFFTP流。为了打开与FTP服务器的连接，调用CFReadStreamOpen函数，该服务器在FTP读取流创建的时候就已指定。为了读取流，使用CFReadStreamRead 函数并提供读取流引用CFReadStreamRef，当创建FTP读取流时该引用会返回。CFReadStreamRead 函数用FTP服务器输出填充缓存区。\n关于使用CFFTP的更多信息，参阅Working with FTP Servers\n###CFHTTP API发送和接收HTTP消息可使用CFHTTP API。正如CFFTP是FTP协议的抽象，CFHTTP是HTTP协议的抽象。\n超文本传输协议（HTTP）是一种客户端和服务器端的请求/响应协议。客户端创建一个请求消息。这个消息被序列化，序列化其实就是将消息转换成原始字节流。消息不能传递除非先被序列化。然后将请求消息发送到服务器。请求通常是请求一个文件，例如网页。服务器响应并后发送回一个字符串然后是消息。这个过程可以重复多次。\n要创建一个HTTP请求消息，你指定以下内容：\n\n请求方法，可以是超文本传输协议定义的请求方法，例如 OPTIONS, GET, HEAD, POST, PUT, DELETE, TRACE, 和CONNECT\n\nURL，例如 http://www.apple.com\n\nHTTP 版本，例如1.0版本或1.1版本。\n\n消息的标题通常根据标题名称指定，例如User-Agent，或值，例如MyUserAgent。\n\n消息主体\n\n\n消息创建后，将其序列化。序列化后，请求如下：\nGET / HTTP/1.0\\r\\nUser-Agent: UserAgent\\r\\nContent-Length: 0\\r\\n\\r\\n\n\n序列化对应的是反序列化。反序列化是将从客户端或服务器接收到的原始字节流恢复成本地的表述。CFNetwork提供获取消息类型（请求或响应），HTTP版本，URL，进入的序列化的消息的标题和主体所需要的所有功能。\n使用CFHTTP的更多例子在与HTTP服务通信（Communicating with HTTP Servers）。\n###CFHTTPAuthentication API如果你发送一个HTTP请求到身份验证服务器而没有认证信息（或不正确的认证信息），服务器将返回身份验证怀疑（俗称401或407响应）。CFHTTPAuthentication API向受到怀疑的HTTP消息提出身份验证申请。CFHTTPAuthentication 支持如下身份验证方案：\n\n基本\n\n摘要\n\nNT LAN管理（NTLM）\n\n简单的受保护的GSS-API 谈判机制（SPNEGO）\n\n\nOS X v10.4的新功能是提供持续请求欧诺个能。在OS X v10.3中，每次请求被怀疑，你必须从头开始身份验证。现在，你为每个服务器维护一组CFHTTPAuthentication 对象。当你收到一个401或407响应，你查找服务器正确的对象和凭证，并请求。CFNetwork使用存储在对象的信息尽可能高效的处理请求。\n通过持续请求，新版本的CFHTTPAuthentication 提供更好的性能。关于如何使用CFHTTPAuthentication 的更多信息，可查看与身份验证HTTP服务器进行通信（Communicating with Authenticating HTTP Servers）。\n###CFHost API你使用CFHost API获取主机信息，包括名称、地址和可达性信息。获取信息的过程被称为解析。\nCFHost 与CFStream类似：\n\n创建CFHost 对象\n\n开始解析CFHost 对象\n\n检索地址、主机名或可达性信息\n\n当你完成时，销毁CFHost 对象\n\n\n像所有的CFNetwork、CFHost都兼容IPv4 和IPv6 。使用CFHost，你可以编写代码完全透明的处理IPv4 和IPv6 。\nCFHost的集成与CFNetwork密切相关。例如，有个称为CFStreamCreatePairWithSocketToCFHost 的CFStream 函数会从CFHost对象中直接创建一个CFStream 对象。关于CFHost对象函数的更多信息，参见CFHost Reference。\n###CFNetServices API如果你想让你的应用使用Bonjour 注册一个服务或发现服务可以使用CFNetServices API。Bonjour 是苹果零配置网络（ZEROCONF）的实现，它允许你发布、发现和解析网络服务。\n为了实现Bonjour ，CFNetServices API定义三个对象类型：CFNetService、CFNetServiceBrowser和CFNetServiceMonitor。CFNetService对象表示一个单一的网络服务，例如打印机或文件服务器。它包含另一台计算机解析服务器所需的所有信息，例如名称、类型、域和域内网络服务。CFNetServiceBrowser是一个对象用于发现域或域内网络服务。CFNetServiceMonitor对象用于监控CFNetService 对象的变化，例如iChat中的状态消息。\n详细Bonjour的描述见Bonjour Overview。关于使用CFNetServices 实现Bonjour的更多信息，可查看NSNetServices and CFNetServices Programming Guide。\n###CFNetDiagnostics API连接到网络的应用依赖于一个稳定的链接。如果网络不稳定，这将导致应用程序的问题。采用CFNetDiagnostics API，用户可以自己诊断如下网络问题：\n\n物理连接失败（例如，未插入电缆）\n\n网络故障（例如，DNS或DHCP服务器不再响应）\n\n配置失败（例如，代理配置不正确）\n\n\n一旦网络故障诊断出来，CFNetDiagnostics 指导用户解决问题。如果Safari连接网站失败，你可能会看到CFNetDiagnostics 起作用。CFNetDiagnostics 助手如图1-3所示。\n\n通过CFNetDiagnostics 提供的网络故障内容，你可以调用CFNetDiagnosticDiagnoseProblemInteractively函数引导用户通过提示找到解决办法。此外，你可以使用CFNetDiagnostics 查询连接状态并为用户提供统一的错误消息。\n如何集成CFNetDiagnotics 到你的应用，可参阅使用网络诊断（ Using Network Diagnostics）。CFNetDiagnostics 是OS X v10.4中新的API。\n官方原文地址：CFNetwork Programming Guide\n","slug":"CFNetwork-编程指南之二-CFNetwork概念（CFNetwork-Concepts","date":"2016-08-10T03:56:29.000Z","categories_index":"iOS网络编程","tags_index":"CFNetwork","author_index":"William Xie"},{"id":"a230e0658132bd7e51140146dce14c4f","title":"CFNetwork 编程指南之一: 概览","content":"CFNetwork是核心服务框架中的一个框架，提供了抽象概念的网络协议库。这些抽象概念使得执行各种网络任务变得更容易，例如：\n\n使用BSD套接字\n使用SSL或TLS创建加密连接\n解析DNS主机\n使用HTTP，验证HTTP和HTTP服务器\n使用FTP服务器\n发布、解析和浏览Bonjour 服务（NSNetServices and CFNetServices Programming Guide中有讨论)。\n本文是针对想在应用中使用网络协议的开发人员。为了完全理解本文，读者应该对网络编程概念如BSD套接字、流和HTTP协议有很好的理解。此外，读者应熟悉OS X编程概念包括运行循环。关于OS X更多信息请阅读OS X技术概述。\n\n##本文组织结构本文包含以下章节：\n\nCFNetwork Concepts 描述了每个CFNetwork API及它们是如何交互的。\n\nWorking with Streams 描述了如何使用CFStream API来发送和接收网络数据。\n\nCommunicating with HTTP Servers 描述了如何发送和接收HTTP消息。\n\nCommunicating with Authenticating HTTP Servers描述了如何与安全HTTP服务器通信。\n\nWorking with FTP Servers 描述了如何从一个FTP服务器上上传和下载文件，以及如何下载目录列表。\n\nUsing Network Diagnostics 描述了如何为应用添加网络诊断。\n\n\n##另请参阅关于OS X网络API更多信息，可查看：\n\n开始使用网络\n\n请参考下面的CFNetwork参考文档：\n\nCFFTPStream Reference是CFFTPStream API的参考文档。\n\nCFHTTPMessage Reference是CFHTTPMessage API的参考文档。\n\nCFHTTPStream Reference是CFHTTPStream API的参考文档。\n\nCFHTTPAuthentication Reference是CFHTTPAuthentication API的参考文档。\n\nCFHost Reference是CFHost API的参考文档。\n\nCFNetServices Reference是CFNetServices API的参考文档。\n\nCFNetDiagnostics Reference是CFNetDiagnosticsAPI的参考文档。\n\n\n除了苹果提供的文档，下面是socket级别编程的参考书：\n\nUNIX网络编程，卷1（Stevens, Fenner and Rudoff）\n\n官方原文地址：CFNetwork Programming Guide\n","slug":"CFNetwork-编程指南之一-概览","date":"2016-08-10T03:56:09.000Z","categories_index":"iOS网络编程","tags_index":"CFNetwork","author_index":"William Xie"},{"id":"764f313455c7e408a84478db15d0ac63","title":"iOS IAP编程","content":"#协议\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n#创建内购项目\n\n\n\n\n\n\n\n#添加内购项目测试账号\n\n\n#实现代码\n首先导入StoreKit.framework库\n\n.h文件\n\n#define kSandboxVerifyURL @\"https://sandbox.itunes.apple.com/verifyReceipt\" //开发阶段沙盒验证URL\n#define kAppStoreVerifyURL @\"https://buy.itunes.apple.com/verifyReceipt\" //实际购买验证URL\n#import &lt;StoreKit/StoreKit.h>\n\n\n\n\nenum&#123;\n    IAP0p20=20,\n\tIAP1p100,\n\tIAP4p600,\n\tIAP9p1000,\n\tIAP24p6000,\n&#125;buyCoinsTag;\n\n\n\n\n\n//代理\n@interface RechargeVC : UIViewController &lt;SKPaymentTransactionObserver,SKProductsRequestDelegate >\n&#123;\nint buyType;&#125;\n\n- (void) requestProUpgradeProductData;\n\n-(void)RequestProductData;\n\n-(void)buy:(int)type;\n\n- (void)paymentQueue:(SKPaymentQueue *)queue updatedTransactions:(NSArray *)transactions;\n\n\n-(void) PurchasedTransaction: (SKPaymentTransaction *)transaction;\n\n\n- (void) completeTransaction: (SKPaymentTransaction *)transaction;\n\n\n- (void) failedTransaction: (SKPaymentTransaction *)transaction;\n\n\n-(void) paymentQueueRestoreCompletedTransactionsFinished: (SKPaymentTransaction *)transaction;\n\n\n-(void) paymentQueue:(SKPaymentQueue *) paymentQueue restoreCompletedTransactionsFailedWithError:(NSError *)error;\n\n\n\n- (void) restoreTransaction: (SKPaymentTransaction *)transaction;\n\n\n-(void)provideContent:(NSString *)product;\n\n\n-(void)recordTransaction:(NSString *)product;\n\n\n@end\n.m文件\n\n#import \"RechargeVC.h\"\n\n\n//在内购项目中创的商品单号\n#define ProductID_IAP0p20 @\"Nada.JPYF01\"//20\n#define ProductID_IAP1p100 @\"Nada.JPYF02\" //100\n#define ProductID_IAP4p600 @\"Nada.JPYF03\" //600\n#define ProductID_IAP9p1000 @\"Nada.JPYF04\" //1000\n#define ProductID_IAP24p6000 @\"Nada.JPYF05\" //6000\n\n\n\n@interface RechargeVC ()\n\n@end\n\n\n@implementation RechargeVC\n\n\n- (void)viewDidLoad &#123;\n\n    [super viewDidLoad];\n\n    [[SKPaymentQueue defaultQueue] addTransactionObserver:self];\n    [self buy:IAP0p20];\n\n&#125;\n\n\n-(void)buy:(int)type\n&#123;\n    buyType = type;\n    if ([SKPaymentQueue canMakePayments]) &#123;\n    [self RequestProductData];\n    NSLog(@\"允许程序内付费购买\");\n&#125;\nelse\n&#123;\n    NSLog(@\"不允许程序内付费购买\");\n    UIAlertView *alerView =  [[UIAlertView alloc] initWithTitle:@\"提示\"\n    message:@\"您的手机没有打开程序内付费购买\"\n    delegate:nil cancelButtonTitle:NSLocalizedString(@\"关闭\",nil) otherButtonTitles:nil];\n\n    [alerView show];\n\n\n    &#125;\n&#125;\n\n-(void)RequestProductData\n&#123;\n    NSLog(@\"---------请求对应的产品信息------------\");\n    NSArray *product = nil;\n    switch (buyType) &#123;\n        case IAP0p20:\n        product=[[NSArray alloc] initWithObjects:ProductID_IAP0p20,nil];\n        break;\n        case IAP1p100:\n        product=[[NSArray alloc] initWithObjects:ProductID_IAP1p100,nil];\n        break;\n        case IAP4p600:\n        product=[[NSArray alloc] initWithObjects:ProductID_IAP4p600,nil];\n        break;\n        case IAP9p1000:\n        product=[[NSArray alloc] initWithObjects:ProductID_IAP9p1000,nil];\n        break;\n        case IAP24p6000:\n        product=[[NSArray alloc] initWithObjects:ProductID_IAP24p6000,nil];\n        break;\n\n        default:\n        break;\n&#125;\nNSSet *nsset = [NSSet setWithArray:product];\nSKProductsRequest *request=[[SKProductsRequest alloc] initWithProductIdentifiers: nsset];\n\nrequest.delegate=self;\n[request start];\n\n&#125;\n\n//&lt;SKProductsRequestDelegate> 请求协议\n//收到的产品信息\n- (void)productsRequest:(SKProductsRequest *)request didReceiveResponse:(SKProductsResponse *)response&#123;\n\n    NSLog(@\"-----------收到产品反馈信息--------------\");\n    NSArray *myProduct = response.products;\n    NSLog(@\"产品Product ID:%@\",response.invalidProductIdentifiers);\n    NSLog(@\"产品付费数量: %d\", (int)[myProduct count]);\n    // populate UI\n    for(SKProduct *product in myProduct)&#123;\n    NSLog(@\"product info\");\n    NSLog(@\"SKProduct 描述信息%@\", [product description]);\n    NSLog(@\"产品标题 %@\" , product.localizedTitle);\n    NSLog(@\"产品描述信息: %@\" , product.localizedDescription);\n    NSLog(@\"价格: %@\" , product.price);\n    NSLog(@\"Product id: %@\" , product.productIdentifier);\n&#125;\nSKPayment *payment = nil;\nswitch (buyType) &#123;\n        case IAP0p20:\n        payment  = [SKPayment paymentWithProductIdentifier:ProductID_IAP0p20];    //支付25\n        break;\n        case IAP1p100:\n        payment  = [SKPayment paymentWithProductIdentifier:ProductID_IAP1p100];    //支付108\n        break;\n        case IAP4p600:\n        payment  = [SKPayment paymentWithProductIdentifier:ProductID_IAP4p600];    //支付618\n        break;\n        case IAP9p1000:\n        payment  = [SKPayment paymentWithProductIdentifier:ProductID_IAP9p1000];    //支付1048\n        break;\n        case IAP24p6000:\n        payment  = [SKPayment paymentWithProductIdentifier:ProductID_IAP24p6000];    //支付5898\n        break;\n        default:\n        break;\n&#125;\nNSLog(@\"---------发送购买请求------------\");\n[[SKPaymentQueue defaultQueue] addPayment:payment];\n\n&#125;\n- (void)requestProUpgradeProductData\n&#123;\n    NSLog(@\"------请求升级数据---------\");\n    NSSet *productIdentifiers = [NSSet setWithObject:@\"com.productid\"];\n    SKProductsRequest* productsRequest = [[SKProductsRequest alloc] initWithProductIdentifiers:productIdentifiers];\n    productsRequest.delegate = self;\n    [productsRequest start];\n\n&#125;\n//弹出错误信息\n- (void)request:(SKRequest *)request didFailWithError:(NSError *)error&#123;\n    NSLog(@\"-------弹出错误信息----------\");\n    UIAlertView *alerView =  [[UIAlertView alloc] initWithTitle:NSLocalizedString(@\"Alert\",NULL) message:[error localizedDescription]\n    delegate:nil cancelButtonTitle:NSLocalizedString(@\"Close\",nil) otherButtonTitles:nil];\n    [alerView show];\n\n&#125;\n\n-(void) requestDidFinish:(SKRequest *)request\n&#123;\n    NSLog(@\"----------反馈信息结束--------------\");\n\n&#125;\n\n-(void) PurchasedTransaction: (SKPaymentTransaction *)transaction&#123;\n    NSLog(@\"-----PurchasedTransaction----\");\n    NSArray *transactions =[[NSArray alloc] initWithObjects:transaction, nil];\n    [self paymentQueue:[SKPaymentQueue defaultQueue] updatedTransactions:transactions];\n&#125;\n\n//&lt;SKPaymentTransactionObserver> 千万不要忘记绑定，代码如下：\n//----监听购买结果\n//[[SKPaymentQueue defaultQueue] addTransactionObserver:self];\n\n- (void)paymentQueue:(SKPaymentQueue *)queue updatedTransactions:(NSArray *)transactions//交易结果\n&#123;\n    NSLog(@\"-----paymentQueue--------\");\n    for (SKPaymentTransaction *transaction in transactions)\n    &#123;\n        switch (transaction.transactionState)\n        &#123;\n            case SKPaymentTransactionStatePurchased:&#123;//交易完成\n            [self completeTransaction:transaction];\n            NSLog(@\"-----交易完成 --------\");\n            //购买成功后进行验证\n            [self verifyPurchaseWithPaymentTransaction];\n\n        &#125; break;\n        case SKPaymentTransactionStateFailed://交易失败\n            &#123; [self failedTransaction:transaction];\n            NSLog(@\"-----交易失败 --------\");\n            UIAlertView *alerView2 =  [[UIAlertView alloc] initWithTitle:@\"提示\"\n            message:@\"购买失败，请重新尝试购买\"\n            delegate:nil cancelButtonTitle:NSLocalizedString(@\"关闭\",nil) otherButtonTitles:nil];\n\n            [alerView2 show];\n\n        &#125;break;\n        case SKPaymentTransactionStateRestored://已经购买过该商品\n            [self restoreTransaction:transaction];\n            NSLog(@\"-----已经购买过该商品 --------\");\n            case SKPaymentTransactionStatePurchasing:      //商品添加进列表\n            NSLog(@\"-----商品添加进列表 --------\");\n            break;\n            default:\n            break;\n        &#125;\n    &#125;\n&#125;\n\n/**\n*  验证购买，避免越狱软件模拟苹果请求达到非法购买问题\n*\n*/\n-(void)verifyPurchaseWithPaymentTransaction&#123;\n    //从沙盒中获取交易凭证并且拼接成请求体数据\n    NSURL *receiptUrl=[[NSBundle mainBundle] appStoreReceiptURL];\n    NSData *receiptData=[NSData dataWithContentsOfURL:receiptUrl];\n\n    NSString *receiptString=[receiptData base64EncodedStringWithOptions:NSDataBase64EncodingEndLineWithLineFeed];//转化为base64字符串\n\n    NSString *bodyString = [NSString stringWithFormat:@\"&#123;\\\"receipt-data\\\" : \\\"%@\\\"&#125;\", receiptString];//拼接请求数据\n    NSData *bodyData = [bodyString dataUsingEncoding:NSUTF8StringEncoding];\n\n    //创建请求到苹果官方进行购买验证\n    NSURL *url=[NSURL URLWithString:kSandboxVerifyURL];\n    NSMutableURLRequest *requestM=[NSMutableURLRequest requestWithURL:url];\n    requestM.HTTPBody=bodyData;\n    requestM.HTTPMethod=@\"POST\";\n    //创建连接并发送同步请求\n    NSError *error=nil;\n    NSData *responseData=[NSURLConnection sendSynchronousRequest:requestM returningResponse:nil error:&amp;error];\n    if (error) &#123;\n        NSLog(@\"验证购买过程中发生错误，错误信息：%@\",error.localizedDescription);\n        return;\n    &#125;\n    NSDictionary *dic=[NSJSONSerialization JSONObjectWithData:responseData options:NSJSONReadingAllowFragments error:nil];\n    NSLog(@\"%@\",dic);\n    if([dic[@\"status\"] intValue]==0)&#123;\n        NSLog(@\"购买成功！\");\n        NSDictionary *dicReceipt= dic[@\"receipt\"];\n        NSDictionary *dicInApp=[dicReceipt[@\"in_app\"] firstObject];\n        NSString *productIdentifier= dicInApp[@\"product_id\"];//读取产品标识\n        //如果是消耗品则记录购买数量，非消耗品则记录是否购买过\n        NSUserDefaults *defaults=[NSUserDefaults standardUserDefaults];\n        if ([productIdentifier isEqualToString:kProductID3]) &#123;\n            int purchasedCount=[defaults integerForKey:productIdentifier];//已购买数量\n            [[NSUserDefaults standardUserDefaults] setInteger:(purchasedCount+1) forKey:productIdentifier];\n        &#125;else&#123;\n            [defaults setBool:YES forKey:productIdentifier];\n        &#125;\n        [self.tableView reloadData];\n        //在此处对购买记录进行存储，可以存储到开发商的服务器端\n    &#125;else&#123;\n        NSLog(@\"购买失败，未通过验证！\");\n    &#125;\n&#125;\n\n- (void) completeTransaction: (SKPaymentTransaction *)transaction\n\n&#123;\n    NSLog(@\"-----completeTransaction--------\");\n    // Your application should implement these two methods.\n    NSString *product = transaction.payment.productIdentifier;\n    if ([product length] > 0) &#123;\n\n    NSArray *tt = [product componentsSeparatedByString:@\".\"];\n    NSString *bookid = [tt lastObject];\n    if ([bookid length] > 0) &#123;\n    [self recordTransaction:bookid];\n    [self provideContent:bookid];\n&#125;\n&#125;\n\n    // Remove the transaction from the payment queue.\n\n    [[SKPaymentQueue defaultQueue] finishTransaction: transaction];\n\n&#125;\n\n//记录交易\n-(void)recordTransaction:(NSString *)product&#123;\n    NSLog(@\"-----记录交易--------\");\n&#125;\n\n//处理下载内容\n-(void)provideContent:(NSString *)product&#123;\n    NSLog(@\"-----下载--------\");\n&#125;\n\n- (void) failedTransaction: (SKPaymentTransaction *)transaction&#123;\n    NSLog(@\"失败\");\n    if (transaction.error.code != SKErrorPaymentCancelled)\n    &#123;\n\n    &#125;\n    [[SKPaymentQueue defaultQueue] finishTransaction: transaction];\n\n&#125;\n-(void) paymentQueueRestoreCompletedTransactionsFinished: (SKPaymentTransaction *)transaction&#123;\n\n&#125;\n\n- (void) restoreTransaction: (SKPaymentTransaction *)transaction\n&#123;\n    NSLog(@\" 交易恢复处理\");\n\n&#125;\n\n-(void) paymentQueue:(SKPaymentQueue *) paymentQueue restoreCompletedTransactionsFailedWithError:(NSError *)error&#123;\n    NSLog(@\"-------paymentQueue----\");\n&#125;\n\n#pragma mark connection delegate\n- (void)connection:(NSURLConnection *)connection didReceiveData:(NSData *)data\n&#123;\n    NSLog(@\"%@\",  [[NSString alloc] initWithData:data encoding:NSUTF8StringEncoding]);\n&#125;\n- (void)connectionDidFinishLoading:(NSURLConnection *)connection&#123;\n\n&#125;\n\n- (void)connection:(NSURLConnection *)connection didReceiveResponse:(NSURLResponse *)response&#123;\n    switch([(NSHTTPURLResponse *)response statusCode]) &#123;\n        case 200:\n        case 206:\n        break;\n        case 304:\n        break;\n        case 400:\n        break;\n        case 404:\n        break;\n        case 416:\n        break;\n        case 403:\n        break;\n        case 401:\n        case 500:\n        break;\n        default:\n        break;\n    &#125;\n&#125;\n\n- (void)connection:(NSURLConnection *)connection didFailWithError:(NSError *)error &#123;\n    NSLog(@\"test\");\n&#125;\n\n-(void)dealloc\n&#123;\n    [[SKPaymentQueue defaultQueue] removeTransactionObserver:self];//解除监听\n\n&#125;\n\n@end","slug":"iOS-IAP编程","date":"2016-08-08T15:00:04.000Z","categories_index":"iOS SDK","tags_index":"IAP","author_index":"William Xie"},{"id":"0be78fce7ff14abe5dd400a8b201abea","title":"iOS App上架流程","content":"准备条件:\n\n\n\n\n\n\n\n\n\n1.一个已付费的开发者账号（账号类型分为个人（Individual）、公司（Company）、企业（Enterprise）、高校（University）四种类型，每年资费分别为$99、$99、$299、免费。）。2.你的Xcode必须是正式版的.\n打开苹果开发者中心：https://developer.apple.com\n打开后点击：账号\n\n开发者登录账号\n点击：Certificates, Identifiers &amp; Profiles (专门生成证书，绑定Bundle Id，绑定device设备，生成描述文件的地方)\n\n点击Certificates生成证书\n\n\n\n\n\n\n\n\n\n1.选择iOS, tvOS, watchOS 2.选择All 3.点击右上角新添加证书\n\n由于是做App上传，选择生产证书（选择App Store and Ad Hoc）\n\n\n\n\n\n\n\n\n\n\n注意：一个开发者账号只能创建（1-2个开发（测试）证书，2-3个生产（发布）证书），如果你的App Store Ad Hoc 前面的按钮不能选择，则代表你的这个账号无法再创建新的生产证书了。解决方法：\n从共同使用这个账号的人电脑上生成.p12文件，导入自己的电脑。（尽量不要执行下面第2步）如果你想生成的话，把现有的删除一个（建议删除时间比较靠前的）。注意：如果删除一个证书，那么正在使用这个证书的人将不能再使用了，除非重新生成，然后利用.p12重新导入自己的电脑里！注意：如果你想删除证书，执行下面步骤，否则略过。\n然后接上上图，生产证书部分继续\n\n\n上传CSR文件去获取证书（CSR文件需要我们到本机钥匙串里去创建）\n在Launchpad的其他里面，点击钥匙串访问弹出如下界面\n\n钥匙串访问工具栏选择钥匙串访问-&gt;证书助理-&gt;从证书颁发机构请求证书…\n\n填写信息\n将CSR文件保存到MAC磁盘的某个位置（这里我选择的是桌面，进行存储）\n\n然后回到浏览器，点击choose File..\n选择创建好的：CertificateSigningRequest.certSigningRequest 文件，点击选取\n跳转到如下界面，点击 DownLoad 下载生成的证书（cer后缀的文件），然后点击Done，你创建的发布证书就会存储在帐号中。\n注意：这个证书只能下载一次。点击下载后，关闭页面后就不能再回到下载页面了。如果不需要给别的电脑使用，则直接跳过下面附加项，跳转到第五步（绑定Bundle Identifier）\n\n双击安装证书后，打开钥匙串访问，选择安装的证书右键单击\n安装的发布证书\n注意：如果没有导出，可以把这个证书删除，然后重新双击下载的证书文件安装。导出证书\n存储证书\n\n\n\n\n\n\n\n\n\n\n注意：存储的文件格式一定要是.p12\n设置密码\n可以为证书设置密码，也可以不设置密码；如果设置了密码，那么别人安装这个证书的时候就要输入密码，否则无法安装。这里就不设置密码了。\n\n保存导出的证书\n\n如果需要在其它电脑上也能发布App,那么就必须要安装这个发布证书。\n五、创建App IDs和绑定你的App的Bundle Identifier回到刚才的页面：https://developer.apple.com/account/ios/identifiers/bundle/bundleList.action\n点击App IDs,进入如下界面，点击右上角的 + 号\n\n填写App IDs和Bundle Identifier\n\n注意：\n上传App使用的Bundle Identifier(不要有-，都是英文+数字)必须是固定的，不能使用占位符。如果你的Bundle Identifier已经在网站上绑定了，如果你又修改了你工程里面这个Bundle Identifier的话，需要重新进入到开发者账号里面绑定。\n\n下面选择App中包含的服务，默认有两项，其余的根据自己项目的需求进行选择\n\n点击continue\n点击Register\n\n点击Done\n\n六、生成描述文件（描述文件的作用就是把证书和Bundle Identifier关联起来）找到Provisioning Profiles ，点击All，然后点击右上角 + 号\n\n因为是发布，所以选择下面App Store这个描述文件，点击Continue\n\n在App ID 这个选项栏里面找到你刚刚创建的：App IDs（Bundle Identifier） 类型的套装，点击Continue\n\n选择你刚创建的发布证书（或者生成p12文件的那个发布证书），根据自己电脑上的发布证书日期来选择，点击Continue\n\n在Profile Name栏里输入一个名字（这个是PP文件的名字，可随便输入，在这里我用工程名字，便于分别），然后点击Generate\n\nDownload生成的PP文件，然后点击Done，双击安装（闪一下就完事了，没其它效果）\n\n\n六、在App Store开辟空间回到Member Center，点击iTunes Connect\n\n登录开发者账号（还是之前已付费的账号）\n登录成功后，点击我的App\n\n点击左上角那个＋号，点击新建(注意：我们是iOS App开发，不要选Mac App啦）\n依次按提示填入对应信息（SKU是公司用于做统计数据之类的id，根据公司需求填写），然后点击创建\n\n注意：如果都填好以后，可能会告诉你，你的App名称已经被占用，那么不好意思，你只能改名了！（而且建议大家起名不要往比较出名的App上靠，否则审核可能会被拒绝）\n填写App其它信息\n\n填写价格和销售范围（由于我的开发者账号没有签订纳税合同，所以不能上线收费应用，所以只能暂时免费）\n\n依次把不同尺寸的App截图拉入到对应的里面需要填写不同尺寸的手机屏幕截图（也就是拿不同尺寸的模拟器运行后，挑出至少3页最多5页进行截图然后拖到响应的区里）（在模拟器Command＋S 就可以保存屏幕截图到桌面了）（注意：如果提示拖进去的图片尺寸不对，则把模拟器弄成100%然后再Command 加 S) 尺寸参照表在下面\n\n尺寸参照图\n\n填写App简介\n\n按提示依次输入\n\n错误提示：如果上传App 图标失败，提示Alpha错误的话，看下面。打开你的图标图片，勾掉这个\n\n点击分级后面的编辑，如实填写后，点击完成\n\n填写审核信息\n\n版本发布就是：（然后最下面选择自动发布的话就是如果审核通过，就自动上传到App Store供人下载）\n此时这个构建版本还没有生成，我们先把基本信息填写完毕，然后再进入Xcode中把项目打包发送到过来。\n七、在Xcode中打包工程找到你刚刚下载的发布证书（后缀为.cer）或者p12文件，和PP文件，双击，看起来没反应，但是他们已经加入到你的钥匙串中。\n在Xcode中选择iOS Device(这里不能选择模拟器)，按照下图提示操作\n\n查看版本号和构建版本号\n\n配置发布证书\n\n检查将断点、全局断点，僵尸模式等都要去掉。设置Release模式（Debug是测试的，Release是发布用的）\n选择 Xcode下 Product 下 Archive（专门用于传项目，或者打包项目）\n\n输入付费的开发者账号\n选择Upload提交\n\n如下就代表上传成功\n\n返回﻿﻿ItunesConnect网站上你自己的App信息中查看一下\n\n另一种上传应用的方式:\nApplication Loader上传应用\n点击export 导出 ipa\n选择第一个,导出成功以后\n打开Application Loader应用操作界面开始上传应用\n\n\n","slug":"iOS-App-上架流程","date":"2016-08-08T14:16:57.000Z","categories_index":"iOS SDK","tags_index":"iOS上架App Store","author_index":"William Xie"},{"id":"5ab5e9a6211c4320e462399f4a87032e","title":"SiriKit 编程","content":"","slug":"SiriKit-编程","date":"2016-08-08T13:56:18.000Z","categories_index":"iOS SDK","tags_index":"SiriKit","author_index":"William Xie"},{"id":"548f4e29db9400645bad688f092ca0b0","title":"iCloud 编程","content":"#iCloud简介\niCloud 是苹果”云战略”的重要棋子，iCloud是苹果的云服务技术。它的重点是提供数据的存储服务，苹果给每个用户免费提供5GB的云服务空间。如果不够，用户可以付费购买更多的空间。苹果公司斥资 10亿美元在北卡罗莱纳州建设新数据中心-iDataCenter，该数据中心面积为50万平方英尺，也是美国最大规模的数据中心之一。 \niCloud被整合到iOS 5和OS X 10.7. 4中，使用了这些设备的用户，只需在多个设备中设置苹果账号就可以同步、共享和备份数据。如图4-1所示，我的iphone设备上的通讯录可以同步到我的ipad和Mac Air电脑中。iCloud可以存放照片、文档等内容，以无线方式将它们推送到你的所有设备上。这都是自动在后台执行的，当打开电脑时候你会发现这些信息已经在那里了！\n使用iCLoud 服务除了能够存储特定应用数据,还可以通过编程方式存储自己应用的数据,iOS8 之后苹果支持4中类的iCloud存储:\n\niCloud 键值数据存储\niCloud 文档存储\niCloud Core Data 技术\niCloudKit 存储编程\n\n\n#iCloud 键值数据存储\niCloud键值数据存储的应用场景是这样的：我有看电子书的习惯，经常在乘坐地铁的时候使用iphone看电子书，当看到精彩内容的时候，我到站了 ，于是我关闭了这个应用。当晚上回到家时，我想用Ipad躺在沙发上看那本电子书，而且我想接着那个精彩的地方开始看。一个设计良好的电子书应用应该是：当我使用ipad打开这本书的时候，它应该马上跳到我当初退出的地方。这需要开发人员记录下退出时的页码，并保存在icloud中，然后其他设备使用该应用的时候获取这些记录信息，以便于初始化应用。\nicloud键值数据存储，以一种键值对的方式存储简单类型数据，这些数据类型包括数字、日期、数组和字典等。数据结构是pust类型。每个应用只能存储64KB的数据。它也没有像文档存储那样有一套数据冲突解决方案，新的数据会覆盖旧的数据。因此，它经常用来存储系统设置、使用偏好以及应用的状态.\niCloud键值数据存储编程比较简单,在API使用方面,NSUbiquitousKeyValueStore类它的使用类似于 NSUserDefaults,NSUserDefaults类 是苹果设计的访问本地系统的设置类.而NSUbiquitousKeyValueStore类 是用来访问iCLoud 键值数据存储数据的.NSUbiquitousKeyValueStore实例的获得也采用单例设计模式:\nvar store = NSUbiquitousKeyValueStore.defaultStore() \n\n下面是NSUbiquitousKeyValueStore类的一些取值方法：\n\nboolForKey:根据键取出布尔值。 \nlongLongForKey:根据键取出长整型值。\nobjectForKey:根据键取出id类型值。\nstringForKey:根据键取出Nsstring类型值。 \ndoubieForKey:根据键取出double类型值。\narrayForKey;根据键取出数组类型值。 \ndictionaryForKey:根据键取出字典类型值。\ndataForKey:根据键取出NSData类型值。 \n\n下面是NSUbiquitousKeyValueStore类的一些赋值方法： \n\nsetBoo]: forKey:根据键设置布尔值。 \nsetLongLong: forKey:根据键设置长整型值。\nsetObject; forKey:根据键设置id类型值。\nsetString: forKey;根据键设置Nsstring类型值。\nsetDouble: forKey:根据键设置double类型值。\nsetArray: forKey:根据键设置数组类型值。\nsetDictionary: forKey;根据键设置字典类型值。\nsetData; forKey;根据键设置NSData类型值。 \n\n力了监听iCLoud键值数据存储据的变化，可以在程序中注册通知消息 NSUbiquitousKeyValueStoreDidchangeExternallyNotification，这个通知是当一个设备更新了iCloud中的键值数据时,iCloud服务器会发出这个通知,使得其他设备都接受到这个通知.\n##iCloud键值存储实例\n开启Capabilities&gt;iCloud&gt;Key-Value storage\n出现”&lt;工程名&gt;”. entilements 这个文件是授权文件,它保存了该工程的iCloud授权的详细配置信息.\n首先注册NSUbiquitousKeyValueStoreDidchangeExternallyNotification通知,并同步数据.\n\nimport UIKit\n\n//背景音乐 存储键\nlet UbiquitousMusicKey = \"MusicKey\"\n//音效 存储键\nlet UbiquitousSoundKey = \"SoundKey\"\n\nclass ViewController: UITableViewController &#123;\n    \n    @IBOutlet weak var switchMusic: UISwitch!    \n    @IBOutlet weak var switchSound: UISwitch!\n    //单例\n    var store = NSUbiquitousKeyValueStore.defaultStore()\n    //观察着指针\n    var storeDidChangeObserver : AnyObject!\n    \n    override func viewDidLoad() &#123;\n        super.viewDidLoad()\n        \n        //初始化控件状态\n        self.switchMusic.setOn(self.store.boolForKey(UbiquitousMusicKey), animated: true)\n        self.switchSound.setOn(self.store.boolForKey(UbiquitousSoundKey), animated: true)\n        //添加观察者,改通知在iCloud服务数据变化时候触发,当客户端接受到该小心时会调用closure\n        self.storeDidChangeObserver = NSNotificationCenter.defaultCenter().addObserverForName(NSUbiquitousKeyValueStoreDidChangeExternallyNotification, object: nil, queue: nil) &#123; (note) -> Void in\n            //更新控件状态\n            self.switchMusic.setOn(self.store.boolForKey(UbiquitousMusicKey), animated: true)\n            self.switchSound.setOn(self.store.boolForKey(UbiquitousSoundKey), animated: true)\n            \n            let alert = UIAlertView(title: \"iCloud变更通知\", message: \"你的iCloud存储数据已经变更\", delegate: nil, cancelButtonTitle: \"Ok\")\n            alert.show()\n        &#125;\n        //同步到iCloud 服务器\n        self.store.synchronize()\n    &#125;\n\n    override func didReceiveMemoryWarning() &#123;\n        \n        super.didReceiveMemoryWarning()\n        NSNotificationCenter.defaultCenter().removeObserver(self.storeDidChangeObserver)\n    &#125;\n\n\n    @IBAction func setData(sender: AnyObject) &#123;\n        //存储iCloud服务器\n        self.store.setBool(self.switchMusic.on, forKey: UbiquitousMusicKey)\n        self.store.setBool(self.switchSound.on, forKey: UbiquitousSoundKey)\n        self.store.synchronize()\n    &#125;\n&#125;\n\n\n\n\n#iCloud文档存储\n文档存储 iCloud文梢存储的应用场景是这样的：我有一个备忘录应用，我在上班的路上突发奇想，于是我用iphone记录下我好想法。然后，到公司的时候使用我的Mac Air运行我的备忘录应用，我会发现应用刚才记录的方法同步到我的Mac Air中了。\niCloud文档存储可以保存用户文档，用户在应用中创建文档，并通过 fcioud守护进程同步到icloud服务。文档类型没有限制，可以是文本文件、二进制文件。存储空间与用户的可用icloud服务空间有关，在文档冲突方面icloud提供一套API帮助解决这些问题。\n##iCloud存储运行过程 \niCloud文档存储运行过程要比键值数据存储烦琐得多，将本地数据存储到iCloud服务器，大体分成3个步骤： \n步骤(1)应用(App)通过一个Ubiquity容器标识请求操作系统Ubiquity容器；步骤(2)操作系统授权应用(App)可以访问Ubiquity容器；步骤(3)通过Ubiquity容器实现与iCloud服务器传输数据。Ubiquity容器事实上也是设备上的目录，下面是运行在笔者设备某个应用的Ubiquity容器目录： \n/var/mobile/Library/Mobile % 20Documents/icloud〜cm〜51work6〜DoucmentDemo/\n而应用的沙箱目录：/var/mobile/Containers/Data/Application/5A858EE6-F4FA-4462-835F-2AB8ED1994DA/Docuinents可见沙箱目录与Ubiquity容器目录是不同的，使用的时候数据不能直接放在Ubiquity容器根目录下，而是要放在它的Documents子目录中，放入到这个目录中的数据可以自动同步到icioud服务器上，这个同步的过程开发者不用关系，由系统自动同步完成。\n##iCloud文档储存实例\n开启Capabilities&gt;iCloud&gt;iCloud Documents出现”&lt;工程名&gt;”. entilements 这个文件是授权文件,它保存了该工程的iCloud授权的详细配置信息Containers选择 User default container 使用默认的容器名 : &quot;iCloud.&lt;应用BundleID&gt;&quot;自定义文档类\nclass MyCloudDocument: UIDocument &#123;\n    //保存文档数据 ,这个文档是本文文件,所以是NSString类型\n    var contents : NSString!\n    \n    //加载数据\n    override func loadFromContents(contents: AnyObject, ofType typeName: String?) throws &#123;\n        \n        let qContents = contents as! NSData\n        \n        if qContents.length > 0 &#123;\n            self.contents = NSString(data: qContents, encoding: NSUTF8StringEncoding)\n        &#125;\n    &#125;\n    \n    //保存数据\n    override func contentsForType(typeName: String) throws -> AnyObject &#123;\n        let outError: NSError! = NSError(domain: \"Migrator\", code: 0, userInfo: nil)\n        let resContents = self.contents.dataUsingEncoding(NSUTF8StringEncoding)\n        if let value = resContents &#123;\n            return value\n        &#125;\n        throw outError\n    &#125;\n&#125;\n\n\n\n\n\n\nimport UIKit\n//当前设备名\nlet DeviceName = UIDevice.currentDevice().name\n\nclass ViewController: UIViewController &#123;\n\n    @IBOutlet weak var txtContent: UITextField!\n    //自定义文档类\n    var myCloudDocument : MyCloudDocument!\n    //查询元数据\n    var query = NSMetadataQuery()\n    \n    //请求本地Ubiquity容器，从容器中获得Document目录URL\n    lazy var ubiquitousDocumentsURL : NSURL? = &#123;\n        let fileManager = NSFileManager.defaultManager()\n        var containerURL = fileManager.URLForUbiquityContainerIdentifier(\"iCloud.com.xxx.Demo\")\n        print(\"Ubiquity容器 : \\(containerURL)\")\n        containerURL = containerURL?.URLByAppendingPathComponent(\"Documents\")\n        return containerURL\n    &#125;()\n\n    override func viewDidLoad() &#123;\n        super.viewDidLoad()\n        \n        //为查询iCloud文件的变化，注册通知\n        NSNotificationCenter.defaultCenter().addObserver(self, selector:\"updateUbiquitousDocuments:\", name: NSMetadataQueryDidFinishGatheringNotification, object: nil)\n        NSNotificationCenter.defaultCenter().addObserver(self, selector:\"updateUbiquitousDocuments:\", name: NSMetadataQueryDidUpdateNotification, object: nil)\n        \n        //注册文档状态变化通知\n        NSNotificationCenter.defaultCenter().addObserver(self, selector: \"resolveConflict:\", name: UIDocumentStateChangedNotification, object: nil)\n        \n        //查询iCloud文件的变化\n        if (self.ubiquitousDocumentsURL != nil) &#123;\n            self.query.predicate = NSPredicate(format: \"%K like 'abc.txt'\", NSMetadataItemFSNameKey)\n            self.query.searchScopes = [NSMetadataQueryUbiquitousDocumentsScope]\n        &#125;\n    &#125;\n\n    override func didReceiveMemoryWarning() &#123;\n        super.didReceiveMemoryWarning()\n        NSNotificationCenter.defaultCenter().removeObserver(self)\n    &#125;\n    \n    override func viewWillAppear(animated: Bool) &#123;\n        self.query.enableUpdates()\n        self.query.startQuery()\n    &#125;\n    \n    override func viewDidDisappear(animated: Bool) &#123;\n        self.query.disableUpdates()\n        self.query.stopQuery()\n    &#125;\n\n\n    \n    //当iCloud中的文件变化时候调用\n    func updateUbiquitousDocuments(notification : NSNotification) &#123;\n        //文件存在\n        if self.query.results.count == 1 &#123;\n            let ubiquityURL  = self.query.results.last?.valueForAttribute(NSMetadataItemURLKey) as! NSURL\n            \n            self.myCloudDocument = MyCloudDocument(fileURL: ubiquityURL)\n            self.myCloudDocument.openWithCompletionHandler(&#123; (success) -> Void in\n                if success &#123;\n                    NSLog(\"%@ : 打开iCloud文档\", DeviceName)\n                    if self.myCloudDocument.contents != nil &#123;\n                        self.txtContent.text = self.myCloudDocument.contents as String\n                    &#125; else &#123;\n                        self.txtContent.text =  \"\"\n                    &#125;\n                &#125;\n            &#125;)\n        &#125; else &#123; //文件不存在\n            NSLog(\"文件不存在\")\n            let documentiCloudPath = self.ubiquitousDocumentsURL?.URLByAppendingPathComponent(\"abc.txt\")\n            self.myCloudDocument = MyCloudDocument(fileURL: documentiCloudPath!)\n            self.myCloudDocument.contents = self.txtContent.text\n        &#125;\n        \n        if self.myCloudDocument != nil &#123;\n            //注册CloudDocument对象到文档协调者，文档状态变化才能收到通知\n            NSFileCoordinator.addFilePresenter(self.myCloudDocument)\n        &#125;\n    &#125;\n    \n    @IBAction func saveClick(sender: AnyObject) &#123;\n        self.myCloudDocument.contents = self.txtContent.text\n        self.myCloudDocument.updateChangeCount(UIDocumentChangeKind.Done)\n        self.txtContent.resignFirstResponder()\n    &#125;\n    \n    //文档冲突解决\n    func resolveConflict(notification : NSNotification) &#123;\n        if self.myCloudDocument != nil\n            &amp;&amp; self.myCloudDocument.documentState == UIDocumentState.InConflict &#123;\n            NSLog(\"冲突发生\")\n            do &#123;\n                //文档冲突解决策略\n                try NSFileVersion.removeOtherVersionsOfItemAtURL(self.myCloudDocument.fileURL)\n            &#125; catch _ &#123;\n            &#125;\n            \n            let conflictVersions = NSFileVersion.unresolvedConflictVersionsOfItemAtURL(self.myCloudDocument.fileURL)\n            for item in conflictVersions! &#123;\n                let fileVersion = item \n                NSLog(\"fileVersion.name = %@\",fileVersion.modificationDate!)\n                fileVersion.resolved = true\n            &#125;\n            self.myCloudDocument.contents = self.txtContent.text\n            self.myCloudDocument.updateChangeCount(UIDocumentChangeKind.Done)\n        &#125;\n        if self.myCloudDocument != nil &#123;\n            //从文档协调者中解除CloudDocument对象\n            NSFileCoordinator.removeFilePresenter(self.myCloudDocument)\n        &#125;\n    &#125;\n    \n&#125;\n\n\n\n\n获取iCloud文档目录\n\n\n查找Ubiquity 容器中的文档\n\n\niCloud中的文件变化处理\n\n\n保存文档\n\n\n解决文档冲突\n\n\n\n\n\n\n#iCloud Core Data 技术把一个文档保存在iCloud服务器端,文档的数据结构比较筒单,数据量也比较少，如果数据结构比较复杂，而是数据量相对大一些，再使用简单的数据结构文件就不能瞒住需求了,,可以考虑使用SQLite数据库,但是SQLite 是低级别数据持久化技术,而Core Data 是高级别的持久化技术,现在Core Data 可以借助于iCloud 技术奖户籍存到iCloud 服务中.\n##iCloud Core Data  实例配置项目iCloud Core Data 是基于iCloud 文档存储Capablities&gt;iCloud&gt;iCloud DocumentsCoreDataDAO.swift\nimport Foundation\nimport CoreData\n\nclass CoreDataDAO: NSObject &#123;\n    \n    override init() &#123;\n        super.init()\n        \n        NSNotificationCenter.defaultCenter().addObserver(self ,\n            selector: #selector(CoreDataDAO.contentDidChange(_:)),\n            name:NSPersistentStoreDidImportUbiquitousContentChangesNotification,\n            object: self.persistentStoreCoordinator)\n    &#125;\n    \n    deinit &#123;\n        NSNotificationCenter.defaultCenter().removeObserver(self)\n    &#125;\n    \n    // 返回应用程序Docment目录的NSURL类型\n    lazy var applicationDocumentsDirectory: NSURL = &#123;\n        let urls = NSFileManager.defaultManager().URLsForDirectory(.DocumentDirectory, inDomains: .UserDomainMask)\n        return urls[urls.count-1] \n    &#125;()\n    \n    // MARK: - Core Data 堆栈\n    //返回 被管理的对象上下文\n    lazy var managedObjectContext: NSManagedObjectContext? = &#123;\n        let coordinator = self.persistentStoreCoordinator\n        if coordinator == nil &#123;\n            return nil\n        &#125;\n        var managedObjectContext = NSManagedObjectContext(concurrencyType: NSManagedObjectContextConcurrencyType.MainQueueConcurrencyType)\n        managedObjectContext.persistentStoreCoordinator = coordinator\n        //合并策略\n        managedObjectContext.mergePolicy = NSMergeByPropertyObjectTrumpMergePolicy\n        return managedObjectContext\n    &#125;()\n    \n    // 返回 持久化存储协调者\n    lazy var persistentStoreCoordinator: NSPersistentStoreCoordinator? = &#123;\n        var coordinator: NSPersistentStoreCoordinator? = NSPersistentStoreCoordinator(managedObjectModel: self.managedObjectModel)\n        let url = self.applicationDocumentsDirectory.URLByAppendingPathComponent(\"CoreDataNotes.sqlite\")\n        var error: NSError? = nil\n        var failureReason = \"There was an error creating or loading the application's saved data.\"\n        \n        \n        do &#123;\n            \n          let  x = try coordinator?.addPersistentStoreWithType(NSSQLiteStoreType, configuration: nil, URL: url, options: self.iCloudPersistentStoreOptions)\n        &#125;catch &#123;\n        \n            coordinator = nil\n            // Report any error we got.\n            var dict = [String: AnyObject]()\n            \n            dict[NSLocalizedDescriptionKey] = \"Failed to initialize the application's saved data\"\n            dict[NSLocalizedFailureReasonErrorKey] = failureReason\n            dict[NSUnderlyingErrorKey] = error as NSError\n            print(\"Unresolved error \\(error), \\((error as NSError).userInfo)\")\n            abort()\n\n        &#125;\n        \n        \n        \n//        if coordinator!.addPersistentStoreWithType(NSSQLiteStoreType, configuration: nil, URL: url, options: self.iCloudPersistentStoreOptions, error: &amp;error) == nil &#123;\n//            coordinator = nil\n//            // Report any error we got.\n//            var dict = [String: AnyObject]()\n//            \n//            dict[NSLocalizedDescriptionKey] = \"Failed to initialize the application's saved data\"\n//            dict[NSLocalizedFailureReasonErrorKey] = failureReason\n//            dict[NSUnderlyingErrorKey] = error\n//            error = NSError(domain: \"51work6.com\", code: 9999, userInfo: dict)\n//            print(\"Unresolved error \\(error), \\(error!.userInfo)\")\n//            abort()\n//        &#125;\n        \n        return coordinator\n    &#125;()\n    \n    //  返回 被管理的对象模型\n    lazy var managedObjectModel: NSManagedObjectModel = &#123;\n        let modelURL = NSBundle.mainBundle().URLForResource(\"CoreDataNotes\", withExtension: \"momd\")!\n        return NSManagedObjectModel(contentsOfURL: modelURL)!\n    &#125;()\n\n    \n    //使用这些配置\n    var iCloudPersistentStoreOptions = &#123;\n        return [NSPersistentStoreUbiquitousContentNameKey: \"iCloudMyNotesApp\"]\n    &#125;()\n    \n    func contentDidChange(notification : NSNotification) &#123;\n\n        NSLog(\"%@\", notification.userInfo!.description)\n        \n        self.managedObjectContext?.mergeChangesFromContextDidSaveNotification(notification)\n        \n        //投送通知更新UI\n        dispatch_async(dispatch_get_main_queue(), &#123; () -> Void in\n            NSNotificationCenter.defaultCenter().postNotificationName(\"reloadViewNotification\", object: nil)\n        &#125;)\n    &#125;\n    \n&#125;\n\n#iCloudKit 存储编程\niOS 8 推出了CloudKit 存储,并提供了一套API用来开发.此外提供了一个iCloud服务器Web 管理工具 — iCloud Dashboard(iCloud 仪表盘)\n在介绍CloudKit编程之前，有必要介绍一下CloudKit中的一些术语：\n\n容器：是应用的iCloud容器存储空间名字，在CloudKit容器类是CKContainer类。 \n数据库：iCloud容器中存储数据的区域，被分为两个数据库—公有数据库和私有数据库，公有数据库是所有用户都能访问的数据,而私有数据库只能允许用户自己访问。在CloudKit数据库类是CKDatabase类。\n记录类型（Record Type):相当于关系数据库中的表。 \n记录(Record) :相当于数据表中记录。在CloudKit数据库类是CKRecord类。 \n数据类型：记录（Record)中的字段是有数据类型的，他们分为database和asset两种。database数据是一般的字符、数字、日期时间和地理经纬度坐标等类型；asset类型是用来存储图片、声音、视频等二进制数据。 \n\niCloud Dashboard \n为了管理iCloud服务器，苹果提供了iCloud Dashboard的Web管理工具,可以通过网站https://icloud.developer.apple.com/dashboard/访问 或者在Xcodezhong 的CloudKit Dashboard按钮访问.\n\niCloud Dashboard左边导航菜单中有一些概念:\n\nSchema(模式):数据库对象的集合,iCloud中包含Record Type(记录类型),Security Role(安全角色）和Subscription Types(订阅类型).Record Type 可以管理记录类型,就是数据表; Security Roles定义角色，提供安全访问管理；Subscription Types可以订阅数据变化的通知。 \nPublic Data: 公共数据库，其中包含User Records(用户记录),Default Zone(默认控件)和 Usage(用量)。User Records查看Users表中的数据，Users表的数据是由iCloud管理和维护的，开发人员不能删除他们；Default Zone查看公共数据库表中数据。Usage提供了数据访问的统计报告。 \nPrivate Data:私有数据库，其中Default Zone查看私有数据库表中数据。需要注意的是，如果当前账户下没有任何数据，这个导航菜单是看不到的。 \nAdmin:管理员功能，Team当需要多人协同开发一个项目时候，为他们提供一个统 一的访问权限。Deployment可以查看Schema修改日志；可以重新初始化开发环境;发布数据库。 \nEnvironment:切换Development(开发环境）和Production(产品环境）。 \n\n##CloudKit 实现实例\nCapabilities &gt; 开启iCloud &gt; CloudKit &gt; User default container \niCloud 创建数据库选择刚刚创建App对应的iCloud容器Schema&gt;Record Types ,点击+ 创建表,填写表名 和 字段\nNoteDAO.swift\nimport Foundation\nimport CloudKit\n\nclass NoteDAO &#123;\n    //定义iCloud 容器\n    var container : CKContainer!\n    //定义database属性\n    var database :  CKDatabase!\n    //单例类方法\n    class var sharedInstance: NoteDAO &#123;\n        struct Static &#123;\n            static var instance: NoteDAO?\n            static var token: dispatch_once_t = 0\n        &#125;\n        \n        dispatch_once(&amp;Static.token) &#123;\n            \n            let dao = NoteDAO()\n            dao.container = CKContainer.defaultContainer()  //获得容器对象\n            dao.database = dao.container.publicCloudDatabase // 获取共有数据库对象\n                              //container.privateCloudDatabase  // 获取私有数据库对象\n            \n            Static.instance = dao\n            \n        &#125;\n        return Static.instance!\n    &#125;\n    \n    //插入Note方法\n    func create(model: Note) -> Int &#123;\n        //创建名为\"Note\"的数据库表记录\n        let record = CKRecord(recordType: \"Note\")\n        //给记录设置 内容\n        record.setObject(model.content, forKey: \"content\")\n        //给记录设置内容\n        record.setObject(model.date, forKey: \"date\")\n        //数据库将记录对象插入到iCloud存储空间\n        self.database.saveRecord(record, completionHandler: &#123; (recd, error) -> Void in\n            if error != nil &#123;\n                print(\"error:\\(error)\" )\n            &#125; else &#123;\n                print(\"插入数据成功。\")\n            &#125;\n        &#125;)\n        \n        return 0\n    &#125;\n    \n    //删除Note方法\n    func remove(model: Note) -> Int &#123;\n        //创建一个data查询条件对象\n        let predicate = NSPredicate(format: \"date = %@\", model.date)\n        //查询对象\n        let query = CKQuery(recordType: \"Note\", predicate: predicate)\n        //查询操作\n        let queryOperation = CKQueryOperation(query: query)\n        //设置recordFetchedBlock回调属性,查询结果返回的回调,根据查询记录的个数调用多次\n        //record 就是被查询到的记录\n        queryOperation.recordFetchedBlock = &#123; record in\n            //将从iCloud存储空间删除,根据ID进行删除.\n            self.database.deleteRecordWithID(record.recordID, completionHandler: &#123; (recd, error) -> Void in\n                if error != nil &#123;\n                    print(\"error: %@\", error)\n                &#125; else &#123;\n                    print(\"删除数据成功。\")\n                &#125;\n            &#125;)\n        &#125;\n        //执行查询操作\n        self.database.addOperation(queryOperation)\n        \n        return 0\n    &#125;\n    \n    //修改Note方法\n    func modify(model: Note) -> Int &#123;\n        \n        let predicate = NSPredicate(format: \"date = %@\", model.date)\n        let query = CKQuery(recordType: \"Note\", predicate: predicate)\n        //查询操作\n        let queryOperation = CKQueryOperation(query: query)\n        //查询完以后,进行修改操作\n        queryOperation.recordFetchedBlock = &#123; record in\n            record.setObject(model.content, forKey: \"content\")\n            //修改操作\n            let modifyOperation = CKModifyRecordsOperation(recordsToSave: [record], recordIDsToDelete: nil)\n            //执行修改回调\n            modifyOperation.perRecordCompletionBlock = &#123; (recd, error) -> Void in\n                if error != nil &#123;\n                    print(\"error: %@\", error)\n                &#125; else &#123;\n                    print(\"修改数据成功。\")\n                &#125;\n            &#125;\n            //执行修改操作\n            self.database.addOperation(modifyOperation)\n        &#125;\n        //执行查询操作\n        self.database.addOperation(queryOperation)\n        \n        return 0\n    &#125;\n    \n    //查询所有数据方法\n    func findAll() &#123;\n        \n        let listData = NSMutableArray()\n        //无条件的对象\n        let predicate = NSPredicate(value: true)//不设置查询条件\n        let query = CKQuery(recordType: \"Note\", predicate: predicate)\n        query.sortDescriptors = [NSSortDescriptor(key: \"date\", ascending: true)]\n        \n        //初始化QueryOperation\n        let queryOperation = CKQueryOperation(query: query)\n        //当提取数据时候设置\n        queryOperation.recordFetchedBlock = &#123; record in\n            let content = record.objectForKey(\"content\") as! String\n            let date = record.objectForKey(\"date\") as! NSDate\n\n            let note = Note(date: date, content:content)\n            listData.addObject(note)\n        &#125;\n    \n        queryOperation.queryCompletionBlock = &#123; (cursor, error) in\n            if error != nil &#123;\n                print(\"error: %@\", error)\n            &#125; else &#123;\n                //投送通知更新UI\n                dispatch_async(dispatch_get_main_queue(), &#123; () -> Void in\n                    NSNotificationCenter.defaultCenter().postNotificationName(\"reloadViewNotification\", object: listData)\n                &#125;)\n            &#125;\n        &#125;\n        \n        //执行查询操作\n        self.database.addOperation(queryOperation)\n\n    &#125;\n    \n    //按照主键查询数据方法\n    func findById(model: Note)  &#123;\n        \n        var note : Note!\n        \n        let predicate = NSPredicate(value: true)//不设置查询条件\n        let query = CKQuery(recordType: \"Note\", predicate: predicate)\n        query.sortDescriptors = [NSSortDescriptor(key: \"date\", ascending: true)]\n        \n        //初始化QueryOperation\n        let queryOperation = CKQueryOperation(query: query)\n        //当提取数据时候设置\n        queryOperation.recordFetchedBlock = &#123; record in\n            let content = record.objectForKey(\"content\") as! String\n            let date = record.objectForKey(\"date\") as! NSDate\n            \n            note = Note(date: date, content:content)\n        &#125;\n        \n        queryOperation.queryCompletionBlock = &#123; (cursor, error) in\n            if error != nil &#123;\n                print(\"error: %@\", error)\n            &#125; else &#123;\n                //投送通知更新UI\n            &#125;\n        &#125;\n        \n        //执行查询操作\n        self.database.addOperation(queryOperation)\n\n    &#125;\n    \n&#125;\n\n","slug":"iCloud-编程","date":"2016-08-08T13:48:46.000Z","categories_index":"iOS SDK","tags_index":"iCloud","author_index":"William Xie"},{"id":"e22bf8154724897227d91eac96e617a1","title":"Handoff 编程","content":"\n#Handoff技术介绍\nHandoff是苹果“融合”主题中的重要元素之一，同时也是iOS8和OS X Yosemite中新的“Continuity”特征集的一部分。“Continuity”功能包含了能跨平台兼容的AirDrop、可在iPad和Mac上拨打iPhone电话和处理SMS信息，以及全新的更易使用的连接服务。无论你在做什么工作，无论你想要继续进行工作的设备是什么，苹果都试图通过透明、无缝的操作来实现这个想法，而不是试图通过一系列不同的设备来适应一个界面，也不是以云服务为中心。这是一个以用户为中心的大胆选择，一旦苹果正式提供这项功能，它可能将改变我们使用iPhone、iPad以及Mac的方式。所以，我们不禁要问，Handoff是如何工作的？\n\n##在设备上使用相同的iCloud账户\n为了让Handoff能够正常工作，你需要在iPhone、iPad或者Mac上使用相同的iCloud账户进行登录。这让Handoff知晓这些设备都属于同一个人——也就是你。由于iCloud账户（Apple ID）也同样被用来备份和恢复、使用iMessage和FaceTime、iCloud电子邮箱和存储在云中的文档，以及其他各种各样的功能，因此，这是一个安全、可靠的方式来确保当前用户和使用的设备不会出现错误匹配。\n使用相同的iCloud账户进行登录同样也意味着：如果你的文档存储在iCloud里面，并且可以被所有设备使用，那么Handoff并不会浪费时间和流量来推送这些文件。Handoff仅仅只会推送你当前所进行的任务。\n##Bluetooth LE 和距离\nHandoff同时也需要你的iPhone、iPad或者Mac相互之间处于一个比较近的距离。当设备进入到一定范围内并且您当前正在进行的任务支持Handoff功能，设备将通过Bluetooth LE（低功耗蓝牙4.0）来自动配对。\n使用比较近的距离可以让Handoff符合苹果的“以个人为中心”的目的。它将有效地保护你的隐私，比如正在浏览的网站、正在撰写的电子邮件或者消息，或者正在处理的文件。它保证这些任务将被推送到用你的账户登录的设备上，但是不会推送到不在你控制范围内的其他设备上面。比如说，如果你在家里工作，你不需要把你的任务推送到学校的设备上，或者你在咖啡店，你也不需要把任务推送到你的工作电脑上。\n距离能够有效的支持便利性和保护隐私，两全其美不是吗？\n##苹果应用程序和Handoff\n\n到目前为止，苹果已经宣布，Handoff将支持以下应用：\n\n\n\n\n\n\n\n\n\n1.邮件2.Safari3.Pages4.Numbers5.Keynote6.地图7.信息8.提醒事项9.日历10.通讯录\n有了它们，你就可以在Mac上编写、阅读电子邮件以及网页、编辑文档、展示表格和keynote、地图定位、输入文字、选择一个提醒事项、进行预约、或者查找地址，然后继续在你的iPhone或iPad完成这些工作，反之亦然。\n苹果尚未宣布任何多媒体应用可以支持Handoff功能，例如启动Mac上的iTunes播放列表，然后在iTunes音乐应用上继续使用；或者你的iPhone上启动游戏，然后继续在iPad上进行游戏。苹果同样也没有宣布Handoff可以让你从Apple TV中推送一部电影到iPad，如果你想换房间看电影的话。（和AirPlay功能相反，AirPlay可以将你的iPhone、iPad或者Mac上的电影推送到Apple TV上。）\nHandoff仍然处于起步阶段，它还有很多不足，但是，路要一步一步的走，来日方长。\n##第三方应用和Handoff\n苹果公司给开发者提供了相同的API（应用编程接口）来开发。开发者需要明确、谨慎地指定需要使用Handoff的任务，比如说写tweet或者阅读RSS文章，并且要保证所涉及到的应用程序都使用同样的开发者Team ID。这能够保护客户的隐私，因此我们就不必担心某个应用程序会影响推送的正常工作。\n使用Handoff功能的应用程序必须有注册开发者的签名，并通过App Store的审核，或者在Mac上予以提供。再次重申，Handoff是安全的，甚至具有一定程度的灵活性。\n##网站和Handoff\n\nHandoff不仅能在应用程序间工作，它同样也能在网站和应用程序间工作。比如说，如果你正在Mac上的Safari浏览iMore.com或者Facebook.com，然后拿着你的iPhone离开了房间，iMore或者Facebook应用会提示你是否接受Handoff——假设开发者实现了这个功能。\n开发者可以使用苹果提供的API来认证他们的网站和应用程序，并且将这两者关联起来。这个操作确认了Handoff功能使用的两个终端。\n如果要在切换到浏览器中使用，Handoff将从始发设备发送一个URL（统一资源定位符）到你想要恢复工作的设备上面。然后这个设备将打开浏览器，加载这个URL，随后你就可以在浏览器上继续浏览之前看的网页了。\n如果要在切换到本地应用中使用，网站上指定的任务将连接到关联的应用程序中的相应位置。即打开Facebook应用，加载你正在浏览的页面，随后你也可以在本地应用中继续浏览之前看的内容了。\n##持续数据流（Continuation streams）\n苹果还表示，开发者可以在两个不同设备的相同应用程序之间双向传输数据流。这使得设备间可以进行持续互动，包括读、写操作。例如，两个设备可以同时处理相同的任务，一个设备增减了文字，另一个设备也会同样进行相同的操作。\n开发者和苹果如何利用这个持续数据流功能，还有待观察……\n##图标显示位置\n\nHandoff基于操作而工作。当一个应用或者浏览器进行加载、应用在后台运行或选项卡切换时，Handoff将会标识当前你正在做的操作——要么编写电子邮件、要么浏览特定的网页、要么编辑Pages文档，等等，随后Handoff将广播这些操作。\n在一定距离内的其他设备将会识别该操作并且为其调出相应的图标。\n在iPhone或者iPad上，这个图标放置于锁屏界面的左下角，或者放置在多任务选项卡界面（双击Home键得到的页面）中主屏的左边（设备解锁后）。\n在Mac上，这个图标放置在Dock的左边，或者放置在应用程序切换栏的右边（按下Command+Tab得到的小窗口）。\n当这个图标被选中之后，Handoff会向主设备的任务发出请求。如果你正在云中使用文档，那么只有文档位置会被传输。如果你正在浏览网站，那么只有URL会被传输。否则，无论你在处理什么内容都将会被全部传输过去。一旦所有必要的数据传输完成后（可能是直接通过Wi-Fi连接），应用程序将被运行，并且任务就会在你之前进行的地方运行。\n比方说，如果你正在iPhone上编写电子邮件，并且你正在你的Mac的传输范围内，“邮件”应用将会出现在OS X的Dock左边的一个新部分中。单击之后你就可以在OS X中的“邮件”应用中继续编写你之前在iPhone上未完成的邮件了。\n如果你正在Mac上使用Keynote，然后拿起你的iPad,你就会看到在锁屏界面的左下方出现了一个Keynote的应用图标。点击它，iPad上的Keynote就会运行，之前你在Mac上的Keynote所看到的内容将会出现在你的眼前。\n##安全和隐私\n苹果尚未说明Handoff是如何确保安全和保护隐私的。不过，由于苹果近期关于安全性和隐私性的历史动作来看，我们有充分的理由对其保持乐观。例如，苹果此前曾解释过AirDrop（另一个在Continuty阵营的服务）是如何确保安全和保护隐私的，这些解释令人印象深刻：\n当用户启用AirDrop，一个2048位的RSA身份表示就会被存储在设备上。此外，基于与用户的Apple ID关联的电子邮件地址和电话号码的AirDrop身份标识哈希表将会被创建。\n当用户选择AirDrop来共享某个项目时，设备将利用BTLE(Bluetooth LE)发出AirDrop信号。其他近距离的、激活AirDrop的设备将检测这个信号，并和所有者的身份标识哈希表的精简版进行回应。\nWi-Fi信号将被直接用来进行设备间的数据交流，并不会连接互联网或者建立Wi-Fi热点。\n同样地，由于Handoff会在锁屏上显示，如何使用密码、Touch ID继续操作，以及是否允许Handoff在锁屏上显示，都可以在设置选项中进行处理。（出于安全方面考虑，BT LE和距离限制允许支持Handoff设备可以被确定为信任设备。）\nHandoff实现了一个不同于微软的“Windows无处不在”以及谷歌的“一切尽在云中”的设备通信方法。借助Handoff，没有任何隐私会被保存在服务器当中。苹果保持了Mac和Mac通信，iPhone和iPad通信的独立性。他们仅仅只是在形式上整合在了一起，但是无论你走到哪里，你设备间的任务都将透明、无缝地进行连接。\n#Handoff编程\nHandoff能够让用户在一台设备上开始某个任务,然后到另一个设备上矩形完成某个任务.Handoff本意就是手递手,即将一个任务从一个设备传递给另一个设备.Handoff是基于多点连接技术,它能够自动发现其他处于广播状态的设备,并进行通信.通过 Handoff，您可以在一台设备上开始撰写文稿、电子邮件或信息，然后转到另一设备上继续进行。 \n\n##使用Handoff的要求:\n\n\n\n\n\n\n\n\n\n1.2012年后的MacBook Air,MacBook Pro,iMac,Mac mini;2013年之后Mac Pro等,必须运行 Mac OS X 10以及更高的版本.2.iOS设备必须是iPhone5以及更高,iPad Air等,系统必须是iOS8及更高版本.3.传递过程是采用蓝牙,因此需要设备开启蓝牙,并且设备之间的距离应在10米内.这些设计都是在iCloud设置面板中登陆相同的Apple ID. Handoff所在的应用在数字签名时候,必须使用相同的团队标示(Team ID)\n##设置Handoff\n\n\n\n\n\n\n\n\n\n1.Mac OS X 的设置方法是 打开’系统偏好设置’&gt;’通用’设置界面 &gt; ‘允许在这台Mac 和 iCloud设计之间使用Handoff’2.iOS 设备开启Handoff,则打开设置应用的’通用’&gt;’Handoff于建议的应用程序’\n使用Handoff\n\n\n\n\n\n\n\n\n\n1.在其中一台设备上，打开兼容应用，如“邮件”或 Pages。2.使用该应用开始一项任务，如撰写电子邮件或文稿。3.然后，您可以切换到其他 iOS 或 Mac 上。\n如果切换到 Mac，您可以按 Command-Tab 从离开的位置继续，或者您可以点按 Dock 中的应用图标：\n#Handoff工作原理\n这种在设备之间传递的任务被称为”用户活动”(User Activity),用户活动可以在设备之间通过Handoff技术传递.用户在原始设备上打开Safari浏览器,然后创建用户活动对象,用户活动对象可以使用userInfo属性传递数据或流, userInfo中的数据包括: NSArray,NSData,NSDate,NSDictionary,NSNull,NSNumber,NSSet,NSString,NSURL;userInfo中的流可以传递文件.原始设备会关闭用户活动,其他附件的设备(与原始设备采用相同的iCloud账号登陆)可以接受用户活动.\nHandoff APIHandoff 没有一个独立的框架,设计的类只有一个NSUserActivity, 就是 用户活动类.\nNSUserActivity类\npublic class NSUserActivity : NSObject &#123;\n    \n    /* Initializes and returns a newly created NSUserActivity with the given activityType. A user activity may be continued only in an application that (1) has the same developer Team ID as the activity's source application and (2) supports the activity's type. Supported activity types are specified in the application's Info.plist under the NSUserActivityTypes key. When receiving a user activity for continuation, the system locates the appropriate application to launch by finding applications with the target Team ID, then filtering on the incoming activity's type identifier.\n    */\n    public init(activityType: String)\n    \n    /* Initializes and returns a newly created NSUserActivity with the first activityType from the NSUserActivityTypes key in the application’s Info.plist.\n    */\n    public init()\n    \n    /* The activityType the user activity was created with.\n    */\n    public var activityType: String &#123; get &#125;\n    \n    /* An optional, user-visible title for this activity, such as a document name or web page title.\n    */\n    public var title: String?\n    \n    /* The userInfo dictionary contains application-specific state needed to continue an activity on another device. Each key and value must be of the following types: NSArray, NSData, NSDate, NSDictionary, NSNull, NSNumber, NSSet, NSString, NSURL, or NSUUID. File scheme URLs which refer to iCloud documents may be translated to valid file URLs on a receiving device.\n    */\n    public var userInfo: [NSObject : AnyObject]?\n    \n    /* Adds to the userInfo dictionary the entries from otherDictionary.  The keys and values must be of the types allowed in the userInfo \n    */\n    public func addUserInfoEntriesFromDictionary(otherDictionary: [NSObject : AnyObject])\n    \n    /* The keys from the userInfo property which represent the minimal information about this user activity that should be stored for later restoration */\n    @available(iOS 9.0, *)\n    public var requiredUserInfoKeys: Set&lt;String>\n    \n    /* If set to YES, then the delegate for this user activity will receive a userActivityWillSave: callback before being sent for continuation on another device. \n    */\n    public var needsSave: Bool\n    \n    /* When no suitable application is installed on a resuming device and the webPageURL is set, the user activity will instead be continued in a web browser by loading this resource.\n    */\n    @NSCopying public var webpageURL: NSURL?\n    \n    /* If non-nil, then an absolute date after which this activity is no longer eligible to be indexed or handed off. */\n    @available(iOS 9.0, *)\n    @NSCopying public var expirationDate: NSDate\n    \n    /* A set of NSString* keywords, representing words or phrases in the current user's language that might help the user to find this activity in the application history. */\n    @available(iOS 9.0, *)\n    public var keywords: Set&lt;String>\n    \n    /* When used for continuation, the user activity can allow the continuing side to connect back for more information using streams. This value is set to NO by default. It can be dynamically set to YES to selectively support continuation streams based on the state of the user activity.\n    */\n    public var supportsContinuationStreams: Bool\n    \n    /* The user activity delegate is informed when the activity is being saved or continued (see NSUserActivityDelegate, below)\n    */\n    weak public var delegate: NSUserActivityDelegate?\n    \n    /* Marks the receiver as the activity currently in use by the user, for example, the activity associated with the active window. A newly created activity is eligible for continuation on another device after the first time it becomes current.\n    */\n    public func becomeCurrent()\n    \n    /* If this activity is the current activity, it should stop being so and set the current activity to nothing. */\n    @available(iOS 9.0, *)\n    public func resignCurrent()\n    \n    /* Invalidate an activity when it's no longer eligible for continuation, for example, when the window associated with an activity is closed. An invalid activity cannot become current.\n    */\n    public func invalidate()\n    \n    /* When an app is launched for a continuation event it can request streams back to the originating side. Streams can only be successfully retrieved from the NSUserActivity in the NS/UIApplication delegate that is called for a continuation event. This functionality is optional and is not expected to be needed in most continuation cases. The streams returned in the completion handler will be in an unopened state. The streams should be opened immediately to start requesting information from the other side.\n    */\n    public func getContinuationStreamsWithCompletionHandler(completionHandler: (NSInputStream?, NSOutputStream?, NSError?) -> Void)\n    \n    /* Set to YES if this user activity should be eligible to be handed off to another device */\n    @available(iOS 9.0, *)\n    public var eligibleForHandoff: Bool\n    \n    /* Set to YES if this user activity should be indexed by App History */\n    @available(iOS 9.0, *)\n    public var eligibleForSearch: Bool\n    \n    /* Set to YES if this user activity should be eligible for indexing for any user of this application, on any device, or NO if the activity contains private or sensitive information or which would not be useful to other users if indexed.  \n    The activity must also have requiredUserActivityKeys or a webpageURL */\n    @available(iOS 9.0, *)\n    public var eligibleForPublicIndexing: Bool\n&#125;\n\n\nNSUserActivityTypeBrowsingWeb 字符串\n/* The activity type used when continuing from a web browsing session to either a web browser or a native app.\n Only activities of this type can be continued from a web browser to a native app.\n*/\n@available(iOS 8.0, *)\npublic let NSUserActivityTypeBrowsingWeb: String\n\n\n\nNSUserActivityDelegate协议\n/* The user activity delegate is responsible for updating the state of an activity and is also notified when an activity has been continued on another device.\n*/\n\n@available(iOS 8.0, *)\npublic protocol NSUserActivityDelegate : NSObjectProtocol &#123;\n    \n    /* The user activity will be saved (to be continued or persisted).\n     The receiver should update the activity with current activity state.\n    */\n    optional public func userActivityWillSave(userActivity: NSUserActivity)\n    \n    /* The user activity was continued on another device.\n    */\n    optional public func userActivityWasContinued(userActivity: NSUserActivity)\n    \n    /* If supportsContinuationStreams is set to YES the continuing side can request streams back to this user activity.\n    This delegate callback will be received with the incoming streams from the other side. The streams will be in an unopened state. The streams should be opened immediately to start receiving requests from the continuing side.\n    */\n    optional public func userActivity(userActivity: NSUserActivity?, didReceiveInputStream inputStream: NSInputStream, outputStream: NSOutputStream)\n&#125;\n\n\n\n##Handoff编程的一般流程:\n原始设备开始1.实例化NSUserActivity对象2.调用NSUserActivity的becomeCurrent方法3.用户活动状态改变4.NSUserActivityDelegate的userActivityWillSave:方法被调用\n其他设备5.实例化 NSUserActivity对象6.调用NSUserActivity的becomeCurrent()方法成为当前活动者7.UIApplicationDelegate的application:continueUserAcitivity:restorationHandler:方法被调用8.UIResponder的restoreUserActivityState:方法被调用\n结束\n上述流程可以分为 两个阶段: 原始设备创建用户活动和用户活动继续传递到其他设备.\n第一个阶段原始设备实例化NSUserActivity 对象创建用户活动,并调用NSUserActivity的becomeCurrent()方法称为当前活动者.\n第二阶段中用户可用改变活动状态,这时NSUserActivityDelegate的userActivytyWillSave:方法调用,然后活动调用数据继续传递到其他设备,其他设备也需要实例化NSUserActivity对象创建,调用becomeCurrent方法称为当前活动者,接着UIApplicationDelegate的application:continueUserActivity:restorationHandler: 方法被调用,这个方法中需要返回,并将需要恢复状态的UIResponder对象集合传递给restorationHandler闭包.根据restorationHandler闭包中的UIResponder对象,调用UIResponder对象的restoreUserActivityState:方法.\n编程实例\nAppDelegate.swift\n\nfunc application(application: UIApplication, continueUserActivity userActivity: NSUserActivity, restorationHandler: ([AnyObject]?) -> Void) -> Bool &#123;\n     \n     \n     if let rootViewController = self.window?.rootViewController as? UINavigationController &#123;\n         \n         if let viewController = rootViewController.topViewController as? ViewController &#123;\n             restorationHandler([viewController])\n         \n             return true\n         &#125;\n     &#125;\n     return false\n     \n &#125;\n\n\n\nInfo.plist 文件中添加 NSUserActivityTypes 数组item0内容填入 cn.williamxie.HandoffDemo\nViewController.swift\nlet controllerActivityType = \"cn.williamxie.HandoffDemo\"\nlet powerSwitchKey = \"powerSwitch_key\"\nlet brightnessSilderKey = \"brightnessSilder_key\"\n\nclass ViewController: UIViewController, NSUserActivityDelegate &#123;\n\n    var activity : NSUserActivity?\n    \n    @IBOutlet weak var powerSwitch: UISwitch!\n    \n    @IBOutlet weak var brightnessSilder: UISlider!\n    \n    @IBOutlet weak var brightnessValue: UILabel!\n    \n    override func viewDidLoad() &#123;\n        super.viewDidLoad()\n    &#125;\n\n    override func viewWillAppear(animated: Bool) &#123;\n        \n        super.viewWillAppear(animated)\n        \n        //实例化activity对象\n        self.activity = NSUserActivity(activityType: controllerActivityType)\n        self.activity!.userInfo = getActivityInfoData()\n        self.activity!.title = \"灯泡控制器\"\n        self.activity!.delegate = self\n        \n        self.activity!.becomeCurrent()\n        \n    &#125;\n    \n    override func viewWillDisappear(animated: Bool) &#123;\n        \n        super.viewWillDisappear(animated)\n        \n        self.activity!.invalidate()\n        self.activity!.delegate = nil\n    &#125;\n    \n    override func didReceiveMemoryWarning() &#123;\n        super.didReceiveMemoryWarning()\n    &#125;\n    \n    //准备activity中的数据\n    func getActivityInfoData() -> [String : AnyObject] &#123;\n        \n        var activityInfo = [String : AnyObject]()\n        activityInfo[powerSwitchKey] = powerSwitch.on\n        activityInfo[brightnessSilderKey] = brightnessSilder.value\n        \n        return activityInfo\n    &#125;\n\n    @IBAction func switchValueChanged(sender: AnyObject) &#123;        \n        self.activity!.needsSave = true\n    &#125;\n    \n    @IBAction func silderValueChanged(sender: AnyObject) &#123;\n        let newValue = self.brightnessSilder.value\n        self.brightnessValue.text = String(format: \"%0.0f\", newValue)\n        self.activity!.needsSave = true\n    &#125;\n    \n    //MARK: --实现NSUserActivityDelegate协议方法\n    func userActivityWillSave(userActivity: NSUserActivity) &#123;\n        userActivity.userInfo = getActivityInfoData()\n    &#125;\n    \n    override func restoreUserActivityState(activity: NSUserActivity) &#123;\n        if activity.activityType == controllerActivityType &#123;\n            \n            let info = activity.userInfo as! [String : AnyObject]\n            let switchValue = info[powerSwitchKey] as! Bool\n            let silderValue = info[brightnessSilderKey] as! Float\n            \n            self.powerSwitch.setOn(switchValue, animated: true)\n            self.brightnessSilder.value = silderValue\n            self.brightnessValue.text = String(format: \"%0.0f\", silderValue)\n        &#125;\n    &#125;\n&#125;\n\n\n\n\n\n","slug":"Handoff-编程","date":"2016-08-08T13:41:38.000Z","categories_index":"iOS SDK","tags_index":"Handoff","author_index":"William Xie"},{"id":"5492d10686659c2d6f970cda1bae8c29","title":"iOS逆向工程","content":"","slug":"iOS逆向工程","date":"2016-08-08T13:20:21.000Z","categories_index":"iOS逆向工程","tags_index":"","author_index":"William Xie"},{"id":"bd7e8525cbfb254b21794e3600c919c6","title":"Xcode中执行脚本的方法","content":"#第一种方法 Xcode中直接编写脚步并运行\n##1.选中一个target &gt; Build Phase &gt; +\n\n##2.选择New Run Script Phase##3.得到下图##4.Run Script 详解\n这里我们可以选择新建一个shell script 或者 将一个编写好的脚步拖进器\nshell脚本代码如下:\n echo &quot;Dump of variables&quot;\n echo &quot;PRODUCT_NAME=$&#123;PRODUCT_NAME&#125;&quot;\n echo &quot;The action being performed on the current target,such as build or clean.&quot;\n echo &quot;ACTION=$&#123;ACTION&#125;&quot;\n echo &quot;The variations-debug,profile or normal-that Xcode is creating for the product being built.&quot;\n echo &quot;BUILD_VARIANTS=$&#123;BUILD_VARIANTS&#125;&quot;\n echo &quot;The name of the project containing the tartget that is being build.&quot;\n echo &quot;PROJECT_NAME=$PROJECT_NAME&quot;\n echo &quot;The name of the project being built, without any extension or suffix.&quot;\n echo &quot;PROJECT_NAME=$PROJECT_NAME&quot;\n echo &quot;The name of the target being built.&quot;\n echo &quot;TARGET_NAME=$TARGET_NAME&quot;\n echo &quot;The location of the target being built.&quot;\n echo &quot;TARGET_BUILD_DIR=$TARGET_BUILD_DIR&quot;\n echo &quot;The directory that holds the products created by building the tartgets in a project.&quot;\n echo &quot;BUILD_PRODUCTS_DIR=$TARGET_BUILD_DIR&quot;\n echo &quot;The directory that holds intermediate files for a specific target.&quot;\n echo &quot;TEMP_FILES_DIR=$TARGET_BUILD_DIR&quot;\n echo &quot;The directory that holds intermediate source files generated by the Compile Source build phase&quot;\n echo &quot;DERIVED_FILES_DIR=$TARGET_BUILD_DIR&quot;\n echo &quot;The location of the installed product.&quot;\n echo &quot;INSTALL_DIR=$TARGET_BUILD_DIR&quot;\n\n\n##5.项目编译,脚本正常编译,结果如下\n\n#第二种方法 将写好的脚本在Xcode中执行\n##1.创建External Build System创建编译系统作为目标APP的执行依赖.选择Cross-platform &gt; Other &gt; External Build System\n##2.取名为External##3.创建shell脚本,取名Script.sh,内容如下:\n#!/bin/sh   \necho &quot;External Build Tool&quot;  \necho &quot;Yes, it worked!&quot; &gt;&gt; ./DidItWork.txt   \n\n为了确保可以正常的执行,在运行之前添加可执行属性.\nchmod +x  Script.sh\n##4.配置编译工具系统Targets &gt; External &gt;Info &gt; External Build Tool ConfigurationBuild Tool填写 ./Script.shDirectory 填写脚步所在目录\n\n##5.给目标App添加运行依赖Targets &gt; Demo &gt;Build Phase &gt; Target Dependencies##6.运行编译结果如下:\n\n如图所示, External Build System 作为目标App的依赖, 在目标App 编译之前进行编译,可以用于一些文件的配置.\n#第三种方法 将以上两种方法结合使用\n结合第一种方法和第二种方法把写好的脚本拖进Run Script框中执行即可.\n","slug":"Xcode中执行脚本的方法","date":"2016-08-08T02:33:17.000Z","categories_index":"","tags_index":"","author_index":"William Xie"},{"id":"0253063df22cd83edff3aeaf17dd4742","title":"Google Cardboard for iOS 虚拟现实开发","content":"原文链接\nThis document describes how to use the Google VR SDK for iOS (iOS SDK) to create your own Virtual Reality (VR) experiences.\nYou can use a VR viewer, such as Google Cardboard, to turn your smartphone into a VR platform. Your phone can display 3D scenes with binocular rendering, track and react to head movements, and interact with apps by activating the trigger input.\nNote: The various manufacturers of smartphone VR viewers use different methods to simulate when a user taps the screen of their phone to interact with an app. These can include pulling a magnet and pressing a button. On some viewer models, the user actually does touch the screen of their phone so there is no simulation required. To keep things simple, on this page we’ll refer to these methods collectively as “activating the trigger input.”The iOS SDK contains tools for spatial audio that go far beyond simple left side/right side audio cues to offer 360 degrees of sound. You can also control the tonal quality of the sound—for example, you can make a conversation in a small spaceship sound drastically different than one in a large, underground (and still virtual) cave.\nThe demo app used in this tutorial, “Treasure Hunt,” is a basic game, but it demonstrates the core features of the Google VR SDK. In the game, users look around a virtual world to find and collect objects. It demonstrates some basic features, such as lighting, movement in space, and coloring. It shows how to set up the trigger input, detect if the user is looking at something, set up spatial audio, and render images by providing a different view for each eye.\n\n这个 Cardboard SDK 可以让你很方便的控制音频的空间感（例如左右声道），也可以控制响度，所以你可以让一段对话在一个小飞船中或者一个很大的地下洞穴中表现得很不一样。\n在这个示例程序中我们完成了一个寻宝游戏，他演示了 Cardboard 的核心功能。玩家将会在一个虚拟的世界中寻找宝物。你将会学习如何使用光照、空间运动和着色等基本功能如果玩家看见了他要找的东西，将会触发空间音效和视差效果。\n#基本要求\n为了能够运行这个示例程序，你至少需要满足以下条件：\n\nXcode 7.1 或更高版本\nCocoaPods,访问 CocoaPods 来安装。\n一部运行 iOS 7.0 或更高版本的 iPhone。\n\n#下载并构建 app\n1.首先将项目 clone 到本地：\ngit clone https://github.com/googlesamples/cardboard-ios.git\n\n2.在你的命令行中，进入到 CardboardSamples 里的 TreasureHunt 文件夹然后执行：\npod update\n\n这将会安装项目所有的依赖。\n因为你懂的原因出现下面的情况:\n但是我又有强迫症,所以使用这么的方式让Terminal也能在翻墙(本人使用Surge Mac 版)下载速度:结果如下:3.现在你应该能看见 TreasureHunt.xcworkspace 文件了，用 Xcode 运行起来应该像这个样子：在 Xcode 上运行 TreasureHunt\n#开始游戏\n现在戴上你的耳机，来在这个虚拟现实的空间里搜寻宝物吧！\n##寻找宝物\n1.四处移动你的方向，直到宝物进入你的视野：宝物已经在视野中显示了\n2.直视这个宝物，他将会变成橘色：直视宝物的时候它变成橘色了\n\n3.激活开关就可以收集宝物（根据 Cradboard 的不同，可能是拨动物理按钮也可能是触碰屏幕之类的)\n#代码概览\n这个寻宝游戏（TreasureHunt）通过 OpenGL 来为你的双眼呈现不同的讯息，他们是这样工作的：\n\n一个 UIViewController 拥有一个 GCSCardboardView 对象\n一个渲染器遵循 GCSCardboardViewDelegate 协议\n通过 CADisplayLink 对象添加一个渲染循环\n捕获输入\n\n##让UIViewController拥有一个 GCSCardboardView\n这个寻宝游戏定义了一个 UIViewController，也就是 TreasureHuntViewController，他拥有一个 GCSCardboardView，并且有一个遵循 GCSCardboardViewDelegate 协议的 TreasureHuntRenderer 的实例来成为 GCSCardboardView 的代理。 此外，这个应用有一个渲染循环，TreasureHuntRenderLoop 这个类，他有一个 -render 方法来GCSCardboardView。\n- (void)loadView &#123;\n  _treasureHuntRenderer &#x3D; [[TreasureHuntRenderer alloc] init];\n  _treasureHuntRenderer.delegate &#x3D; self;\n\n  _cardboardView &#x3D; [[GVRCardboardView alloc] initWithFrame:CGRectZero];\n  _cardboardView.delegate &#x3D; _treasureHuntRenderer;\n  ...\n  _cardboardView.vrModeEnabled &#x3D; YES;\n  ...\n  self.view &#x3D; _cardboardView;\n&#125;\n\n##定义一个遵循GCSCardboardViewDelegate协议的渲染器\nGCSCardboardView 将会用于向你展示内容，他通过 GCSCardboardViewDelegate 协议来完成这些工作，所以 TreasureHuntRenderer 将会遵循 GCSCardboardViewDelegate协议：\n#import &quot;GVRCardboardView.h&quot;\n\n&#x2F;** TreasureHunt renderer. *&#x2F;\n@interface TreasureHuntRenderer : NSObject&lt;GVRCardboardViewDelegate&gt;\n\n@end\n\n##声明 GCSCardboardViewDelegate 协议中的内容\n为了在 GCSCardboardView 显示内容，TreasureHuntRenderer 需要遵循 GCSCardboardViewDelegate 的这些协议：\n@protocol GCSCardboardViewDelegate&lt;NSObject&gt;\n \n- (void)cardboardView:(GCSCardboardView *)cardboardView\n         didFireEvent:(GCSUserEvent)event;\n \n- (void)cardboardView:(GCSCardboardView *)cardboardView\n     willStartDrawing:(GCSHeadTransform *)headTransform;\n \n- (void)cardboardView:(GCSCardboardView *)cardboardView\n     prepareDrawFrame:(GCSHeadTransform *)headTransform;\n \n- (void)cardboardView:(GCSCardboardView *)cardboardView\n              drawEye:(GCSEye)eye\n    withHeadTransform:(GCSHeadTransform *)headTransform;\n \n- (void)cardboardView:(GCSCardboardView *)cardboardView\n   shouldPauseDrawing:(BOOL)pause;\n \n@end\n\n接下来我们将实现 willStartDrawing，prepareDrawFrame，和 drawEye 方法。\n##实现 willStartDrawing 方法\n要执行 GL(Graphics Library) 一次性初始化，实现 -cardboardView:willStartDrawing: 方法，并在其中来加载着色器初始化集合场景并添加到 GL 的参数中，并且还初始化了一个 GCSCardboardAudioEngine 实例：\n- (void)cardboardView:(GVRCardboardView *)cardboardView\n     willStartDrawing:(GVRHeadTransform *)headTransform &#123;\n  &#x2F;&#x2F; Load shaders and bind GL attributes.\n  &#x2F;&#x2F; Load mesh and model geometry.\n  &#x2F;&#x2F; Initialize GVRCardboardAudio engine.\n  _cardboard_audio_engine &#x3D;\n  [[GVRCardboardAudioEngine alloc]initWithRenderingMode:\n      kRenderingModeBinauralHighQuality];\n  [_cardboard_audio_engine preloadSoundFile:kSampleFilename];\n  [_cardboard_audio_engine start];\n  ...\n  [self spawnCube];\n&#125;\n\n##实现 prepareDrawFrame 方法\n通过实现 -cardboardView:prepareDrawFrame: 方法，将可以决定将要呈现在人眼前内容的逻辑。任何对于特定帧内容的操作应该在这里实现，在这里更新模型并清除 GL 绘制状态等。应用将会计算头部的方向并更新音频引擎。\n- (void)cardboardView:(GVRCardboardView *)cardboardView\n     willStartDrawing:(GVRHeadTransform *)headTransform &#123;\n  &#x2F;&#x2F; Load shaders and bind GL attributes.\n  &#x2F;&#x2F; Load mesh and model geometry.\n  &#x2F;&#x2F; Initialize GVRCardboardAudio engine.\n  _cardboard_audio_engine &#x3D;\n  [[GVRCardboardAudioEngine alloc]initWithRenderingMode:\n      kRenderingModeBinauralHighQuality];\n  [_cardboard_audio_engine preloadSoundFile:kSampleFilename];\n  [_cardboard_audio_engine start];\n  ...\n  [self spawnCube];\n&#125;\n\n\n##实现 drawEye 方法\n这里将会是整个渲染代码的核心，就像你建立一个常规的 OpenGL ES 应用一样。下面这段代码将为你展示如何在 -drawEye 方法中为 每个 眼球呈现场景的变换和透视效果。注意，这个方法会为每一个眼球调用，如果 GCSCardboardView 没有启用 VR 模式，那么眼球将会被设置为最中间。这种单眼渲染模式也是有用的，他能在非 VR 视图下也展现 3D 场景。\n\n- (void)cardboardView:(GVRCardboardView *)cardboardView\n              drawEye:(GVREye)eye\n    withHeadTransform:(GVRHeadTransform *)headTransform &#123;\n  &#x2F;&#x2F; Set the viewport.\n  CGRect viewport &#x3D; [headTransform viewportForEye:eye];\n  glViewport(viewport.origin.x, viewport.origin.y, viewport.size.width,\n      viewport.size.height);\n  glScissor(viewport.origin.x, viewport.origin.y, viewport.size.width,\n      viewport.size.height);\n\n  &#x2F;&#x2F; Get the head matrix.\n  const GLKMatrix4 head_from_start_matrix &#x3D;\n      [headTransform headPoseInStartSpace];\n\n  &#x2F;&#x2F; Get this eye&#39;s matrices.\n  GLKMatrix4 projection_matrix &#x3D; [headTransform\n      projectionMatrixForEye:eye near:0.1f far:100.0f];\n  GLKMatrix4 eye_from_head_matrix &#x3D;\n      headTransform eyeFromHeadMatrix:eye];\n\n  &#x2F;&#x2F; Compute the model view projection matrix.\n  GLKMatrix4 model_view_projection_matrix &#x3D;\n      GLKMatrix4Multiply(projection_matrix,\n      GLKMatrix4Multiply(eye_from_head_matrix, head_from_start_matrix));\n\n  &#x2F;&#x2F; Render from this eye.\n  [self renderWithModelViewProjectionMatrix:model_view_projection_matrix.m];\n&#125;\n\n返回这个方法的调用以后，GCSCardboardView 会将它渲染到屏幕上。\n##用 CADisplayLink 添加渲染循环\n为了渲染内容，我们需要CADisplayLink 来驱动一个渲染循环。 在这个寻宝游戏中，我们用到了 TreasureHuntRenderLoop 来实现这个渲染循环。 这需要调用 GCSCardboardView 中的 -render 方法。 我们在 TreasureHuntViewController 的 - viewWillAppear: and -viewDidDisappear: 方法中生成它并且在 -viewDidDisappear: 方法中销毁它。\n- (void)viewWillAppear:(BOOL)animated &#123;\n  [super viewWillAppear:animated];\n\n  _renderLoop &#x3D; [[TreasureHuntRenderLoop alloc]\n   initWithRenderTarget:_cardboardView selector:@selector(render)];\n&#125;\n\n- (void)viewDidDisappear:(BOOL)animated &#123;\n  [super viewDidDisappear:animated];\n\n  [_renderLoop invalidate];\n  _renderLoop &#x3D; nil;\n&#125;\n##捕获输入\nCradboard SDK 可以接受到输入的事件（通常是拨动 Cardboard 上的按钮），你要在用户触发这个按钮的时候做一些事情，只需要实现 - cardboardView:didFireEvent 代理方法。\n- (void)cardboardView:(GVRCardboardView *)cardboardView\n         didFireEvent:(GVRUserEvent)event &#123;\n  switch (event) &#123;\n    case kGVRUserEventBackButton:\n    &#x2F;&#x2F; If the view controller is in a navigation stack or\n    &#x2F;&#x2F; over another view controller, pop or dismiss the\n    &#x2F;&#x2F; view controller here.\n    break;\n    case kGVRUserEventTrigger:\n     NSLog(@&quot;User performed trigger action&quot;);\n     &#x2F;&#x2F; Check whether the object is found.\n     if (_is_cube_focused) &#123;\n       &#x2F;&#x2F; Vibrate the device on success.\n       AudioServicesPlaySystemSound(kSystemSoundID_Vibrate);\n       &#x2F;&#x2F; Generate the next cube.\n       [self spawnCube];\n     &#125;\n     break;\n  &#125;\n&#125;\n","slug":"Google-Cardboard-for-iOS-虚拟现实开发","date":"2016-07-08T09:07:56.000Z","categories_index":"Virtual Reality","tags_index":"Cardboard for iOS","author_index":"William Xie"},{"id":"6bb8fd6a1413621db1c9e68194cf759a","title":"Swift 神经网络","content":"","slug":"Swift-神经网络","date":"2016-05-24T13:29:26.000Z","categories_index":"Machine Learning","tags_index":"Deeep Learning","author_index":"William Xie"},{"id":"556e214a02cae52a81727167410b7d73","title":"Swift 排序算法","content":"","slug":"Swift-排序算法","date":"2016-04-19T13:00:54.000Z","categories_index":"Swift For Algorithm","tags_index":"","author_index":"William Xie"}]