{"title":"CFNetwork 编程指南之二: CFNetwork概念（CFNetwork Concepts)","uid":"a332cbc6e65f305f252e6ab66fc98405","slug":"CFNetwork-编程指南之二-CFNetwork概念（CFNetwork-Concepts","date":"2016-08-10T03:56:29.000Z","updated":"2016-08-19T11:44:53.000Z","comments":true,"path":"api/articles/CFNetwork-编程指南之二-CFNetwork概念（CFNetwork-Concepts.json","keywords":null,"cover":[],"content":"<p>#CFNetwork概念</p>\n<p>CFNetwork是一个低级别高性能的框架，使你能够精细的控制协议栈。它是BSD套接字的扩展，标准套接字抽象API提供对象来简化任务，例如与FTP和HTTP服务器通信或解析DNS主机。CFNetwork物理上和理论上都基于BSD套接字。</p>\n<p>正如CFNetwork依赖与BSD套接字，有大量的Cocoa类依赖CFNetwork（例如，NSURL）。此外，Cocoa类的web工具包用来在窗口显示网页内容。这两个类是高层级，并实现大部分的网络协议。因此，软件层的结构如图1-1所示。</p>\n<p><img src=\"https://developer.apple.com/library/ios/documentation/Networking/Conceptual/CFNetwork/Art/layers_2x.png\" alt=\"图1-1 OS X上CFNetwork和其他软件层\"></p>\n<span id=\"more\"></span>\n<p>##何时使用CFNetwork<br>CFNetwork相对BSD套接字有很多优点，它提供了run-loop集成，因此，如果你的应用程序是基于运行循环，你可以使用网络协议，而不用实现线程。CFNetwork还包含大量的对象可帮助你使用网络协议，而不用实现具体的细节。例如，你可以使用FTP协议，而不用实现CFFTP API的所有细节。如果你了解网络协议，需要它们提供低级别的控制，但是不想自己实现，这时CFNetwork可能是正确的选择。</p>\n<p>使用CFNetwork替代Foundation 级别网络API有很多好处。CFNetwork更侧重于网络协议，而Foundation 级别API侧重于数据访问，例如通过HTTP或FTP传输数据。虽然框架API提供了一些可配置性，但CFNetwork提供了更多。关于框架网络类的更多信息，请参阅<a href=\"https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/URLLoadingSystem/URLLoadingSystem.html#//apple_ref/doc/uid/10000165i\">URL Session Programming Guide</a>。</p>\n<p>现在你已了解CFNetwork如何与其他OS X网络API交互，可以开始了解CFNetwork API和形成CFNetwork基础的两个API。</p>\n<p>##CFNetwork基础<br>在学习CFNetwork API之前，你首先需要了解API，这些API是CFNetwork的基础。CFNetwork依赖的两个API：CFSocket和CFStream是核心基础框架的一部分。理解这两个API对使用CFNetwork至关重要。</p>\n<p>###CFSocket API<br>套接字是网络通信的底层。一个套接字类似于电话插孔。它允许你连接到另一个套接字（通过本地或网络）并发送数据给该套接字。</p>\n<p>最常见的套接字是BSD套接字。CFSocket是BSD套接字的一个抽象概念。CFSocket提供几乎BSD套接字的所有功能，使用很少的开销将套接字集成到一个运行循环中。CFSocket并不局限于基于流套接字（例如，TCP），它可以处理任何类型的套接字。</p>\n<p>你可以使用<a href=\"https://developer.apple.com/library/ios/documentation/CoreFoundation/Reference/CFSocketRef/index.html#//apple_ref/doc/c_ref/CFSocketCreate\">CFSocketCreate</a> 函数从头创建一个CFSocket对象，或者使用<a href=\"https://developer.apple.com/library/ios/documentation/CoreFoundation/Reference/CFSocketRef/index.html#//apple_ref/doc/c_ref/CFSocketCreateWithNative\">CFSocketCreateWithNative</a>函数创建。然后你可以使用函数<a href=\"https://developer.apple.com/library/ios/documentation/CoreFoundation/Reference/CFSocketRef/index.html#//apple_ref/doc/c_ref/CFSocketCreateRunLoopSource\">CFSocketCreateRunLoopSource</a> 创建一个运行循环源，并使用函数<a href=\"https://developer.apple.com/library/ios/documentation/CoreFoundation/Reference/CFRunLoopRef/index.html#//apple_ref/doc/c_ref/CFRunLoopAddSource\">CFRunLoopAddSource</a>将其添加到运行循环。这样，当CFSocket对象接收到一条消息时，你的CFSocket回调函数会运行起来。</p>\n<p>关于更多CFSocket API的信息，可阅读CFSocket参考（<a href=\"https://developer.apple.com/library/ios/documentation/CoreFoundation/Reference/CFSocketRef/index.html#//apple_ref/doc/uid/20001445\">CFSocket Reference</a>）。</p>\n<p>###CFStream API<br>读写流提供一种简单的方法以与设备无关的方式来与各种媒体进行数据交换。你可以为内存中、文件中或网络中（使用套接字）的数据创建流，并且你可以使用流而无需将所有的数据加载到内存中。</p>\n<p>流是一个字节序列串行传输的通信路径。流是单向路径，所以需要一个双向通信，一个输入（读取）流和一个输出（写入）流。除了基于文件的流，你不能寻找一个流；一旦数据流被提供或消耗，不能从流中重新取回。</p>\n<p>CFStream是一个API，它为两个新CFType对象：CFReadStream 和CFWriteStream提供了一个抽象。这两种类型的流遵守所有常见核心基础API约定。关于核心基础类型的更多信息，可参阅核心基础设计概念（<a href=\"https://developer.apple.com/library/ios/documentation/CoreFoundation/Conceptual/CFDesignConcepts/CFDesignConcepts.html#//apple_ref/doc/uid/10000122i\">Core Foundation Design Concepts</a>）。</p>\n<p>CFStream构建在CFSocket之上，在CFHTTP和CFFTP之下。如图1-2可以看出，尽管CFStream不是CFNetwork正式的部分，但它是几乎所有CFNetwork的基础。</p>\n<p><img src=\"https://developer.apple.com/library/ios/documentation/Networking/Conceptual/CFNetwork/Art/framework_layers_2x.png\" alt=\"图1-2 CFStream API结构\"></p>\n<p>你可以像使用UNIX文件描述符一样使用读写流。首先，你指定流类型（内存、文件或套接字）实例化流并设置选项。接下来，你可以多次打开流并进行读写。流存在时，可以访问属性获得流信息。流属性是关于流的所有信息，例如它的源或目标，但不是实际写入或读取的数据。当你不再需要流时，关闭并处理它。</p>\n<p>用于读写流的CFStream函数将暂停或阻塞当前进程，直到数据可以读取或写入。为了避免在流阻塞的时候试图读取或写入流，使用异步函数并安排流到一个运行循环上。当可以无阻塞的读取和写入时，将调用你的回调函数。</p>\n<p>此外，CFStream内置支持安全套接字层（SSL）协议。你可以设置包含流SSL信息的字典，例如属性的安全级别或自签证书。然后传递它给你的流，正如<code>kCFStreamPropertySSLSettings</code>属性设置流为SSL流。</p>\n<p>使用流（<a href=\"https://developer.apple.com/library/ios/documentation/Networking/Conceptual/CFNetwork/CFStreamTasks/CFStreamTasks.html#//apple_ref/doc/uid/TP30001132-CH6-SW1\">Working with Streams</a>）章节描述了如何使用读写流。</p>\n<p>##CFNetwork API 概念<br>为了理解CFNetwork框架，你需要熟悉构建它的block。CFNetwork框架分成单独的API，每个API覆盖一个特定的网络协议。这些API可以结合使用或分开使用，这取决于你的应用。API大多数编程约定是常见的，所以理解他们很重要。</p>\n<p>###CFFTP API<br>使用CFFTP与FTP服务器通信会更加容易，使用CFFTP API，你可以创建FTP读取流（下载）和FTP写入流（上传）。使用FTP读写流，你可以执行如下功能：</p>\n<ul>\n<li><p>从FTP服务器下载文件</p>\n</li>\n<li><p>上传文件到FTP服务器</p>\n</li>\n<li><p>从FTP服务器下载目录清单</p>\n</li>\n<li><p>在FTP服务器上创建目录。</p>\n</li>\n</ul>\n<p>FTP流就像其他CFNetwork流一样工作。例如，你可以通过调用CFReadStreamCreateWithFTPURL 函数，创建一个FTP读取流。然后，你可以在任何时候调用CFReadStreamGetError 函数来检查流的状态。</p>\n<p>通过设置FTP流的属性，你可以为特定应用调整你的流。例如，如果流连接的服务器需要一个用户名和密码，你需要设置特定的属性这样流可以正常工作。关于FTP流不同属性的更多信息，请参阅<a href=\"https://developer.apple.com/library/ios/documentation/Networking/Conceptual/CFNetwork/CFFTPTasks/CFFTPTasks.html#//apple_ref/doc/uid/TP30001132-CH9-SW2\">Setting up the Streams</a>。</p>\n<p>可以同步或异步使用CFFTP流。为了打开与FTP服务器的连接，调用CFReadStreamOpen函数，该服务器在FTP读取流创建的时候就已指定。为了读取流，使用CFReadStreamRead 函数并提供读取流引用CFReadStreamRef，当创建FTP读取流时该引用会返回。CFReadStreamRead 函数用FTP服务器输出填充缓存区。</p>\n<p>关于使用CFFTP的更多信息，参阅<a href=\"https://developer.apple.com/library/ios/documentation/Networking/Conceptual/CFNetwork/CFFTPTasks/CFFTPTasks.html#//apple_ref/doc/uid/TP30001132-CH9-SW1\">Working with FTP Servers</a></p>\n<p>###CFHTTP API<br>发送和接收HTTP消息可使用CFHTTP API。正如CFFTP是FTP协议的抽象，CFHTTP是HTTP协议的抽象。</p>\n<p>超文本传输协议（HTTP）是一种客户端和服务器端的请求/响应协议。客户端创建一个请求消息。这个消息被序列化，序列化其实就是将消息转换成原始字节流。消息不能传递除非先被序列化。然后将请求消息发送到服务器。请求通常是请求一个文件，例如网页。服务器响应并后发送回一个字符串然后是消息。这个过程可以重复多次。</p>\n<p>要创建一个HTTP请求消息，你指定以下内容：</p>\n<ul>\n<li><p>请求方法，可以是超文本传输协议定义的请求方法，例如 OPTIONS, GET, HEAD, POST, PUT, DELETE, TRACE, 和CONNECT</p>\n</li>\n<li><p>URL，例如 <code>http://www.apple.com</code></p>\n</li>\n<li><p>HTTP 版本，例如1.0版本或1.1版本。</p>\n</li>\n<li><p>消息的标题通常根据标题名称指定，例如User-Agent，或值，例如MyUserAgent。</p>\n</li>\n<li><p>消息主体</p>\n</li>\n</ul>\n<p>消息创建后，将其序列化。序列化后，请求如下：</p>\n<pre><code>GET / HTTP/1.0\\r\\nUser-Agent: UserAgent\\r\\nContent-Length: 0\\r\\n\\r\\n\n</code></pre>\n<p>序列化对应的是反序列化。反序列化是将从客户端或服务器接收到的原始字节流恢复成本地的表述。CFNetwork提供获取消息类型（请求或响应），HTTP版本，URL，进入的序列化的消息的标题和主体所需要的所有功能。</p>\n<p>使用CFHTTP的更多例子在与HTTP服务通信（<a href=\"https://developer.apple.com/library/ios/documentation/Networking/Conceptual/CFNetwork/CFHTTPTasks/CFHTTPTasks.html#//apple_ref/doc/uid/TP30001132-CH5-SW2\">Communicating with HTTP Servers</a>）。</p>\n<p>###CFHTTPAuthentication API<br>如果你发送一个HTTP请求到身份验证服务器而没有认证信息（或不正确的认证信息），服务器将返回身份验证怀疑（俗称401或407响应）。CFHTTPAuthentication API向受到怀疑的HTTP消息提出身份验证申请。CFHTTPAuthentication 支持如下身份验证方案：</p>\n<ul>\n<li><p>基本</p>\n</li>\n<li><p>摘要</p>\n</li>\n<li><p>NT LAN管理（NTLM）</p>\n</li>\n<li><p>简单的受保护的GSS-API 谈判机制（SPNEGO）</p>\n</li>\n</ul>\n<p>OS X v10.4的新功能是提供持续请求欧诺个能。在OS X v10.3中，每次请求被怀疑，你必须从头开始身份验证。现在，你为每个服务器维护一组CFHTTPAuthentication 对象。当你收到一个401或407响应，你查找服务器正确的对象和凭证，并请求。CFNetwork使用存储在对象的信息尽可能高效的处理请求。</p>\n<p>通过持续请求，新版本的CFHTTPAuthentication 提供更好的性能。关于如何使用CFHTTPAuthentication 的更多信息，可查看与身份验证HTTP服务器进行通信（<a href=\"https://developer.apple.com/library/ios/documentation/Networking/Conceptual/CFNetwork/CFHTTPAuthenticationTasks/CFHTTPAuthenticationTasks.html#//apple_ref/doc/uid/TP30001132-CH8-SW1\">Communicating with Authenticating HTTP Servers</a>）。</p>\n<p>###CFHost API<br>你使用CFHost API获取主机信息，包括名称、地址和可达性信息。获取信息的过程被称为解析。</p>\n<p>CFHost 与CFStream类似：</p>\n<ul>\n<li><p>创建CFHost 对象</p>\n</li>\n<li><p>开始解析CFHost 对象</p>\n</li>\n<li><p>检索地址、主机名或可达性信息</p>\n</li>\n<li><p>当你完成时，销毁CFHost 对象</p>\n</li>\n</ul>\n<p>像所有的CFNetwork、CFHost都兼容IPv4 和IPv6 。使用CFHost，你可以编写代码完全透明的处理IPv4 和IPv6 。</p>\n<p>CFHost的集成与CFNetwork密切相关。例如，有个称为CFStreamCreatePairWithSocketToCFHost 的CFStream 函数会从CFHost对象中直接创建一个CFStream 对象。关于CFHost对象函数的更多信息，参见<a href=\"https://developer.apple.com/library/ios/documentation/CoreFoundation/Reference/CFHostRef/index.html#//apple_ref/doc/uid/TP40003333\">CFHost Reference</a>。</p>\n<p>###CFNetServices API<br>如果你想让你的应用使用Bonjour 注册一个服务或发现服务可以使用CFNetServices API。Bonjour 是苹果零配置网络（ZEROCONF）的实现，它允许你发布、发现和解析网络服务。</p>\n<p>为了实现Bonjour ，CFNetServices API定义三个对象类型：CFNetService、CFNetServiceBrowser和CFNetServiceMonitor。CFNetService对象表示一个单一的网络服务，例如打印机或文件服务器。它包含另一台计算机解析服务器所需的所有信息，例如名称、类型、域和域内网络服务。CFNetServiceBrowser是一个对象用于发现域或域内网络服务。CFNetServiceMonitor对象用于监控CFNetService 对象的变化，例如iChat中的状态消息。</p>\n<p>详细Bonjour的描述见<a href=\"https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/NetServices/Introduction.html#//apple_ref/doc/uid/10000119i\">Bonjour Overview</a>。关于使用CFNetServices 实现Bonjour的更多信息，可查看<a href=\"https://developer.apple.com/library/ios/documentation/Networking/Conceptual/NSNetServiceProgGuide/Introduction.html#//apple_ref/doc/uid/TP40002736\">NSNetServices and CFNetServices Programming Guide</a>。</p>\n<p>###CFNetDiagnostics API<br>连接到网络的应用依赖于一个稳定的链接。如果网络不稳定，这将导致应用程序的问题。采用CFNetDiagnostics API，用户可以自己诊断如下网络问题：</p>\n<ul>\n<li><p>物理连接失败（例如，未插入电缆）</p>\n</li>\n<li><p>网络故障（例如，DNS或DHCP服务器不再响应）</p>\n</li>\n<li><p>配置失败（例如，代理配置不正确）</p>\n</li>\n</ul>\n<p>一旦网络故障诊断出来，CFNetDiagnostics 指导用户解决问题。如果Safari连接网站失败，你可能会看到CFNetDiagnostics 起作用。CFNetDiagnostics 助手如图1-3所示。</p>\n<p><img src=\"https://developer.apple.com/library/ios/documentation/Networking/Conceptual/CFNetwork/Art/net_diagnostics_2x.png\" alt=\"图1-3 网络诊断助手\"></p>\n<p>通过CFNetDiagnostics 提供的网络故障内容，你可以调用<a href=\"https://developer.apple.com/library/ios/documentation/CoreFoundation/Reference/CFNetDiagnosticsRef/index.html#//apple_ref/doc/c_ref/CFNetDiagnosticDiagnoseProblemInteractively\">CFNetDiagnosticDiagnoseProblemInteractively</a>函数引导用户通过提示找到解决办法。此外，你可以使用CFNetDiagnostics 查询连接状态并为用户提供统一的错误消息。</p>\n<p>如何集成CFNetDiagnotics 到你的应用，可参阅使用网络诊断（ <a href=\"https://developer.apple.com/library/ios/documentation/Networking/Conceptual/CFNetwork/UsingNetworkDiagnostics/UsingNetworkDiagnostics.html#//apple_ref/doc/uid/TP30001132-CH7-SW1\">Using Network Diagnostics</a>）。CFNetDiagnostics 是OS X v10.4中新的API。</p>\n<p>官方原文地址：<br><a href=\"https://developer.apple.com/library/ios/documentation/Networking/Conceptual/CFNetwork/Concepts/Concepts.html#//apple_ref/doc/uid/TP30001132-CH4-SW10\">CFNetwork Programming Guide</a></p>\n","text":"#CFNetwork概念 CFNetwork是一个低级别高性能的框架，使你能够精细的控制协议栈。它是BSD套接字的扩展，标准套接字抽象API提供对象来简化任务，例如与FTP和HTTP服务器通信或解析DNS主机。CFNetwork物理上和理论上都基于BSD套接字。 正如CFNetw...","link":"","photos":[],"count_time":{"symbolsCount":"5.5k","symbolsTime":"5 mins."},"categories":[{"name":"iOS网络编程","slug":"iOS网络编程","count":9,"path":"api/categories/iOS网络编程.json"}],"tags":[{"name":"CFNetwork","slug":"CFNetwork","count":7,"path":"api/tags/CFNetwork.json"}],"toc":"","author":{"name":"William Xie","slug":"blog-author","avatar":"/img/author.png","link":"/","description":"","socials":{"github":"https://github.com/williamxiewz","twitter":"https://twitter.com/williamxie_wz","stackoverflow":"http://stackoverflow.com/users/4078104/goingxiebin-jobs","wechat":"","qq":"","weibo":"https://weibo.com/u/2281381063","zhihu":"https://www.zhihu.com/people/williamxiewz","csdn":"https://blog.csdn.net/u014222645","juejin":"https://juejin.cn/user/3280598430133277","customs":{}}},"mapped":true,"prev_post":{"title":"CFNetwork 编程指南之三: 使用流(Working with Streams)","uid":"2ceaaff5f996f8ed02b5f1f94c9c06a5","slug":"CFNetwork-编程指南之三-使用流-Working-with-Streams","date":"2016-08-10T03:57:01.000Z","updated":"2016-08-19T11:44:29.000Z","comments":true,"path":"api/articles/CFNetwork-编程指南之三-使用流-Working-with-Streams.json","keywords":null,"cover":null,"text":"#Working with Streams 本文讨论如何创建、打开和检查读写流错误。它还描述了如何从读取流读取信息，如何从写入信息到写入流，如何在读取或写入流时防止阻塞以及如何通过代理服务器导航到流。 ##使用读取流核心基础流可用于读取或写入文件或使用网络套接字。除了创建这些流过...","link":"","photos":[],"count_time":{"symbolsCount":"15k","symbolsTime":"13 mins."},"categories":[{"name":"iOS网络编程","slug":"iOS网络编程","count":9,"path":"api/categories/iOS网络编程.json"}],"tags":[{"name":"CFNetwork","slug":"CFNetwork","count":7,"path":"api/tags/CFNetwork.json"}],"author":{"name":"William Xie","slug":"blog-author","avatar":"/img/author.png","link":"/","description":"","socials":{"github":"https://github.com/williamxiewz","twitter":"https://twitter.com/williamxie_wz","stackoverflow":"http://stackoverflow.com/users/4078104/goingxiebin-jobs","wechat":"","qq":"","weibo":"https://weibo.com/u/2281381063","zhihu":"https://www.zhihu.com/people/williamxiewz","csdn":"https://blog.csdn.net/u014222645","juejin":"https://juejin.cn/user/3280598430133277","customs":{}}}},"next_post":{"title":"CFNetwork 编程指南之一: 概览","uid":"a230e0658132bd7e51140146dce14c4f","slug":"CFNetwork-编程指南之一-概览","date":"2016-08-10T03:56:09.000Z","updated":"2016-08-19T08:33:23.000Z","comments":true,"path":"api/articles/CFNetwork-编程指南之一-概览.json","keywords":null,"cover":null,"text":"CFNetwork是核心服务框架中的一个框架，提供了抽象概念的网络协议库。这些抽象概念使得执行各种网络任务变得更容易，例如： 使用BSD套接字 使用SSL或TLS创建加密连接 解析DNS主机 使用HTTP，验证HTTP和HTTP服务器 使用FTP服务器 发布、解析和浏览Bonjo...","link":"","photos":[],"count_time":{"symbolsCount":"1.2k","symbolsTime":"1 mins."},"categories":[{"name":"iOS网络编程","slug":"iOS网络编程","count":9,"path":"api/categories/iOS网络编程.json"}],"tags":[{"name":"CFNetwork","slug":"CFNetwork","count":7,"path":"api/tags/CFNetwork.json"}],"author":{"name":"William Xie","slug":"blog-author","avatar":"/img/author.png","link":"/","description":"","socials":{"github":"https://github.com/williamxiewz","twitter":"https://twitter.com/williamxie_wz","stackoverflow":"http://stackoverflow.com/users/4078104/goingxiebin-jobs","wechat":"","qq":"","weibo":"https://weibo.com/u/2281381063","zhihu":"https://www.zhihu.com/people/williamxiewz","csdn":"https://blog.csdn.net/u014222645","juejin":"https://juejin.cn/user/3280598430133277","customs":{}}}}}