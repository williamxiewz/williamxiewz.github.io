{"title":"CFNetwork 编程指南之四: 与HTTP服务器通信(Communicating with HTTP Servers)","uid":"07ef757033d0429be6d914103f281624","slug":"CFNetwork-编程指南之四-与HTTP服务器通信-Communicating-with-HTTP-Servers","date":"2016-08-10T03:57:31.000Z","updated":"2016-08-19T11:46:50.000Z","comments":true,"path":"api/articles/CFNetwork-编程指南之四-与HTTP服务器通信-Communicating-with-HTTP-Servers.json","keywords":null,"cover":null,"content":"<p>#与HTTP服务器通信</p>\n<p>本文解释了如何创建、发送和接收HTTP请求和响应。</p>\n<p>##创建一个CFHTTP请求<br>HTTP请求是一个消息，这个消息由远程服务器执行的方法，操作的对象（URL），消息头和消息体。方法通常是下面之一：GET, HEAD, PUT, POST, DELETE, TRACE, CONNECT 或OPTIONS。<br>用CFHTTP创建一个HTTP请求分为四个步骤：</p>\n<ul>\n<li>使用CFHTTPMessageCreateRequest 函数生成CFHTTP消息对象</li>\n<li>使用CFHTTPMessageSetBody函数设置消息体</li>\n<li>使用CFHTTPMessageSetHeaderFieldValue 函数设置消息头</li>\n<li>通过调用CFHTTPMessageCopySerializedMessage函数序列化消息</li>\n</ul>\n<span id=\"more\"></span>\n\n<p>示例代码类似列表3-1中的代码。</p>\n<p>列表3-1 创建一个HTTP请求</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">CFStringRef bodyString &#x3D; CFSTR(&quot;&quot;); &#x2F;&#x2F; Usually used for POST data \nCFDataRef bodyData &#x3D;     \nCFStringCreateExternalRepresentation     \n(kCFAllocatorDefault,bodyString,kCFStringEncodingUTF8, 0);\n\nCFStringRef headerFieldName &#x3D; CFSTR(&quot;X-My-Favorite-Field&quot;);\nCFStringRef headerFieldValue &#x3D; CFSTR(&quot;Dreams&quot;);\n\nCFStringRef url &#x3D; CFSTR(&quot;http:&#x2F;&#x2F;www.apple.com&quot;);\nCFURLRef myURL &#x3D; CFURLCreateWithString(kCFAllocatorDefault, url, NULL);\n\nCFStringRef requestMethod &#x3D; CFSTR(&quot;GET&quot;);\nCFHTTPMessageRef myRequest &#x3D;\nCFHTTPMessageCreateRequest(kCFAllocatorDefault, requestMethod, myURL,\n                          kCFHTTPVersion1_1);\n\nCFDataRef bodyDataExt &#x3D;\nCFStringCreateExternalRepresentation(kCFAllocatorDefault,     \nbodyData, kCFStringEncodingUTF8, 0);   \nCFHTTPMessageSetBody(myRequest, bodyDataExt);     \n\nCFHTTPMessageSetHeaderFieldValue(myRequest,\nheaderFieldName, headerFieldValue);\nCFDataRef mySerializedRequest &#x3D;       \nCFHTTPMessageCopySerializedMessage(myRequest);</code></pre>\n\n<p>在此示例代码中，通过调用<a href=\"https://developer.apple.com/library/ios/documentation/CoreFoundation/Reference/CFURLRef/index.html#//apple_ref/doc/c_ref/CFURLCreateWithString\">CFURLCreateWithString</a>，url 是首先转换成一个CFURL对象。然后调用<a href=\"https://developer.apple.com/library/ios/documentation/CoreFoundation/Reference/CFMessageRef/index.html#//apple_ref/doc/c_ref/CFHTTPMessageCreateRequest\">CFHTTPMessageCreateRequest</a> ，有四个参数：kCFAllocatorDefault 指定默认系统内存分配器用来创建消息应用，requestMethod 指定方法，例如POST方法，myURL 用来指定URL，例如，<code>http://www.apple.com</code>，kCFHTTPVersion1_1指定消息HTTP版本是1.1.</p>\n<p><a href=\"https://developer.apple.com/library/ios/documentation/CoreFoundation/Reference/CFMessageRef/index.html#//apple_ref/doc/c_ref/CFHTTPMessageCreateRequest\">CFHTTPMessageCreateRequest</a> 返回的消息对象引用(myRequest)和消息体(bodyData)一起发送到<a href=\"https://developer.apple.com/library/ios/documentation/CoreFoundation/Reference/CFMessageRef/index.html#//apple_ref/doc/c_ref/CFHTTPMessageSetBody\">CFHTTPMessageSetBody</a> 。然后调用<a href=\"https://developer.apple.com/library/ios/documentation/CoreFoundation/Reference/CFMessageRef/index.html#//apple_ref/doc/c_ref/CFHTTPMessageSetHeaderFieldValue\">CFHTTPMessageSetHeaderFieldValue</a> 使用相同消息对象引用，头(headerField)名称和设置的值(value)。头参数是个CFString对象，例如Content-Length,值参数是一个CFString对象例如1260.最后，调用<a href=\"https://developer.apple.com/library/ios/documentation/CoreFoundation/Reference/CFMessageRef/index.html#//apple_ref/doc/c_ref/CFHTTPMessageCopySerializedMessage\">CFHTTPMessageCopySerializedMessage</a>序列化消息，通过写入流发送到接受者，例子详见<code>http://www.apple.com</code></p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>注意：请求主体通常省略。请求主体通常用于一个包含POST数据的POST请求。它也可以用于其他有关HTTP扩展的请求类型，例如WebDAV。更多信息参见<a href=\"http://www.w3.org/Protocols/rfc2616/rfc2616.html\">RFC 2616</a>。</p></blockquote>\n<p>当不再需要消息，释放消息对象并序列化消息。见列表3-2的示例代码</p>\n<p>列表3-2 释放一个HTTP请求</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">CFRelease(myRequest);   \nCFRelease(myURL); \nCFRelease(url); \nCFRelease(mySerializedRequest); \nmyRequest &#x3D; NULL; \nmySerializedRequest &#x3D; NULL;</code></pre>\n\n\n<p>##创建一个CFHTTP响应<br>创建一个HTTP响应的步骤与创建一个HTTP请求的步骤几乎完全相同。唯一的区别是，调用函数<a href=\"https://developer.apple.com/library/ios/documentation/CoreFoundation/Reference/CFMessageRef/index.html#//apple_ref/doc/c_ref/CFHTTPMessageCreateResponse\">CFHTTPMessageCreateResponse</a> ，而不是<a href=\"https://developer.apple.com/library/ios/documentation/CoreFoundation/Reference/CFMessageRef/index.html#//apple_ref/doc/c_ref/CFHTTPMessageCreateRequest\">CFHTTPMessageCreateRequest</a>，两者使用相同的参数</p>\n<p>反序列化传入的HTTP请求<br>反序列化一个传入的HTTP请求，使用<a href=\"https://developer.apple.com/library/ios/documentation/CoreFoundation/Reference/CFMessageRef/index.html#//apple_ref/doc/c_ref/CFHTTPMessageCreateEmpty\">CFHTTPMessageCreateEmpty</a> 函数，创建一个空消息，isRequest 参数设为TRUE 指定创建一个空的请求消息。然后调用<a href=\"https://developer.apple.com/library/ios/documentation/CoreFoundation/Reference/CFMessageRef/index.html#//apple_ref/doc/c_ref/CFHTTPMessageAppendBytes\">CFHTTPMessageAppendBytes</a>函数将传入的消息添加到空消息中。<a href=\"https://developer.apple.com/library/ios/documentation/CoreFoundation/Reference/CFMessageRef/index.html#//apple_ref/doc/c_ref/CFHTTPMessageAppendBytes\">CFHTTPMessageAppendBytes</a>反序列化消息并移除任何可能包含的控制信息。</p>\n<p>继续这样做直到<a href=\"https://developer.apple.com/library/ios/documentation/CoreFoundation/Reference/CFMessageRef/index.html#//apple_ref/doc/c_ref/CFHTTPMessageIsHeaderComplete\">CFHTTPMessageIsHeaderComplete</a> 函数返回TRUE。如果你不检查<a href=\"https://developer.apple.com/library/ios/documentation/CoreFoundation/Reference/CFMessageRef/index.html#//apple_ref/doc/c_ref/CFHTTPMessageIsHeaderComplete\">CFHTTPMessageIsHeaderComplete</a> 是否返回TRUE，消息可能是不完整的或不可信的。列表3-3可以看到这两个函数使用的例子。</p>\n<p>列表3-3 反序列化消息</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">CFHTTPMessageRef myMessage &#x3D;   \nCFHTTPMessageCreateEmpty(kCFAllocatorDefault, TRUE);   \nif (!CFHTTPMessageAppendBytes(myMessage, &amp;data, numBytes)) &#123;   \n\n&#x2F;&#x2F;Handle parsing error\n&#125;\n</code></pre>\n\n\n<p>在示例中，data 是添加的数据而numBytes 是的data 长度。调用CFHTTPMessageIsHeaderComplete 验证附加消息的头是完整的。</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">if (CFHTTPMessageIsHeaderComplete(myMessage)) &#123; \n\n&#x2F;&#x2F; Perform processing.\n&#125;\n</code></pre>\n\n\n\n<p>消息反序列化后，你可以调用如下函数从消息中提取信息：</p>\n<ul>\n<li><code>CFHTTPMessageCopyBody</code> 用来获取消息主体</li>\n<li><code>CFHTTPMessageCopyHeaderFieldValue</code> 用来获取特定头字段值</li>\n<li><code>CFHTTPMessageCopyAllHeaderFields</code> 用来获取所有消息头字段</li>\n<li><code>CFHTTPMessageCopyRequestURL </code>用来获取消息URL</li>\n<li><code>CFHTTPMessageCopyRequestMethod </code>用来获取消息请求方法</li>\n</ul>\n<p>当你不再需要该消息，释放并恰当的处理它。</p>\n<p>##反序列化传入的HTTP响应<br>正如创建HTTP请求类似于创建HTTP响应一样，反序列化传入的HTTP请求与反序列化传入的HTTP响应类似。唯一重要的区别是，当调用<a href=\"https://developer.apple.com/library/ios/documentation/CoreFoundation/Reference/CFMessageRef/index.html#//apple_ref/doc/c_ref/CFHTTPMessageCreateEmpty\">CFHTTPMessageCreateEmpty</a>，你必须给isRequest 参数传入FALSE 来指定将要创建的消息是响应消息。</p>\n<p>##使用读取流序列化并发送HTTP请求<br>你可以使用CFReadStream对象来序列化和发送CFHTTP请求。当你使用CFReadStream对象来发送一个CFHTTP请求时，打开流因为消息必须在同一步中序列化好发送。使用CFReadStream 对象来发送CFHTTP请求，使获取请求的响应更加容易，因为响应作为流的属性是可用的。</p>\n<p>###序列化并发送一个HTTP请求<br>使用CFReadStream 对象序列化并发送HTTP请求，首先创建一个CFHTTP请求并设置消息主体和头，在创建CFHTTP请求（<a href=\"https://developer.apple.com/library/ios/documentation/Networking/Conceptual/CFNetwork/CFHTTPTasks/CFHTTPTasks.html#//apple_ref/doc/uid/TP30001132-CH5-SW1\">Creating a CFHTTP Request</a>）中有描述。然后，调用<a href=\"https://developer.apple.com/library/ios/documentation/CoreFoundation/Reference/CFHTTPStreamRef/index.html#//apple_ref/doc/c_ref/CFReadStreamCreateForHTTPRequest\">CFReadStreamCreateForHTTPRequest</a> 函数创建一个CFReadStream 对象，传递你刚刚创建的请求。最后，通过<a href=\"https://developer.apple.com/library/ios/documentation/CoreFoundation/Reference/CFReadStreamRef/index.html#//apple_ref/doc/c_ref/CFReadStreamOpen\">CFReadStreamOpen</a>打开读取流。</p>\n<p>当调用<a href=\"https://developer.apple.com/library/ios/documentation/CoreFoundation/Reference/CFHTTPStreamRef/index.html#//apple_ref/doc/c_ref/CFReadStreamCreateForHTTPRequest\">CFReadStreamCreateForHTTPRequest</a> ，复制一份传入的CFHTTP请求对象。因此，如果有必要，你可以在调用<a href=\"https://developer.apple.com/library/ios/documentation/CoreFoundation/Reference/CFHTTPStreamRef/index.html#//apple_ref/doc/c_ref/CFReadStreamCreateForHTTPRequest\">CFReadStreamCreateForHTTPRequest</a> 之后立即释放CFHTTP请求对象。</p>\n<p>因为当创建CFHTTP请求时，读取流打开一个套接字连接myUrl 参数指定的服务器，两者之间允许有些时间差。打开读取流也会导致请求被序列化和发送。</p>\n<p>列表3-4是一个关于如何序列化和发送HTTP请求的例子</p>\n<p>列表3-4 读取流序列化HTTP请求</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">CFStringRef url &#x3D; CFSTR(&quot;http:&#x2F;&#x2F;www.apple.com&quot;); \nCFURLRef myURL &#x3D; CFURLCreateWithString(kCFAllocatorDefault, url, NULL); \nCFStringRef requestMethod &#x3D; CFSTR(&quot;GET&quot;); \nCFHTTPMessageRef myRequest &#x3D;     \nCFHTTPMessageCreateRequest(kCFAllocatorDefault,   \nrequestMethod, myUrl, kCFHTTPVersion1_1); \nCFHTTPMessageSetBody(myRequest, bodyData); \nCFHTTPMessageSetHeaderFieldValue(myRequest, headerField, value); \nCFReadStreamRef myReadStream &#x3D;     \nCFReadStreamCreateForHTTPRequest(kCFAllocatorDefault, myRequest); \nCFReadStreamOpen(myReadStream);</code></pre>\n\n<p>###检查响应<br>在你安排请求到运行循环后，你将最终会得到一个头完成回调。在这一点上，你可以调用<a href=\"https://developer.apple.com/library/ios/documentation/CoreFoundation/Reference/CFReadStreamRef/index.html#//apple_ref/c/func/CFReadStreamCopyProperty\">CFReadStreamCopyProperty</a> 从读取流获取消息响应。</p>\n<pre><code>CFHTTPMessageRef myResponse = (CFHTTPMessageRef)CFReadStreamCopyProperty(myReadStream,kCFStreamPropertyHTTPResponseHeader);\n</code></pre>\n<p>你可以通过调用CFHTTPMessageCopyResponseStatusLine函数，从消息响应获取完整状态行：</p>\n<pre><code>CFStringRef myStatusLine = CFHTTPMessageCopyResponseStatusLine(myResponse);\n</code></pre>\n<p>通过调用CFHTTPMessageGetResponseStatusCode函数获取消息响应的状态码：</p>\n<pre><code>UInt32 myErrCode = CFHTTPMessageGetResponseStatusCode(myResponse);\n</code></pre>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>注意：如果你正在同步使用这个类（没有安排到运行循环），你必须在调用CFReadStreamCopyProperty之前调用<a href=\"https://developer.apple.com/library/ios/documentation/CoreFoundation/Reference/CFReadStreamRef/index.html#//apple_ref/c/func/CFReadStreamRead\">CFReadStreamRead</a> ，先读取消息。CFReadStreamRead 调用一直阻塞直到数据可用（或连接失败）。不要在你的主应用线程中使用。</p></blockquote>\n<p>###处理身份验证错误<br>如果CFHTTPMessageGetResponseStatusCode 函数返回的状态码是401（远程服务器需要身份验证信息）或407（代理服务器需要身份验证），你需要将身份验证信息附加到请求并重新发送。关于如何处理身份验证的信息，请查看与需要身份验证HTTP服务器通信（ <a href=\"https://developer.apple.com/library/ios/documentation/Networking/Conceptual/CFNetwork/CFHTTPAuthenticationTasks/CFHTTPAuthenticationTasks.html#//apple_ref/doc/uid/TP30001132-CH8-SW1\">Communicating with Authenticating HTTP Servers</a>）。</p>\n<p>###处理重定向错误<br>当<code>CFReadStreamCreateForHTTPRequest</code> 创建一个读取流，默认情况下流的自动重定向是禁用的。如果请求发送的统一资源定位符或URL重定向到另一个URL，发送该请求将导致一个错误，状态码在300到307之间。如果你接收到一个重定向错误，你需要关闭流，创建流，启用重定向并打开流。参见列表3-5.</p>\n<p>列表3-5 重定向HTTP流</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">CFReadStreamClose(myReadStream);\nCFReadStreamRef myReadStream &#x3D;\nCFReadStreamCreateForHTTPRequest(kCFAllocatorDefault, myRequest);\nif (CFReadStreamSetProperty(myReadStream,\nkCFStreamPropertyHTTPShouldAutoredirect, kCFBooleanTrue) &#x3D;&#x3D; false) &#123;\n\n&#x2F;&#x2F; something went wrong, exit\n\n&#125;\nCFReadStreamOpen(myReadStream);</code></pre>\n\n<p>当你创建一个读取流，你可能想要启用自动重定向。</p>\n<p>##取消一个待定请求<br>一旦请求已经发送，不能阻止远程服务器处理它。然而，你不再关心响应数据，你可以关闭流。</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>重要：如果另一个线程正在等待某个线程的流的内容，则不要关闭该流。如果你需要终止请求时，你应该使用非阻塞 I/O，在使用流时防止阻塞（<a href=\"https://developer.apple.com/library/ios/documentation/Networking/Conceptual/CFNetwork/CFStreamTasks/CFStreamTasks.html#//apple_ref/doc/uid/TP30000230-61973\">Preventing Blocking When Working with Streams</a>）中有描述。确保在关闭流之前从你的运行循环上移除流。</p></blockquote>\n<p>官方原文地址：<br><a href=\"https://developer.apple.com/library/ios/documentation/Networking/Conceptual/CFNetwork/CFHTTPTasks/CFHTTPTasks.html#//apple_ref/doc/uid/TP30001132-CH5-SW2\">CFNetwork Programming Guide</a></p>\n","text":"#与HTTP服务器通信 本文解释了如何创建、发送和接收HTTP请求和响应。 ##创建一个CFHTTP请求HTTP请求是一个消息，这个消息由远程服务器执行的方法，操作的对象（URL），消息头和消息体。方法通常是下面之一：GET, HEAD, PUT, POST, DELETE, T...","link":"","photos":[],"count_time":{"symbolsCount":"6.4k","symbolsTime":"6 mins."},"categories":[{"name":"iOS网络编程","slug":"iOS网络编程","count":9,"path":"api/categories/iOS网络编程.json"}],"tags":[{"name":"CFNetwork","slug":"CFNetwork","count":7,"path":"api/tags/CFNetwork.json"}],"toc":"","author":{"name":"William Xie","slug":"blog-author","avatar":"/img/author.png","link":"/","description":"","socials":{"github":"https://github.com/williamxiewz","twitter":"https://twitter.com/williamxie_wz","stackoverflow":"http://stackoverflow.com/users/4078104/goingxiebin-jobs","wechat":"","qq":"","weibo":"https://weibo.com/u/2281381063","zhihu":"https://www.zhihu.com/people/williamxiewz","csdn":"https://blog.csdn.net/u014222645","juejin":"https://juejin.cn/user/3280598430133277","customs":{}}},"mapped":true,"prev_post":{"title":"CFNetwork 编程指南之五: 与身份验证HTTP服务器通信(Communicating with Authenticating HTTP Servers)","uid":"e4b9eca156b9b591c912ba6382a5ef7f","slug":"CFNetwork-编程指南之五-与身份验证HTTP服务器通信-Communicating-with-Authenticating-HTTP-Servers","date":"2016-08-10T03:58:03.000Z","updated":"2016-08-19T11:45:25.000Z","comments":true,"path":"api/articles/CFNetwork-编程指南之五-与身份验证HTTP服务器通信-Communicating-with-Authenticating-HTTP-Servers.json","keywords":null,"cover":[],"text":"#与身份验证HTTP服务器通信 本文描述了如何利用CFHTTPAuthentication API与需要身份验证的HTTP服务器通信。它解释了如何找到匹配的验证对象和证书，并将它们应用到HTTP请求，然后存储以供以后使用。 一般来说，如果一个HTTP服务器返回一个401或407响...","link":"","photos":[],"count_time":{"symbolsCount":"11k","symbolsTime":"10 mins."},"categories":[{"name":"iOS网络编程","slug":"iOS网络编程","count":9,"path":"api/categories/iOS网络编程.json"}],"tags":[{"name":"CFNetwork","slug":"CFNetwork","count":7,"path":"api/tags/CFNetwork.json"}],"author":{"name":"William Xie","slug":"blog-author","avatar":"/img/author.png","link":"/","description":"","socials":{"github":"https://github.com/williamxiewz","twitter":"https://twitter.com/williamxie_wz","stackoverflow":"http://stackoverflow.com/users/4078104/goingxiebin-jobs","wechat":"","qq":"","weibo":"https://weibo.com/u/2281381063","zhihu":"https://www.zhihu.com/people/williamxiewz","csdn":"https://blog.csdn.net/u014222645","juejin":"https://juejin.cn/user/3280598430133277","customs":{}}}},"next_post":{"title":"CFNetwork 编程指南之三: 使用流(Working with Streams)","uid":"2ceaaff5f996f8ed02b5f1f94c9c06a5","slug":"CFNetwork-编程指南之三-使用流-Working-with-Streams","date":"2016-08-10T03:57:01.000Z","updated":"2016-08-19T11:44:29.000Z","comments":true,"path":"api/articles/CFNetwork-编程指南之三-使用流-Working-with-Streams.json","keywords":null,"cover":null,"text":"#Working with Streams 本文讨论如何创建、打开和检查读写流错误。它还描述了如何从读取流读取信息，如何从写入信息到写入流，如何在读取或写入流时防止阻塞以及如何通过代理服务器导航到流。 ##使用读取流核心基础流可用于读取或写入文件或使用网络套接字。除了创建这些流过...","link":"","photos":[],"count_time":{"symbolsCount":"15k","symbolsTime":"13 mins."},"categories":[{"name":"iOS网络编程","slug":"iOS网络编程","count":9,"path":"api/categories/iOS网络编程.json"}],"tags":[{"name":"CFNetwork","slug":"CFNetwork","count":7,"path":"api/tags/CFNetwork.json"}],"author":{"name":"William Xie","slug":"blog-author","avatar":"/img/author.png","link":"/","description":"","socials":{"github":"https://github.com/williamxiewz","twitter":"https://twitter.com/williamxie_wz","stackoverflow":"http://stackoverflow.com/users/4078104/goingxiebin-jobs","wechat":"","qq":"","weibo":"https://weibo.com/u/2281381063","zhihu":"https://www.zhihu.com/people/williamxiewz","csdn":"https://blog.csdn.net/u014222645","juejin":"https://juejin.cn/user/3280598430133277","customs":{}}}}}