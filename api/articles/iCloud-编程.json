{"title":"iCloud 编程","uid":"548f4e29db9400645bad688f092ca0b0","slug":"iCloud-编程","date":"2016-08-08T13:48:46.000Z","updated":"2016-08-23T02:49:57.000Z","comments":true,"path":"api/articles/iCloud-编程.json","keywords":null,"cover":null,"content":"<p>#iCloud简介</p>\n<p>iCloud 是苹果”云战略”的重要棋子，iCloud是苹果的云服务技术。它的重点是提供数据的存储服务，苹果给每个用户免费提供5GB的云服务空间。如果不够，用户可以付费购买更多的空间。苹果公司斥资 10亿美元在北卡罗莱纳州建设新数据中心-iDataCenter，该数据中心面积为50万平方英尺，也是美国最大规模的数据中心之一。 </p>\n<p>iCloud被整合到iOS 5和OS X 10.7. 4中，使用了这些设备的用户，只需在多个设备中设置苹果账号就可以同步、共享和备份数据。如图4-1所示，我的iphone设备上的通讯录可以同步到我的ipad和Mac Air电脑中。iCloud可以存放照片、文档等内容，以无线方式将它们推送到你的所有设备上。这都是自动在后台执行的，当打开电脑时候你会发现这些信息已经在那里了！</p>\n<p>使用iCLoud 服务除了能够存储特定应用数据,还可以通过编程方式存储自己应用的数据,iOS8 之后苹果支持4中类的iCloud存储:</p>\n<ul>\n<li>iCloud 键值数据存储</li>\n<li>iCloud 文档存储</li>\n<li>iCloud Core Data 技术</li>\n<li>iCloudKit 存储编程</li>\n</ul>\n<span id=\"more\"></span>\n<p>#iCloud 键值数据存储</p>\n<p>iCloud键值数据存储的应用场景是这样的：我有看电子书的习惯，经常在乘坐地铁的时候使用iphone看电子书，当看到精彩内容的时候，我到站了 ，于是我关闭了这个应用。当晚上回到家时，我想用Ipad躺在沙发上看那本电子书，而且我想接着那个精彩的地方开始看。一个设计良好的电子书应用应该是：当我使用ipad打开这本书的时候，它应该马上跳到我当初退出的地方。这需要开发人员记录下退出时的页码，并保存在icloud中，然后其他设备使用该应用的时候获取这些记录信息，以便于初始化应用。</p>\n<p>icloud键值数据存储，以一种键值对的方式存储简单类型数据，这些数据类型包括数字、日期、数组和字典等。数据结构是pust类型。每个应用只能存储64KB的数据。它也没有像文档存储那样有一套数据冲突解决方案，新的数据会覆盖旧的数据。因此，它经常用来存储系统设置、使用偏好以及应用的状态.</p>\n<p>iCloud键值数据存储编程比较简单,在API使用方面,<code>NSUbiquitousKeyValueStore类</code><br>它的使用类似于 <code>NSUserDefaults</code>,NSUserDefaults类 是苹果设计的访问本地系统的设置类.<br>而NSUbiquitousKeyValueStore类 是用来访问iCLoud 键值数据存储数据的.<br>NSUbiquitousKeyValueStore实例的获得也采用单例设计模式:</p>\n<pre><code>var store = NSUbiquitousKeyValueStore.defaultStore() \n</code></pre>\n<p>下面是NSUbiquitousKeyValueStore类的一些取值方法：</p>\n<ul>\n<li>boolForKey:根据键取出布尔值。 </li>\n<li>longLongForKey:根据键取出长整型值。</li>\n<li>objectForKey:根据键取出id类型值。</li>\n<li>stringForKey:根据键取出Nsstring类型值。 </li>\n<li>doubieForKey:根据键取出double类型值。</li>\n<li>arrayForKey;根据键取出数组类型值。 </li>\n<li>dictionaryForKey:根据键取出字典类型值。</li>\n<li>dataForKey:根据键取出NSData类型值。 </li>\n</ul>\n<p>下面是NSUbiquitousKeyValueStore类的一些赋值方法： </p>\n<ul>\n<li>setBoo]: forKey:根据键设置布尔值。 </li>\n<li>setLongLong: forKey:根据键设置长整型值。</li>\n<li>setObject; forKey:根据键设置id类型值。</li>\n<li>setString: forKey;根据键设置Nsstring类型值。</li>\n<li>setDouble: forKey:根据键设置double类型值。</li>\n<li>setArray: forKey:根据键设置数组类型值。</li>\n<li>setDictionary: forKey;根据键设置字典类型值。</li>\n<li>setData; forKey;根据键设置NSData类型值。 </li>\n</ul>\n<p>力了监听iCLoud键值数据存储据的变化，可以在程序中注册通知消息 <code>NSUbiquitousKeyValueStoreDidchangeExternallyNotification</code>，这个通知是当一个设备更新了iCloud中的键值数据时,iCloud服务器会发出这个通知,使得其他设备都接受到这个通知.</p>\n<p>##iCloud键值存储实例</p>\n<p>开启Capabilities&gt;iCloud&gt;Key-Value storage</p>\n<p>出现”&lt;工程名&gt;”. entilements 这个文件是授权文件,它保存了该工程的iCloud授权的详细配置信息.</p>\n<p>首先注册NSUbiquitousKeyValueStoreDidchangeExternallyNotification通知,并同步数据.</p>\n<pre class=\"line-numbers language-swift\" data-language=\"swift\"><code class=\"language-swift\">\nimport UIKit\n\n&#x2F;&#x2F;背景音乐 存储键\nlet UbiquitousMusicKey &#x3D; &quot;MusicKey&quot;\n&#x2F;&#x2F;音效 存储键\nlet UbiquitousSoundKey &#x3D; &quot;SoundKey&quot;\n\nclass ViewController: UITableViewController &#123;\n    \n    @IBOutlet weak var switchMusic: UISwitch!    \n    @IBOutlet weak var switchSound: UISwitch!\n    &#x2F;&#x2F;单例\n    var store &#x3D; NSUbiquitousKeyValueStore.defaultStore()\n    &#x2F;&#x2F;观察着指针\n    var storeDidChangeObserver : AnyObject!\n    \n    override func viewDidLoad() &#123;\n        super.viewDidLoad()\n        \n        &#x2F;&#x2F;初始化控件状态\n        self.switchMusic.setOn(self.store.boolForKey(UbiquitousMusicKey), animated: true)\n        self.switchSound.setOn(self.store.boolForKey(UbiquitousSoundKey), animated: true)\n        &#x2F;&#x2F;添加观察者,改通知在iCloud服务数据变化时候触发,当客户端接受到该小心时会调用closure\n        self.storeDidChangeObserver &#x3D; NSNotificationCenter.defaultCenter().addObserverForName(NSUbiquitousKeyValueStoreDidChangeExternallyNotification, object: nil, queue: nil) &#123; (note) -&gt; Void in\n            &#x2F;&#x2F;更新控件状态\n            self.switchMusic.setOn(self.store.boolForKey(UbiquitousMusicKey), animated: true)\n            self.switchSound.setOn(self.store.boolForKey(UbiquitousSoundKey), animated: true)\n            \n            let alert &#x3D; UIAlertView(title: &quot;iCloud变更通知&quot;, message: &quot;你的iCloud存储数据已经变更&quot;, delegate: nil, cancelButtonTitle: &quot;Ok&quot;)\n            alert.show()\n        &#125;\n        &#x2F;&#x2F;同步到iCloud 服务器\n        self.store.synchronize()\n    &#125;\n\n    override func didReceiveMemoryWarning() &#123;\n        \n        super.didReceiveMemoryWarning()\n        NSNotificationCenter.defaultCenter().removeObserver(self.storeDidChangeObserver)\n    &#125;\n\n\n    @IBAction func setData(sender: AnyObject) &#123;\n        &#x2F;&#x2F;存储iCloud服务器\n        self.store.setBool(self.switchMusic.on, forKey: UbiquitousMusicKey)\n        self.store.setBool(self.switchSound.on, forKey: UbiquitousSoundKey)\n        self.store.synchronize()\n    &#125;\n&#125;\n\n\n\n</code></pre>\n<p>#iCloud文档存储</p>\n<p>文档存储 iCloud文梢存储的应用场景是这样的：我有一个备忘录应用，我在上班的路上突发奇<br>想，于是我用iphone记录下我好想法。然后，到公司的时候使用我的Mac Air运行我的备<br>忘录应用，我会发现应用刚才记录的方法同步到我的Mac Air中了。</p>\n<p>iCloud文档存储可以保存用户文档，用户在应用中创建文档，并通过 fcioud守护进程同步到icloud服务。文档类型没有限制，可以是文本文件、二进制文件。<br>存储空间与用户的可用icloud服务空间有关，在文档冲突方面icloud提供一套API帮助<br>解决这些问题。</p>\n<p>##iCloud存储运行过程 </p>\n<p>iCloud文档存储运行过程要比键值数据存储烦琐得多，将本地数据存储到iCloud服务器，大体分成3个步骤： </p>\n<p>步骤(1)<code>应用(App)</code>通过一个<code>Ubiquity容器标识</code>请求操作系统Ubiquity容器；<br>步骤(2)操作系统授权<code>应用(App)</code>可以访问Ubiquity容器；<br>步骤(3)通过Ubiquity容器实现与iCloud服务器传输数据。Ubiquity容器事实上也是设备上的目录，下面是运行在笔者设备某个应用的Ubiquity容器目录： </p>\n<p>/var/mobile/Library/Mobile % 20Documents/icloud〜cm〜51work6〜DoucmentDemo/</p>\n<p>而应用的沙箱目录：<br>/var/mobile/Containers/Data/Application/5A858EE6-F4FA-4462-835F-2AB8ED1994DA/Docuinents<br>可见沙箱目录与Ubiquity容器目录是不同的，使用的时候数据不能直接放在Ubiquity容器根目录下，而是要放在它的Documents子目录中，放入到这个目录中的数据可以自动同步到icioud服务器上，这个同步的过程开发者不用关系，由系统自动同步完成。</p>\n<p>##iCloud文档储存实例</p>\n<p>开启Capabilities&gt;iCloud&gt;iCloud Documents<br>出现”&lt;工程名&gt;”. entilements 这个文件是授权文件,它保存了该工程的iCloud授权的详细配置信息<br>Containers选择 User default container 使用默认的容器名 : <code>&quot;iCloud.&lt;应用BundleID&gt;&quot;</code><br>自定义文档类</p>\n<pre class=\"line-numbers language-swift\" data-language=\"swift\"><code class=\"language-swift\">class MyCloudDocument: UIDocument &#123;\n    &#x2F;&#x2F;保存文档数据 ,这个文档是本文文件,所以是NSString类型\n    var contents : NSString!\n    \n    &#x2F;&#x2F;加载数据\n    override func loadFromContents(contents: AnyObject, ofType typeName: String?) throws &#123;\n        \n        let qContents &#x3D; contents as! NSData\n        \n        if qContents.length &gt; 0 &#123;\n            self.contents &#x3D; NSString(data: qContents, encoding: NSUTF8StringEncoding)\n        &#125;\n    &#125;\n    \n    &#x2F;&#x2F;保存数据\n    override func contentsForType(typeName: String) throws -&gt; AnyObject &#123;\n        let outError: NSError! &#x3D; NSError(domain: &quot;Migrator&quot;, code: 0, userInfo: nil)\n        let resContents &#x3D; self.contents.dataUsingEncoding(NSUTF8StringEncoding)\n        if let value &#x3D; resContents &#123;\n            return value\n        &#125;\n        throw outError\n    &#125;\n&#125;\n\n\n</code></pre>\n\n\n\n<pre class=\"line-numbers language-swift\" data-language=\"swift\"><code class=\"language-swift\">import UIKit\n&#x2F;&#x2F;当前设备名\nlet DeviceName &#x3D; UIDevice.currentDevice().name\n\nclass ViewController: UIViewController &#123;\n\n    @IBOutlet weak var txtContent: UITextField!\n    &#x2F;&#x2F;自定义文档类\n    var myCloudDocument : MyCloudDocument!\n    &#x2F;&#x2F;查询元数据\n    var query &#x3D; NSMetadataQuery()\n    \n    &#x2F;&#x2F;请求本地Ubiquity容器，从容器中获得Document目录URL\n    lazy var ubiquitousDocumentsURL : NSURL? &#x3D; &#123;\n        let fileManager &#x3D; NSFileManager.defaultManager()\n        var containerURL &#x3D; fileManager.URLForUbiquityContainerIdentifier(&quot;iCloud.com.xxx.Demo&quot;)\n        print(&quot;Ubiquity容器 : \\(containerURL)&quot;)\n        containerURL &#x3D; containerURL?.URLByAppendingPathComponent(&quot;Documents&quot;)\n        return containerURL\n    &#125;()\n\n    override func viewDidLoad() &#123;\n        super.viewDidLoad()\n        \n        &#x2F;&#x2F;为查询iCloud文件的变化，注册通知\n        NSNotificationCenter.defaultCenter().addObserver(self, selector:&quot;updateUbiquitousDocuments:&quot;, name: NSMetadataQueryDidFinishGatheringNotification, object: nil)\n        NSNotificationCenter.defaultCenter().addObserver(self, selector:&quot;updateUbiquitousDocuments:&quot;, name: NSMetadataQueryDidUpdateNotification, object: nil)\n        \n        &#x2F;&#x2F;注册文档状态变化通知\n        NSNotificationCenter.defaultCenter().addObserver(self, selector: &quot;resolveConflict:&quot;, name: UIDocumentStateChangedNotification, object: nil)\n        \n        &#x2F;&#x2F;查询iCloud文件的变化\n        if (self.ubiquitousDocumentsURL !&#x3D; nil) &#123;\n            self.query.predicate &#x3D; NSPredicate(format: &quot;%K like &#39;abc.txt&#39;&quot;, NSMetadataItemFSNameKey)\n            self.query.searchScopes &#x3D; [NSMetadataQueryUbiquitousDocumentsScope]\n        &#125;\n    &#125;\n\n    override func didReceiveMemoryWarning() &#123;\n        super.didReceiveMemoryWarning()\n        NSNotificationCenter.defaultCenter().removeObserver(self)\n    &#125;\n    \n    override func viewWillAppear(animated: Bool) &#123;\n        self.query.enableUpdates()\n        self.query.startQuery()\n    &#125;\n    \n    override func viewDidDisappear(animated: Bool) &#123;\n        self.query.disableUpdates()\n        self.query.stopQuery()\n    &#125;\n\n\n    \n    &#x2F;&#x2F;当iCloud中的文件变化时候调用\n    func updateUbiquitousDocuments(notification : NSNotification) &#123;\n        &#x2F;&#x2F;文件存在\n        if self.query.results.count &#x3D;&#x3D; 1 &#123;\n            let ubiquityURL  &#x3D; self.query.results.last?.valueForAttribute(NSMetadataItemURLKey) as! NSURL\n            \n            self.myCloudDocument &#x3D; MyCloudDocument(fileURL: ubiquityURL)\n            self.myCloudDocument.openWithCompletionHandler(&#123; (success) -&gt; Void in\n                if success &#123;\n                    NSLog(&quot;%@ : 打开iCloud文档&quot;, DeviceName)\n                    if self.myCloudDocument.contents !&#x3D; nil &#123;\n                        self.txtContent.text &#x3D; self.myCloudDocument.contents as String\n                    &#125; else &#123;\n                        self.txtContent.text &#x3D;  &quot;&quot;\n                    &#125;\n                &#125;\n            &#125;)\n        &#125; else &#123; &#x2F;&#x2F;文件不存在\n            NSLog(&quot;文件不存在&quot;)\n            let documentiCloudPath &#x3D; self.ubiquitousDocumentsURL?.URLByAppendingPathComponent(&quot;abc.txt&quot;)\n            self.myCloudDocument &#x3D; MyCloudDocument(fileURL: documentiCloudPath!)\n            self.myCloudDocument.contents &#x3D; self.txtContent.text\n        &#125;\n        \n        if self.myCloudDocument !&#x3D; nil &#123;\n            &#x2F;&#x2F;注册CloudDocument对象到文档协调者，文档状态变化才能收到通知\n            NSFileCoordinator.addFilePresenter(self.myCloudDocument)\n        &#125;\n    &#125;\n    \n    @IBAction func saveClick(sender: AnyObject) &#123;\n        self.myCloudDocument.contents &#x3D; self.txtContent.text\n        self.myCloudDocument.updateChangeCount(UIDocumentChangeKind.Done)\n        self.txtContent.resignFirstResponder()\n    &#125;\n    \n    &#x2F;&#x2F;文档冲突解决\n    func resolveConflict(notification : NSNotification) &#123;\n        if self.myCloudDocument !&#x3D; nil\n            &amp;&amp; self.myCloudDocument.documentState &#x3D;&#x3D; UIDocumentState.InConflict &#123;\n            NSLog(&quot;冲突发生&quot;)\n            do &#123;\n                &#x2F;&#x2F;文档冲突解决策略\n                try NSFileVersion.removeOtherVersionsOfItemAtURL(self.myCloudDocument.fileURL)\n            &#125; catch _ &#123;\n            &#125;\n            \n            let conflictVersions &#x3D; NSFileVersion.unresolvedConflictVersionsOfItemAtURL(self.myCloudDocument.fileURL)\n            for item in conflictVersions! &#123;\n                let fileVersion &#x3D; item \n                NSLog(&quot;fileVersion.name &#x3D; %@&quot;,fileVersion.modificationDate!)\n                fileVersion.resolved &#x3D; true\n            &#125;\n            self.myCloudDocument.contents &#x3D; self.txtContent.text\n            self.myCloudDocument.updateChangeCount(UIDocumentChangeKind.Done)\n        &#125;\n        if self.myCloudDocument !&#x3D; nil &#123;\n            &#x2F;&#x2F;从文档协调者中解除CloudDocument对象\n            NSFileCoordinator.removeFilePresenter(self.myCloudDocument)\n        &#125;\n    &#125;\n    \n&#125;\n\n\n</code></pre>\n\n<p>获取iCloud文档目录</p>\n<pre class=\"line-numbers language-swift\" data-language=\"swift\"><code class=\"language-swift\">\n</code></pre>\n<p>查找Ubiquity 容器中的文档</p>\n<pre class=\"line-numbers language-swift\" data-language=\"swift\"><code class=\"language-swift\">\n</code></pre>\n<p>iCloud中的文件变化处理</p>\n<pre class=\"line-numbers language-swift\" data-language=\"swift\"><code class=\"language-swift\">\n</code></pre>\n<p>保存文档</p>\n<pre class=\"line-numbers language-swift\" data-language=\"swift\"><code class=\"language-swift\">\n</code></pre>\n<p>解决文档冲突</p>\n<pre class=\"line-numbers language-swift\" data-language=\"swift\"><code class=\"language-swift\">\n</code></pre>\n\n\n\n\n<p>#iCloud Core Data 技术<br>把一个文档保存在iCloud服务器端,文档的数据结构比较筒单,数据量也比较少，如果数据结构比较复杂，而是数据量相对大一些，再使用简单的数据结构文件就不能瞒住需求了,,可以考虑使用SQLite数据库,但是SQLite 是低级别数据持久化技术,而Core Data 是高级别的持久化技术,现在Core Data 可以借助于iCloud 技术奖户籍存到iCloud 服务中.</p>\n<p>##iCloud Core Data  实例<br>配置项目<br>iCloud Core Data 是基于iCloud 文档存储<br>Capablities&gt;iCloud&gt;iCloud Documents<br><code>CoreDataDAO.swift</code></p>\n<pre class=\"line-numbers language-swift\" data-language=\"swift\"><code class=\"language-swift\">import Foundation\nimport CoreData\n\nclass CoreDataDAO: NSObject &#123;\n    \n    override init() &#123;\n        super.init()\n        \n        NSNotificationCenter.defaultCenter().addObserver(self ,\n            selector: #selector(CoreDataDAO.contentDidChange(_:)),\n            name:NSPersistentStoreDidImportUbiquitousContentChangesNotification,\n            object: self.persistentStoreCoordinator)\n    &#125;\n    \n    deinit &#123;\n        NSNotificationCenter.defaultCenter().removeObserver(self)\n    &#125;\n    \n    &#x2F;&#x2F; 返回应用程序Docment目录的NSURL类型\n    lazy var applicationDocumentsDirectory: NSURL &#x3D; &#123;\n        let urls &#x3D; NSFileManager.defaultManager().URLsForDirectory(.DocumentDirectory, inDomains: .UserDomainMask)\n        return urls[urls.count-1] \n    &#125;()\n    \n    &#x2F;&#x2F; MARK: - Core Data 堆栈\n    &#x2F;&#x2F;返回 被管理的对象上下文\n    lazy var managedObjectContext: NSManagedObjectContext? &#x3D; &#123;\n        let coordinator &#x3D; self.persistentStoreCoordinator\n        if coordinator &#x3D;&#x3D; nil &#123;\n            return nil\n        &#125;\n        var managedObjectContext &#x3D; NSManagedObjectContext(concurrencyType: NSManagedObjectContextConcurrencyType.MainQueueConcurrencyType)\n        managedObjectContext.persistentStoreCoordinator &#x3D; coordinator\n        &#x2F;&#x2F;合并策略\n        managedObjectContext.mergePolicy &#x3D; NSMergeByPropertyObjectTrumpMergePolicy\n        return managedObjectContext\n    &#125;()\n    \n    &#x2F;&#x2F; 返回 持久化存储协调者\n    lazy var persistentStoreCoordinator: NSPersistentStoreCoordinator? &#x3D; &#123;\n        var coordinator: NSPersistentStoreCoordinator? &#x3D; NSPersistentStoreCoordinator(managedObjectModel: self.managedObjectModel)\n        let url &#x3D; self.applicationDocumentsDirectory.URLByAppendingPathComponent(&quot;CoreDataNotes.sqlite&quot;)\n        var error: NSError? &#x3D; nil\n        var failureReason &#x3D; &quot;There was an error creating or loading the application&#39;s saved data.&quot;\n        \n        \n        do &#123;\n            \n          let  x &#x3D; try coordinator?.addPersistentStoreWithType(NSSQLiteStoreType, configuration: nil, URL: url, options: self.iCloudPersistentStoreOptions)\n        &#125;catch &#123;\n        \n            coordinator &#x3D; nil\n            &#x2F;&#x2F; Report any error we got.\n            var dict &#x3D; [String: AnyObject]()\n            \n            dict[NSLocalizedDescriptionKey] &#x3D; &quot;Failed to initialize the application&#39;s saved data&quot;\n            dict[NSLocalizedFailureReasonErrorKey] &#x3D; failureReason\n            dict[NSUnderlyingErrorKey] &#x3D; error as NSError\n            print(&quot;Unresolved error \\(error), \\((error as NSError).userInfo)&quot;)\n            abort()\n\n        &#125;\n        \n        \n        \n&#x2F;&#x2F;        if coordinator!.addPersistentStoreWithType(NSSQLiteStoreType, configuration: nil, URL: url, options: self.iCloudPersistentStoreOptions, error: &amp;error) &#x3D;&#x3D; nil &#123;\n&#x2F;&#x2F;            coordinator &#x3D; nil\n&#x2F;&#x2F;            &#x2F;&#x2F; Report any error we got.\n&#x2F;&#x2F;            var dict &#x3D; [String: AnyObject]()\n&#x2F;&#x2F;            \n&#x2F;&#x2F;            dict[NSLocalizedDescriptionKey] &#x3D; &quot;Failed to initialize the application&#39;s saved data&quot;\n&#x2F;&#x2F;            dict[NSLocalizedFailureReasonErrorKey] &#x3D; failureReason\n&#x2F;&#x2F;            dict[NSUnderlyingErrorKey] &#x3D; error\n&#x2F;&#x2F;            error &#x3D; NSError(domain: &quot;51work6.com&quot;, code: 9999, userInfo: dict)\n&#x2F;&#x2F;            print(&quot;Unresolved error \\(error), \\(error!.userInfo)&quot;)\n&#x2F;&#x2F;            abort()\n&#x2F;&#x2F;        &#125;\n        \n        return coordinator\n    &#125;()\n    \n    &#x2F;&#x2F;  返回 被管理的对象模型\n    lazy var managedObjectModel: NSManagedObjectModel &#x3D; &#123;\n        let modelURL &#x3D; NSBundle.mainBundle().URLForResource(&quot;CoreDataNotes&quot;, withExtension: &quot;momd&quot;)!\n        return NSManagedObjectModel(contentsOfURL: modelURL)!\n    &#125;()\n\n    \n    &#x2F;&#x2F;使用这些配置\n    var iCloudPersistentStoreOptions &#x3D; &#123;\n        return [NSPersistentStoreUbiquitousContentNameKey: &quot;iCloudMyNotesApp&quot;]\n    &#125;()\n    \n    func contentDidChange(notification : NSNotification) &#123;\n\n        NSLog(&quot;%@&quot;, notification.userInfo!.description)\n        \n        self.managedObjectContext?.mergeChangesFromContextDidSaveNotification(notification)\n        \n        &#x2F;&#x2F;投送通知更新UI\n        dispatch_async(dispatch_get_main_queue(), &#123; () -&gt; Void in\n            NSNotificationCenter.defaultCenter().postNotificationName(&quot;reloadViewNotification&quot;, object: nil)\n        &#125;)\n    &#125;\n    \n&#125;</code></pre>\n\n<p>#iCloudKit 存储编程</p>\n<p>iOS 8 推出了CloudKit 存储,并提供了一套API用来开发.此外提供了一个iCloud服务器Web 管理工具 — iCloud Dashboard(iCloud 仪表盘)</p>\n<p>在介绍CloudKit编程之前，有必要介绍一下CloudKit中的一些术语：</p>\n<ul>\n<li>容器：是应用的iCloud容器存储空间名字，在CloudKit容器类是CKContainer类。 </li>\n<li>数据库：iCloud容器中存储数据的区域，被分为两个数据库—公有数据库和私有数据库，公有数据库是所有用户都能访问的数据,而私有数据库只能允许用户自己访问。在CloudKit数据库类是CKDatabase类。</li>\n<li>记录类型（Record Type):相当于关系数据库中的表。 </li>\n<li>记录(Record) :相当于数据表中记录。在CloudKit数据库类是CKRecord类。 </li>\n<li>数据类型：记录（Record)中的字段是有数据类型的，他们分为database和asset两<br>种。database数据是一般的字符、数字、日期时间和地理经纬度坐标等类型；asset类型是用来存储图片、声音、视频等二进制数据。 </li>\n</ul>\n<p>iCloud Dashboard </p>\n<p>为了管理iCloud服务器，苹果提供了iCloud Dashboard的Web管理工具,可以通过网站<a href=\"https://icloud.developer.apple.com/dashboard/\">https://icloud.developer.apple.com/dashboard/</a>访问 或者在Xcodezhong 的CloudKit Dashboard按钮访问.</p>\n<p><img src=\"\"></p>\n<p>iCloud Dashboard左边导航菜单中有一些概念:</p>\n<ul>\n<li>Schema(模式):数据库对象的集合,iCloud中包含Record Type(记录类型),Security Role(安全角色）和Subscription Types(订阅类型).Record Type 可以管理记录类型,就是数据表; Security Roles定义角色，提供安全访问管理；Subscription Types可以订阅数据变化的通知。 </li>\n<li>Public Data: 公共数据库，其中包含User Records(用户记录),Default Zone(默认控件)和 Usage(用量)。User Records查看Users表中的数据，Users表的数据是由iCloud管理和维护的，开发人<br>员不能删除他们；Default Zone查看公共数据库表中数据。Usage提供了数据访问的统计报告。 </li>\n<li>Private Data:私有数据库，其中Default Zone查看私有数据库表中数据。需要注意的是，如果当前账户下没有任何数据，这个导航菜单是看不到的。 </li>\n<li>Admin:管理员功能，Team当需要多人协同开发一个项目时候，为他们提供一个统 一的访问权限。Deployment可以查看Schema修改日志；可以重新初始化开发环境;发布数据库。 </li>\n<li>Environment:切换Development(开发环境）和Production(产品环境）。 </li>\n</ul>\n<p>##CloudKit 实现实例</p>\n<p>Capabilities &gt; 开启iCloud &gt; CloudKit &gt; User default container </p>\n<p>iCloud 创建数据库<br>选择刚刚创建App对应的iCloud容器<br>Schema&gt;Record Types ,点击+ 创建表,填写表名 和 字段</p>\n<p><code>NoteDAO.swift</code></p>\n<pre class=\"line-numbers language-swift\" data-language=\"swift\"><code class=\"language-swift\">import Foundation\nimport CloudKit\n\nclass NoteDAO &#123;\n    &#x2F;&#x2F;定义iCloud 容器\n    var container : CKContainer!\n    &#x2F;&#x2F;定义database属性\n    var database :  CKDatabase!\n    &#x2F;&#x2F;单例类方法\n    class var sharedInstance: NoteDAO &#123;\n        struct Static &#123;\n            static var instance: NoteDAO?\n            static var token: dispatch_once_t &#x3D; 0\n        &#125;\n        \n        dispatch_once(&amp;Static.token) &#123;\n            \n            let dao &#x3D; NoteDAO()\n            dao.container &#x3D; CKContainer.defaultContainer()  &#x2F;&#x2F;获得容器对象\n            dao.database &#x3D; dao.container.publicCloudDatabase &#x2F;&#x2F; 获取共有数据库对象\n                              &#x2F;&#x2F;container.privateCloudDatabase  &#x2F;&#x2F; 获取私有数据库对象\n            \n            Static.instance &#x3D; dao\n            \n        &#125;\n        return Static.instance!\n    &#125;\n    \n    &#x2F;&#x2F;插入Note方法\n    func create(model: Note) -&gt; Int &#123;\n        &#x2F;&#x2F;创建名为&quot;Note&quot;的数据库表记录\n        let record &#x3D; CKRecord(recordType: &quot;Note&quot;)\n        &#x2F;&#x2F;给记录设置 内容\n        record.setObject(model.content, forKey: &quot;content&quot;)\n        &#x2F;&#x2F;给记录设置内容\n        record.setObject(model.date, forKey: &quot;date&quot;)\n        &#x2F;&#x2F;数据库将记录对象插入到iCloud存储空间\n        self.database.saveRecord(record, completionHandler: &#123; (recd, error) -&gt; Void in\n            if error !&#x3D; nil &#123;\n                print(&quot;error:\\(error)&quot; )\n            &#125; else &#123;\n                print(&quot;插入数据成功。&quot;)\n            &#125;\n        &#125;)\n        \n        return 0\n    &#125;\n    \n    &#x2F;&#x2F;删除Note方法\n    func remove(model: Note) -&gt; Int &#123;\n        &#x2F;&#x2F;创建一个data查询条件对象\n        let predicate &#x3D; NSPredicate(format: &quot;date &#x3D; %@&quot;, model.date)\n        &#x2F;&#x2F;查询对象\n        let query &#x3D; CKQuery(recordType: &quot;Note&quot;, predicate: predicate)\n        &#x2F;&#x2F;查询操作\n        let queryOperation &#x3D; CKQueryOperation(query: query)\n        &#x2F;&#x2F;设置recordFetchedBlock回调属性,查询结果返回的回调,根据查询记录的个数调用多次\n        &#x2F;&#x2F;record 就是被查询到的记录\n        queryOperation.recordFetchedBlock &#x3D; &#123; record in\n            &#x2F;&#x2F;将从iCloud存储空间删除,根据ID进行删除.\n            self.database.deleteRecordWithID(record.recordID, completionHandler: &#123; (recd, error) -&gt; Void in\n                if error !&#x3D; nil &#123;\n                    print(&quot;error: %@&quot;, error)\n                &#125; else &#123;\n                    print(&quot;删除数据成功。&quot;)\n                &#125;\n            &#125;)\n        &#125;\n        &#x2F;&#x2F;执行查询操作\n        self.database.addOperation(queryOperation)\n        \n        return 0\n    &#125;\n    \n    &#x2F;&#x2F;修改Note方法\n    func modify(model: Note) -&gt; Int &#123;\n        \n        let predicate &#x3D; NSPredicate(format: &quot;date &#x3D; %@&quot;, model.date)\n        let query &#x3D; CKQuery(recordType: &quot;Note&quot;, predicate: predicate)\n        &#x2F;&#x2F;查询操作\n        let queryOperation &#x3D; CKQueryOperation(query: query)\n        &#x2F;&#x2F;查询完以后,进行修改操作\n        queryOperation.recordFetchedBlock &#x3D; &#123; record in\n            record.setObject(model.content, forKey: &quot;content&quot;)\n            &#x2F;&#x2F;修改操作\n            let modifyOperation &#x3D; CKModifyRecordsOperation(recordsToSave: [record], recordIDsToDelete: nil)\n            &#x2F;&#x2F;执行修改回调\n            modifyOperation.perRecordCompletionBlock &#x3D; &#123; (recd, error) -&gt; Void in\n                if error !&#x3D; nil &#123;\n                    print(&quot;error: %@&quot;, error)\n                &#125; else &#123;\n                    print(&quot;修改数据成功。&quot;)\n                &#125;\n            &#125;\n            &#x2F;&#x2F;执行修改操作\n            self.database.addOperation(modifyOperation)\n        &#125;\n        &#x2F;&#x2F;执行查询操作\n        self.database.addOperation(queryOperation)\n        \n        return 0\n    &#125;\n    \n    &#x2F;&#x2F;查询所有数据方法\n    func findAll() &#123;\n        \n        let listData &#x3D; NSMutableArray()\n        &#x2F;&#x2F;无条件的对象\n        let predicate &#x3D; NSPredicate(value: true)&#x2F;&#x2F;不设置查询条件\n        let query &#x3D; CKQuery(recordType: &quot;Note&quot;, predicate: predicate)\n        query.sortDescriptors &#x3D; [NSSortDescriptor(key: &quot;date&quot;, ascending: true)]\n        \n        &#x2F;&#x2F;初始化QueryOperation\n        let queryOperation &#x3D; CKQueryOperation(query: query)\n        &#x2F;&#x2F;当提取数据时候设置\n        queryOperation.recordFetchedBlock &#x3D; &#123; record in\n            let content &#x3D; record.objectForKey(&quot;content&quot;) as! String\n            let date &#x3D; record.objectForKey(&quot;date&quot;) as! NSDate\n\n            let note &#x3D; Note(date: date, content:content)\n            listData.addObject(note)\n        &#125;\n    \n        queryOperation.queryCompletionBlock &#x3D; &#123; (cursor, error) in\n            if error !&#x3D; nil &#123;\n                print(&quot;error: %@&quot;, error)\n            &#125; else &#123;\n                &#x2F;&#x2F;投送通知更新UI\n                dispatch_async(dispatch_get_main_queue(), &#123; () -&gt; Void in\n                    NSNotificationCenter.defaultCenter().postNotificationName(&quot;reloadViewNotification&quot;, object: listData)\n                &#125;)\n            &#125;\n        &#125;\n        \n        &#x2F;&#x2F;执行查询操作\n        self.database.addOperation(queryOperation)\n\n    &#125;\n    \n    &#x2F;&#x2F;按照主键查询数据方法\n    func findById(model: Note)  &#123;\n        \n        var note : Note!\n        \n        let predicate &#x3D; NSPredicate(value: true)&#x2F;&#x2F;不设置查询条件\n        let query &#x3D; CKQuery(recordType: &quot;Note&quot;, predicate: predicate)\n        query.sortDescriptors &#x3D; [NSSortDescriptor(key: &quot;date&quot;, ascending: true)]\n        \n        &#x2F;&#x2F;初始化QueryOperation\n        let queryOperation &#x3D; CKQueryOperation(query: query)\n        &#x2F;&#x2F;当提取数据时候设置\n        queryOperation.recordFetchedBlock &#x3D; &#123; record in\n            let content &#x3D; record.objectForKey(&quot;content&quot;) as! String\n            let date &#x3D; record.objectForKey(&quot;date&quot;) as! NSDate\n            \n            note &#x3D; Note(date: date, content:content)\n        &#125;\n        \n        queryOperation.queryCompletionBlock &#x3D; &#123; (cursor, error) in\n            if error !&#x3D; nil &#123;\n                print(&quot;error: %@&quot;, error)\n            &#125; else &#123;\n                &#x2F;&#x2F;投送通知更新UI\n            &#125;\n        &#125;\n        \n        &#x2F;&#x2F;执行查询操作\n        self.database.addOperation(queryOperation)\n\n    &#125;\n    \n&#125;\n</code></pre>\n","text":"#iCloud简介 iCloud 是苹果”云战略”的重要棋子，iCloud是苹果的云服务技术。它的重点是提供数据的存储服务，苹果给每个用户免费提供5GB的云服务空间。如果不够，用户可以付费购买更多的空间。苹果公司斥资 10亿美元在北卡罗莱纳州建设新数据中心-iDataCenter...","link":"","photos":[],"count_time":{"symbolsCount":"24k","symbolsTime":"22 mins."},"categories":[{"name":"iOS SDK","slug":"iOS-SDK","count":18,"path":"api/categories/iOS-SDK.json"}],"tags":[{"name":"iCloud","slug":"iCloud","count":1,"path":"api/tags/iCloud.json"}],"toc":"","author":{"name":"William Xie","slug":"blog-author","avatar":"/img/author.png","link":"/","description":"","socials":{"github":"https://github.com/williamxiewz","twitter":"https://twitter.com/williamxie_wz","stackoverflow":"http://stackoverflow.com/users/4078104/goingxiebin-jobs","wechat":"","qq":"","weibo":"https://weibo.com/u/2281381063","zhihu":"https://www.zhihu.com/people/williamxiewz","csdn":"https://blog.csdn.net/u014222645","juejin":"https://juejin.cn/user/3280598430133277","customs":{}}},"mapped":true,"prev_post":{"title":"iOS App上架流程","uid":"0be78fce7ff14abe5dd400a8b201abea","slug":"iOS-App-上架流程","date":"2016-08-08T14:16:57.000Z","updated":"2019-05-14T04:53:34.000Z","comments":true,"path":"api/articles/iOS-App-上架流程.json","keywords":null,"cover":[],"text":"准备条件: 1.一个已付费的开发者账号（账号类型分为个人（Individual）、公司（Company）、企业（Enterprise）、高校（University）四种类型，每年资费分别为$99、$99、$299、免费。）。2.你的Xcode必须是正式版的. 打开苹果开发者中心：...","link":"","photos":[],"count_time":{"symbolsCount":"3.2k","symbolsTime":"3 mins."},"categories":[{"name":"iOS SDK","slug":"iOS-SDK","count":18,"path":"api/categories/iOS-SDK.json"}],"tags":[{"name":"iOS上架App Store","slug":"iOS上架App-Store","count":1,"path":"api/tags/iOS上架App-Store.json"}],"author":{"name":"William Xie","slug":"blog-author","avatar":"/img/author.png","link":"/","description":"","socials":{"github":"https://github.com/williamxiewz","twitter":"https://twitter.com/williamxie_wz","stackoverflow":"http://stackoverflow.com/users/4078104/goingxiebin-jobs","wechat":"","qq":"","weibo":"https://weibo.com/u/2281381063","zhihu":"https://www.zhihu.com/people/williamxiewz","csdn":"https://blog.csdn.net/u014222645","juejin":"https://juejin.cn/user/3280598430133277","customs":{}}}},"next_post":{"title":"Handoff 编程","uid":"e22bf8154724897227d91eac96e617a1","slug":"Handoff-编程","date":"2016-08-08T13:41:38.000Z","updated":"2019-05-14T04:53:36.000Z","comments":true,"path":"api/articles/Handoff-编程.json","keywords":null,"cover":[],"text":" #Handoff技术介绍 Handoff是苹果“融合”主题中的重要元素之一，同时也是iOS8和OS X Yosemite中新的“Continuity”特征集的一部分。“Continuity”功能包含了能跨平台兼容的AirDrop、可在iPad和Mac上拨打iPhone电话和处理...","link":"","photos":[],"count_time":{"symbolsCount":"17k","symbolsTime":"15 mins."},"categories":[{"name":"iOS SDK","slug":"iOS-SDK","count":18,"path":"api/categories/iOS-SDK.json"}],"tags":[{"name":"Handoff","slug":"Handoff","count":3,"path":"api/tags/Handoff.json"}],"author":{"name":"William Xie","slug":"blog-author","avatar":"/img/author.png","link":"/","description":"","socials":{"github":"https://github.com/williamxiewz","twitter":"https://twitter.com/williamxie_wz","stackoverflow":"http://stackoverflow.com/users/4078104/goingxiebin-jobs","wechat":"","qq":"","weibo":"https://weibo.com/u/2281381063","zhihu":"https://www.zhihu.com/people/williamxiewz","csdn":"https://blog.csdn.net/u014222645","juejin":"https://juejin.cn/user/3280598430133277","customs":{}}}}}