{"title":"什么是I帧,P帧,B帧","uid":"99c5f55389acbd9de2b2a8aa78d3843c","slug":"什么是I帧-P帧-B帧","date":"2016-09-07T05:53:44.000Z","updated":"2019-05-14T04:53:25.000Z","comments":true,"path":"api/articles/什么是I帧-P帧-B帧.json","keywords":null,"cover":[],"content":"<p><a href=\"https://zh.wikipedia.org/wiki/H.264/MPEG-4_AVC\">H.264</a>是新一代的编码标准，以高压缩高质量和支持多种网络的流媒体传输著称，在编码方面，我理解的他的理论依据是：</p>\n<p>参照一段时间内图像的统计结果表明，在相邻几幅图像画面中，一般有差别的像素只有10%以内的点,亮度差值变化不超过2%，而色度差值的变化只有1%以内。所以对于一段变化不大图像画面，我们可以先编码出一个完整的图像帧A，随后的B帧就不编码全部图像，只写入与A帧的差别，这样B帧的大小就只有完整帧的1/10或更小！B帧之后的C帧如果变化不大，我们可以继续以参考B的方式编码C帧，这样循环下去。这段图像我们称为一个序列（序列就是有相同特点的一段数据），当某个图像与之前的图像变化很大，无法参考前面的帧来生成，那我们就结束上一个序列，开始下一段序列，也就是对这个图像生成一个完整帧A1，随后的图像就参考A1生成，只写入与A1的差别内容。</p>\n<p>在H.264协议里定义了三种帧:</p>\n<ul>\n<li>完整编码的帧叫I帧，I帧是<code>关键帧</code>；</li>\n<li>参考之前的I帧生成的只包含<code>差异部分编码</code>的帧叫P帧，P帧是<code>前向差别帧</code>；</li>\n<li>还有一种参考<code>前后的帧编码</code>的帧叫B帧，B帧是<code>双向差别帧</code>。</li>\n</ul>\n<p>H.264采用的核心算法是<code>帧内压缩</code>和<code>帧间压缩</code>，帧内压缩是生成I帧的算法，帧间压缩是生成B帧和P帧的算法。</p>\n<span id=\"more\"></span>\n<p>#三种帧的说明</p>\n<p>I帧:<code>帧内编码帧</code> ，I帧表示关键帧，你可以理解为这一帧画面的完整保留；解码时只需要本帧数据就可以完成（因为包含完整画面）</p>\n<p>I帧特点:<br>1.它是一个全帧压缩编码帧。它将全帧图像信息进行JPEG压缩编码及传输;<br>2.解码时仅用I帧的数据就可重构完整图像;<br>3.I帧描述了图像背景和运动主体的详情;<br>4.I帧不需要参考其他画面而生成;<br>5.I帧是P帧和B帧的参考帧(其质量直接影响到同组中以后各帧的质量);<br>6.I帧是帧组GOP的基础帧(第一帧),在一组中只有一个I帧;<br>7.I帧不需要考虑运动矢量;<br>8.I帧所占数据的信息量比较大。</p>\n<p>P帧:<code>前向预测编码帧</code>。P帧表示的是这一帧跟之前的一个关键帧（或P帧）的差别，解码时需要用之前缓存的画面叠加上本帧定义的差别，生成最终画面。（也就是差别帧，P帧没有完整画面数据，只有与前一帧的画面差别的数据）</p>\n<p>P帧的预测与重构:P帧是以I帧为参考帧,在I帧中找出P帧“某点”的预测值和运动矢量,取预测差值和运动矢量一起传送。在接收端根据运动矢量从I帧中找出P帧“某点”的预测值并与差值相加以得到P帧“某点”样值,从而可得到完整的P帧。</p>\n<p>P帧特点:<br>1.P帧是I帧后面相隔1~2帧的编码帧;<br>2.P帧采用运动补偿的方法传送它与前面的I或P帧的差值及运动矢量(预测误差);<br>3.解码时必须将I帧中的预测值与预测误差求和后才能重构完整的P帧图像;<br>4.P帧属于前向预测的帧间编码。它只参考前面最靠近它的I帧或P帧;<br>5.P帧可以是其后面P帧的参考帧,也可以是其前后的B帧的参考帧;<br>6.由于P帧是参考帧,它可能造成解码错误的扩散;<br>7.由于是差值传送,P帧的压缩比较高。</p>\n<p>B帧:<code>双向预测内插编码帧</code>。B帧是双向差别帧，也就是B帧记录的是本帧与前后帧的差别（具体比较复杂，有4种情况，但我这样说简单些），换言之，要解码B帧，不仅要取得之前的缓存画面，还要解码之后的画面，通过前后画面的与本帧数据的叠加取得最终的画面。B帧压缩率高，但是解码时CPU会比较累。</p>\n<p>B帧的预测与重构</p>\n<p>B帧以<code>前面的I或P帧</code>和<code>后面的P帧</code>为参考帧,“找出”B帧“某点”的预测值和两个运动矢量,并取预测差值和运动矢量传送。接收端根据运动矢量在两个参考帧中“找出(算出)”预测值并与差值求和,得到B帧“某点”样值,从而可得到完整的B帧。</p>\n<p>B帧特点<br>1.B帧是由前面的I或P帧和后面的P帧来进行预测的;<br>2.B帧传送的是它与前面的I或P帧和后面的P帧之间的预测误差及运动矢量;<br>3.B帧是双向预测编码帧;<br>4.B帧压缩比最高,因为它只反映丙参考帧间运动主体的变化情况,预测比较准确;<br>5.B帧不是参考帧,不会造成解码错误的扩散。</p>\n<p>注:I、B、P各帧是根据压缩算法的需要，是人为定义的,它们都是实实在在的物理帧。一般来说，I帧的压缩率是7（跟JPG差不多），P帧是20，B帧可以达到50。可见使用B帧能节省大量空间，节省出来的空间可以用来保存多一些I帧，这样在相同码率下，可以提供更好的画质。</p>\n<p>#序列的说明</p>\n<p>在H.264中图像以序列为单位进行组织，一个序列是一段图像编码后的数据流，以I帧开始，到下一个I帧结束。</p>\n<p>一个序列的第一个图像叫做 IDR 图像（立即刷新图像），IDR 图像都是 I 帧图像。H.264 引入 IDR 图像是为了解码的重同步，当解码器解码到 IDR 图像时，立即将参考帧队列清空，将已解码的数据全部输出或抛弃，重新查找参数集，开始一个新的序列。这样，如果前一个序列出现重大错误，在这里可以获得重新同步的机会。IDR图像之后的图像永远不会使用IDR之前的图像的数据来解码。</p>\n<p>一个序列就是一段内容差异不太大的图像编码后生成的一串数据流。当运动变化比较少时，一个序列可以很长，因为运动变化少就代表图像画面的内容变动很小，所以就可以编一个I帧，然后一直P帧、B帧了。当运动变化多时，可能一个序列就比较短了，比如就包含一个I帧和3、4个P帧。</p>\n<p>视频压缩中，每帧代表一幅静止的图像。而在实际压缩时，会采取各种算法减少数据的容量，其中IPB就是最常见的。</p>\n<p>简单地说，I帧是关键帧，属于帧内压缩。就是和AVI的压缩是一样的。 P是向前搜索的意思。B是双向搜索。他们都是基于I帧来压缩数据。</p>\n<p>从上面的解释看，我们知道I和P的解码算法比较简单，资源占用也比较少，I只要自己完成就行了，P呢，也只需要解码器把前一个画面缓存一下，遇到P时就使用之前缓存的画面就好了，如果视频流只有I和P，解码器可以不管后面的数据，边读边解码，线性前进，大家很舒服。</p>\n<p>但网络上的电影很多都采用了B帧，因为B帧记录的是前后帧的差别，比P帧能节约更多的空间，但这样一来，文件小了，解码器就麻烦了，因为在解码时，不仅要用之前缓存的画面，还要知道下一个I或者P的画面（也就是说要预读预解码），而且，B帧不能简单地丢掉，因为B帧其实也包含了画面信息，如果简单丢掉，并用之前的画面简单重复，就会造成画面卡（其实就是丢帧了），并且由于网络上的电影为了节约空间，往往使用相当多的B帧，B帧用的多，对不支持B帧的播放器就造成更大的困扰，画面也就越卡。</p>\n<p>一般平均来说，I的压缩率是7（跟JPG差不多），P是20，B可以达到50，可见使用B帧能节省大量空间，节省出来的空间可以用来保存多一些I帧，这样在相同码率下，可以提供更好的画质。</p>\n<p>下面举例说明：<br><img src=\"https://github.com/williamxiewz/williamxie-github-io/raw/master/ipbframe1.jpg\"></p>\n<p>在如上图中，GOP (Group of Pictures)长度为13，S0<del>S7 表示 8个视点，T0</del>T12 为 GOP的 13个时刻。每个 GOP包含帧数为视点数 GOP 长度的乘积。在该图中一个 GOP 中，包含94 个 B帧。B 帧占一个 GOP 总帧数的 90.38%。GOP 越长，B 帧所占比例更高，编码的率失真性能越高。下图测试序列 Race1 在不同 GOP 下的率失真性能对比。</p>\n<p><img src=\"https://github.com/williamxiewz/williamxie-github-io/raw/master/ipbframe2.jpg\"></p>\n<p>率失真理论是用信息论的基本观点和方法研究数据压缩问题的理论，又称限失真信源编码理论。率失真理论的基本问题可以归结如下：对于一个给定的信源分布与失真度量，在特定的码率下能达到的最小期望失真；或者为了满足一定的失真限制，最小描述码率可以是多少。</p>\n<p>率失真理论的名称来源于信息速率失真函数，率失真理论包含两个中心内容：一是率失真函数或失真率函数，二是限失真编码定理。这就是针对不同的信源．不同的失真量度和不同信源概率分布计算率失真函数和证明相应的限失真编码定理。</p>\n<p>#压缩算法的说明</p>\n<p>h264的压缩方法:</p>\n<p>1.分组:把几帧图像分为一组(GOP，也就是一个序列),为防止运动变化,帧数不宜取多。</p>\n<p>2.定义帧:将每组内各帧图像定义为三种类型,即I帧、B帧和P帧;</p>\n<p>3.预测帧:以I帧做为基础帧,以I帧预测P帧,再由I帧和P帧预测B帧;</p>\n<p>4.数据传输:最后将I帧数据与预测的差值信息进行存储和传输。</p>\n<p>帧内（Intraframe）压缩也称为空间压缩（Spatial compression）。当压缩一帧图像时，仅考虑本帧的数据而不考虑相邻帧之间的冗余信息，这实际上与静态图像压缩类似。帧内一般采用有损压缩算法，由于帧内压缩是编码一个完整的图像，所以可以独立的解码、显示。帧内压缩一般达不到很高的压缩，跟编码jpeg差不多。<br>　　<br>帧间（Interframe）压缩的原理是：相邻几帧的数据有很大的相关性，或者说前后两帧信息变化很小的特点。也即连续的视频其相邻帧之间具有冗余信息,根据这一特性，压缩相邻帧之间的冗余量就可以进一步提高压缩量，减小压缩比。帧间压缩也称为时间压缩（Temporal compression），它通过比较时间轴上不同帧之间的数据进行压缩。帧间压缩一般是无损的。帧差值（Frame differencing）算法是一种典型的时间压缩法，它通过比较本帧与相邻帧之间的差异，仅记录本帧与其相邻帧的差值，这样可以大大减少数据量。</p>\n<p>顺便说下有损（Lossy ）压缩和无损（Lossy less）压缩。无损压缩也即压缩前和解压缩后的数据完全一致。多数的无损压缩都采用RLE行程编码算法。有损压缩意味着解压缩后的数据与压缩前的数据不一致。在压缩的过程中要丢失一些人眼和人耳所不敏感的图像或音频信息,而且丢失的信息不可恢复。几乎所有高压缩的算法都采用有损压缩,这样才能达到低数据率的目标。丢失的数据率与压缩比有关,压缩比越小，丢失的数据越多,解压缩后的效果一般越差。此外,某些有损压缩算法采用多次重复压缩的方式,这样还会引起额外的数据丢失。</p>\n<p><a href=\"http://blog.csdn.net/abcjennifer/article/details/6577934\">http://blog.csdn.net/abcjennifer/article/details/6577934</a></p>\n<p><a href=\"http://blog.sina.com.cn/s/blog_8fb8cd4801018yyo.html\">http://blog.sina.com.cn/s/blog_8fb8cd4801018yyo.html</a></p>\n","text":"H.264是新一代的编码标准，以高压缩高质量和支持多种网络的流媒体传输著称，在编码方面，我理解的他的理论依据是： 参照一段时间内图像的统计结果表明，在相邻几幅图像画面中，一般有差别的像素只有10%以内的点,亮度差值变化不超过2%，而色度差值的变化只有1%以内。所以对于一段变化不大...","link":"","photos":[],"count_time":{"symbolsCount":"4.1k","symbolsTime":"4 mins."},"categories":[{"name":"音视频开发","slug":"音视频开发","count":6,"path":"api/categories/音视频开发.json"}],"tags":[{"name":"H.264","slug":"H-264","count":1,"path":"api/tags/H-264.json"}],"toc":"","author":{"name":"William Xie","slug":"blog-author","avatar":"/img/author.png","link":"/","description":"","socials":{"github":"https://github.com/williamxiewz","twitter":"https://twitter.com/williamxie_wz","stackoverflow":"http://stackoverflow.com/users/4078104/goingxiebin-jobs","wechat":"","qq":"","weibo":"https://weibo.com/u/2281381063","zhihu":"https://www.zhihu.com/people/williamxiewz","csdn":"https://blog.csdn.net/u014222645","juejin":"https://juejin.cn/user/3280598430133277","customs":{}}},"mapped":true,"prev_post":{"title":"移动端直播应用的开发流程","uid":"d5c815160e8fec6a4b0bd832cd6d3ef9","slug":"移动端直播应用的开发流程","date":"2016-09-07T12:01:52.000Z","updated":"2016-09-08T10:00:56.000Z","comments":true,"path":"api/articles/移动端直播应用的开发流程.json","keywords":null,"cover":null,"text":"#推流端 推流,就是将采集到的音频,视频数据通过流媒体协议发送到流媒体服务器。 ##一、选择流媒体协议 现在直播应用，采用RTMP协议居多，也有部分使用HLS协议。 采用RTMP协议，就要看下它与流媒体服务器交互的过程，RTMP协议的默认端口是1935，采用TCP协议。并且需要了...","link":"","photos":[],"count_time":{"symbolsCount":"1.1k","symbolsTime":"1 mins."},"categories":[{"name":"音视频开发","slug":"音视频开发","count":6,"path":"api/categories/音视频开发.json"}],"tags":[],"author":{"name":"William Xie","slug":"blog-author","avatar":"/img/author.png","link":"/","description":"","socials":{"github":"https://github.com/williamxiewz","twitter":"https://twitter.com/williamxie_wz","stackoverflow":"http://stackoverflow.com/users/4078104/goingxiebin-jobs","wechat":"","qq":"","weibo":"https://weibo.com/u/2281381063","zhihu":"https://www.zhihu.com/people/williamxiewz","csdn":"https://blog.csdn.net/u014222645","juejin":"https://juejin.cn/user/3280598430133277","customs":{}}}},"next_post":{"title":"硬编码和软编码","uid":"f98bfd8cdd720319e10a130f228835a6","slug":"硬编码和软编码","date":"2016-09-07T03:52:41.000Z","updated":"2016-09-07T03:55:07.000Z","comments":true,"path":"api/articles/硬编码和软编码.json","keywords":null,"cover":null,"text":"一、软编码和硬编码如何区分 软编码：使用CPU进行编码 硬编码：使用非CPU进行编码，如显卡GPU、专用的DSP、FPGA、ASIC芯片等 二、软编码和硬编码比较 软编码：实现直接、简单，参数调整方便，升级易，但CPU负载重，性能较硬编码低，低码率下质量通常比硬编码要好一点。 硬...","link":"","photos":[],"count_time":{"symbolsCount":508,"symbolsTime":"1 mins."},"categories":[{"name":"音视频开发","slug":"音视频开发","count":6,"path":"api/categories/音视频开发.json"}],"tags":[],"author":{"name":"William Xie","slug":"blog-author","avatar":"/img/author.png","link":"/","description":"","socials":{"github":"https://github.com/williamxiewz","twitter":"https://twitter.com/williamxie_wz","stackoverflow":"http://stackoverflow.com/users/4078104/goingxiebin-jobs","wechat":"","qq":"","weibo":"https://weibo.com/u/2281381063","zhihu":"https://www.zhihu.com/people/williamxiewz","csdn":"https://blog.csdn.net/u014222645","juejin":"https://juejin.cn/user/3280598430133277","customs":{}}}}}