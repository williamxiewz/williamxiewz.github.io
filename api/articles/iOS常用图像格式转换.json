{"title":"iOS常用图像格式转换","uid":"834d577630ee02b50ec7eb6df43a4285","slug":"iOS常用图像格式转换","date":"2017-10-24T08:20:00.000Z","updated":"2017-10-24T08:21:03.000Z","comments":true,"path":"api/articles/iOS常用图像格式转换.json","keywords":null,"cover":null,"content":"<p>在iOS多媒体开发时，需要经常转换图像格式以便调试。下面列了一些常用工具方法，在UIImage, CVPixelBufferRef,Texture之间完成格式转换。</p>\n<ol>\n<li>其他格式转为UIImage</li>\n</ol>\n<p>1.1 CVImageBufferRef (RGB)转为UIImage</p>\n<ul>\n<li>(UIImage *)imageFromRGBImageBuffer:(CVImageBufferRef)imageBuffer {<br>  CVPixelBufferLockBaseAddress(imageBuffer, 0);<br>  void *baseAddress = CVPixelBufferGetBaseAddress(imageBuffer);<br>  size_t bytesPerRow = CVPixelBufferGetBytesPerRow(imageBuffer);<br>  size_t width = CVPixelBufferGetWidth(imageBuffer);<br>  size_t height = CVPixelBufferGetHeight(imageBuffer);<br>  CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceRGB();<br>  CGContextRef context = CGBitmapContextCreate(baseAddress, width, height, 8,bytesPerRow, colorSpace, kCGBitmapByteOrder32Little | kCGImageAlphaPremultipliedFirst);<br>  CGImageRef quartzImage = CGBitmapContextCreateImage(context);<br>  CVPixelBufferUnlockBaseAddress(imageBuffer,0);<br>  CGContextRelease(context);<br>  CGColorSpaceRelease(colorSpace);<br>  UIImage *image = [UIImage imageWithCGImage:quartzImage];<br>  CGImageRelease(quartzImage);<br>  return (image);<br>}</li>\n</ul>\n<p>1.2 CVImageBufferRef (YUV)转为UIImage</p>\n<ul>\n<li>(UIImage *)imageFromYUVImageBuffer:(CVImageBufferRef)imageBuffer {<br>  CVPixelBufferLockBaseAddress(imageBuffer, 0);<br>  size_t bytesPerRow = CVPixelBufferGetBytesPerRowOfPlane(imageBuffer, 0);<br>  size_t width = CVPixelBufferGetWidthOfPlane(imageBuffer, 0);<br>  size_t height = CVPixelBufferGetHeightOfPlane(imageBuffer, 0);<br>  void *lumaAddress = CVPixelBufferGetBaseAddress(imageBuffer);<br>  CGColorSpaceRef rgbSpace = CGColorSpaceCreateDeviceGray();<br>  CGContextRef context = CGBitmapContextCreate(lumaAddress, width, height, 8, bytesPerRow, rgbSpace, kCGBitmapByteOrderDefault );<br>  CGImageRef imageRef = CGBitmapContextCreateImage(context);<br>  CGContextRelease(context);<br>  CVPixelBufferUnlockBaseAddress(imageBuffer, 0);<br>  UIImage *image = [UIImage imageWithCGImage:imageRef];<br>  CGImageRelease(imageRef);<br>  return image;<br>}</li>\n</ul>\n<p>1.3 纹理 (Texture)转为UIImage</p>\n<ul>\n<li>(UIImage *)imageFromTextureWithwidth:(int)width height:(int)height {<br>  // glActiveTexture(GL_TEXTURE1); 先绑定某个纹理<br>  int size = width * height * 4;<br>  GLubyte *buffer = malloc(size);<br>  glReadPixels(0, 0, width, height, GL_RGBA, GL_UNSIGNED_BYTE, buffer);<br>  CGDataProviderRef provider = CGDataProviderCreateWithData(NULL, buffer, size, NULL);<br>  int bitsPerComponent = 8;<br>  int bitsPerPixel = 32;<br>  int bytesPerRow = 4 * width;<br>  CGColorSpaceRef colorSpaceRef = CGColorSpaceCreateDeviceRGB();<br>  CGBitmapInfo bitmapInfo = kCGBitmapByteOrderDefault;<br>  CGColorRenderingIntent renderingIntent = kCGRenderingIntentDefault;<br>  CGImageRef imageRef = CGImageCreate(width, height, bitsPerComponent, bitsPerPixel, bytesPerRow, colorSpaceRef, bitmapInfo, provider, NULL, NO, renderingIntent);<br>  UIImage *image = [UIImage imageWithCGImage:imageRef];<br>  free(buffer);<br>  return image;<br>}</li>\n</ul>\n<p>1.4 data (RGB)转为UIImage</p>\n<ul>\n<li>(UIImage *)imageFromRGBData:(void <em>)data width:(int)width height:(int)height {<br>  CGColorSpaceRef rgbSpace = CGColorSpaceCreateDeviceRGB();<br>  CGContextRef context = CGBitmapContextCreate(data, width, height, 8, width</em>4, rgbSpace, kCGImageAlphaPremultipliedFirst | kCGBitmapByteOrder32Little );<br>  CGImageRef imageRef = CGBitmapContextCreateImage(context);<br>  CGContextRelease(context);<br>  UIImage *image = [UIImage imageWithCGImage:imageRef];<br>  CGImageRelease(imageRef);<br>  return image;<br>}</li>\n</ul>\n<p>1.5 data (Y)转为UIImage</p>\n<ul>\n<li>(UIImage *)imageFromYData:(void *)data width:(int)width height:(int)height {<br>  CGColorSpaceRef rgbSpace = CGColorSpaceCreateDeviceGray();<br>  CGContextRef context = CGBitmapContextCreate(data, width, height, 8, width, rgbSpace, kCGBitmapByteOrderDefault );<br>  CGImageRef imageRef = CGBitmapContextCreateImage(context);<br>  CGContextRelease(context);<br>  UIImage *image = [UIImage imageWithCGImage:imageRef];<br>  CGImageRelease(imageRef);<br>  return image;<br>}</li>\n</ul>\n<ol start=\"2\">\n<li>UIImage转为其他格式</li>\n</ol>\n<p>2.1 UIImage转为CVPixelBufferRef(RGB)</p>\n<ul>\n<li>(CVPixelBufferRef)imageToRGBPixelBuffer:(UIImage *)image {<br>  CGSize frameSize = CGSizeMake(CGImageGetWidth(image.CGImage),CGImageGetHeight(image.CGImage));<br>  NSDictionary *options =<br>  [NSDictionary dictionaryWithObjectsAndKeys:[NSNumber numberWithBool:YES],kCVPixelBufferCGImageCompatibilityKey,[NSNumber numberWithBool:YES],kCVPixelBufferCGBitmapContextCompatibilityKey,nil];<br>  CVPixelBufferRef pxbuffer = NULL;<br>  CVReturn status =<br>  CVPixelBufferCreate(kCFAllocatorDefault, frameSize.width, frameSize.height,kCVPixelFormatType_32BGRA, (__bridge CFDictionaryRef)options, &amp;pxbuffer);<br>  NSParameterAssert(status == kCVReturnSuccess &amp;&amp; pxbuffer != NULL);<br>  CVPixelBufferLockBaseAddress(pxbuffer, 0);<br>  void *pxdata = CVPixelBufferGetBaseAddress(pxbuffer);<br>  CGColorSpaceRef rgbColorSpace = CGColorSpaceCreateDeviceRGB();<br>  CGContextRef context = CGBitmapContextCreate(pxdata, frameSize.width, frameSize.height,8, CVPixelBufferGetBytesPerRow(pxbuffer),rgbColorSpace,(CGBitmapInfo)kCGBitmapByteOrder32Little | kCGImageAlphaPremultipliedFirst);<br>  CGContextDrawImage(context, CGRectMake(0, 0, CGImageGetWidth(image.CGImage),CGImageGetHeight(image.CGImage)), image.CGImage);<br>  CGColorSpaceRelease(rgbColorSpace);<br>  CGContextRelease(context);<br>  CVPixelBufferUnlockBaseAddress(pxbuffer, 0);<br>  return pxbuffer;<br>}</li>\n</ul>\n<p>2.2 UIImage转为CVPixelBufferRef(YUV)</p>\n<ul>\n<li>(CVPixelBufferRef)imageToYUVPixelBuffer:(UIImage *)image {<br>  CGSize frameSize = CGSizeMake(CGImageGetWidth(image.CGImage), CGImageGetHeight(image.CGImage));<br>  NSDictionary *options = [NSDictionary dictionaryWithObjectsAndKeys:<pre><code>                       [NSNumber numberWithBool:YES],kCVPixelBufferCGImageCompatibilityKey,\n                       [NSNumber numberWithBool:YES],kCVPixelBufferCGBitmapContextCompatibilityKey,nil];\n</code></pre>\n  CVPixelBufferRef pxbuffer = NULL;<br>  CVPixelBufferCreate(kCFAllocatorDefault, frameSize.width, frameSize.height,kCVPixelFormatType_420YpCbCr8BiPlanarFullRange, (__bridge CFDictionaryRef)options,&amp;pxbuffer);<br>  CVPixelBufferLockBaseAddress(pxbuffer, 0);<br>  void *pxdata = CVPixelBufferGetBaseAddressOfPlane(pxbuffer,0);<br>  CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceGray();<br>  CGContextRef context = CGBitmapContextCreate(pxdata, frameSize.width, frameSize.height,8,CVPixelBufferGetBytesPerRowOfPlane(pxbuffer, 0),colorSpace,kCGImageAlphaNone);<br>  CGContextDrawImage(context, CGRectMake(0, 0, CGImageGetWidth(image.CGImage),CGImageGetHeight(image.CGImage)), image.CGImage);<br>  CGColorSpaceRelease(colorSpace);<br>  CGContextRelease(context);<br>  CVPixelBufferUnlockBaseAddress(pxbuffer, 0);<br>  return pxbuffer;<br>}</li>\n</ul>\n","feature":true,"text":"在iOS多媒体开发时，需要经常转换图像格式以便调试。下面列了一些常用工具方法，在UIImage, CVPixelBufferRef,Texture之间完成格式转换。 其他格式转为UIImage 1.1 CVImageBufferRef (RGB)转为UIImage (UIImag...","link":"","photos":[],"count_time":{"symbolsCount":"6.3k","symbolsTime":"6 mins."},"categories":[],"tags":[],"toc":"","author":{"name":"William Xie","slug":"blog-author","avatar":"/img/author.png","link":"/","description":"","socials":{"github":"https://github.com/williamxiewz","twitter":"https://twitter.com/williamxie_wz","stackoverflow":"http://stackoverflow.com/users/4078104/goingxiebin-jobs","wechat":"","qq":"","weibo":"https://weibo.com/u/2281381063","zhihu":"https://www.zhihu.com/people/williamxiewz","csdn":"https://blog.csdn.net/u014222645","juejin":"https://juejin.cn/user/3280598430133277","customs":{}}},"mapped":true,"prev_post":{},"next_post":{"title":"awakeFromNib 整理摘录","uid":"e6105bfb53c66c2464c788c0813cc873","slug":"awakeFromNib-整理摘录","date":"2017-10-24T08:18:48.000Z","updated":"2017-10-24T08:19:33.000Z","comments":true,"path":"api/articles/awakeFromNib-整理摘录.json","keywords":null,"cover":null,"text":"（1）awakeFromNib和initWithCoder:差别awakeFromNib 从xib或者storyboard加载完毕就会调用initWithCoder: 只要对象是从文件解析来的，就会调用同时存在会先调用initWithCoder: （2）initWithCoder...","link":"","photos":[],"count_time":{"symbolsCount":"1.7k","symbolsTime":"2 mins."},"categories":[{"name":"iOS SDK","slug":"iOS-SDK","count":18,"path":"api/categories/iOS-SDK.json"}],"tags":[],"author":{"name":"William Xie","slug":"blog-author","avatar":"/img/author.png","link":"/","description":"","socials":{"github":"https://github.com/williamxiewz","twitter":"https://twitter.com/williamxie_wz","stackoverflow":"http://stackoverflow.com/users/4078104/goingxiebin-jobs","wechat":"","qq":"","weibo":"https://weibo.com/u/2281381063","zhihu":"https://www.zhihu.com/people/williamxiewz","csdn":"https://blog.csdn.net/u014222645","juejin":"https://juejin.cn/user/3280598430133277","customs":{}}},"feature":true}}