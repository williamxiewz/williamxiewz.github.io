{"title":"CFNetwork 编程指南之三: 使用流(Working with Streams)","uid":"2ceaaff5f996f8ed02b5f1f94c9c06a5","slug":"CFNetwork-编程指南之三-使用流-Working-with-Streams","date":"2016-08-10T03:57:01.000Z","updated":"2016-08-19T11:44:29.000Z","comments":true,"path":"api/articles/CFNetwork-编程指南之三-使用流-Working-with-Streams.json","keywords":null,"cover":null,"content":"<p>#Working with Streams</p>\n<p>本文讨论如何创建、打开和检查读写流错误。它还描述了如何从读取流读取信息，如何从写入信息到写入流，如何在读取或写入流时防止阻塞以及如何通过代理服务器导航到流。</p>\n<p>##使用读取流<br>核心基础流可用于读取或写入文件或使用网络套接字。除了创建这些流过程中的异常，其他行为类似。</p>\n<p>###创建一个读取流<br>首先创建一个读取流。列表2-1为一个文件创建读取流。</p>\n<p>列表2-1 为一个文件创建读取流</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">CFReadStreamRef myReadStream &#x3D; CFReadStreamCreateWithFile(kCFAllocatorDefault, fileURL);</code></pre>\n<span id=\"more\"></span>\n<p>在这个列表中，<code>kCFAllocatorDefault</code> 参数指定当前默认系统分配器来为流分配内存，fileURL 参数指定读取流创建到的文件名称，例如 <code>file:///Users/joeuser/Downloads/MyApp.sit</code></p>\n<p>类似的，你可以通过调用<a href=\"https://developer.apple.com/library/ios/documentation/CoreFoundation/Reference/CFStreamConstants/index.html#//apple_ref/c/func/CFStreamCreatePairWithSocketToCFHost\">CFStreamCreatePairWithSocketToCFHost</a>（在使用运行循环阻止阻塞（<a href=\"https://developer.apple.com/library/ios/documentation/Networking/Conceptual/CFNetwork/CFStreamTasks/CFStreamTasks.html#//apple_ref/doc/uid/TP30000230-62233\">Using a Run Loop to Prevent Blocking</a>）中有描述）或者<a href=\"https://developer.apple.com/library/ios/documentation/CoreFoundation/Reference/CFStreamConstants/index.html#//apple_ref/c/func/CFStreamCreatePairWithSocketToNetService\">CFStreamCreatePairWithSocketToNetService</a>（在NSNetServices and CFNetServices 编程指南（<a href=\"https://developer.apple.com/library/ios/documentation/Networking/Conceptual/NSNetServiceProgGuide/Introduction.html#//apple_ref/doc/uid/TP40002736\">NSNetServices and CFNetServices Programming Guide</a>）中有描述）来创建一对基于网络服务的流。</p>\n<p>现在，你已经创建流，你可以打开它。打开流将导致流保留需要的任何系统资源，例如打开文件所需的文件描述符。列表2-1是一个打开读取流的例子。</p>\n<p>列表2-2 打开读取流</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">if (!CFReadStreamOpen(myReadStream)) &#123;  \n     CFStreamError myErr &#x3D; CFReadStreamGetError(myReadStream);  \n       &#x2F;&#x2F; An error has occurred.     \n     if (myErr.domain &#x3D;&#x3D; kCFStreamErrorDomainPOSIX) &#123;  \n         &#x2F;&#x2F; Interpret myErr.error as a UNIX errno.    \n     &#125; else if (myErr.domain &#x3D;&#x3D; kCFStreamErrorDomainMacOSStatus) &#123;   \n        &#x2F;&#x2F; Interpret myErr.error as a MacOS error code.  \n        OSStatus macError &#x3D; (OSStatus)myErr.error;     \n        &#x2F;&#x2F; Check other error domains.    \n     &#125;\n&#125;</code></pre>\n\n<p><code>CFReadStreamOpen</code> 函数返回<code>TRUE</code> 表示成功，<code>FALSE</code> 表示由于某种原因打开失败。如果<code>CFReadStreamOpen</code> 返回<code>FALSE</code>，例子调用<code>CFReadStreamGetError</code> 函数，将返回<code>CFStreamError</code> 类型结构，包含两个值：一个域代码和一个错误代码。域代码表明错误代码应该如何解释。例如，如果域代码是<code>kCFStreamErrorDomainPOSIX</code>，错误代码是<code>UNIX errno</code>值。其他错误域是<code>kCFStreamErrorDomainMacOSStatus</code>，表明错误代码是一个定义在<code>MacErrors.h</code>中的<code>OSStatus</code> 值，<code>kCFStreamErrorDomainHTTP</code>表明错误代码是<code>CFStreamErrorHTTP</code> 枚举中定义的值。</p>\n<p>打开一个流是一个漫长的过程，所以<code>CFReadStreamOpen</code> 函数和<code>CFWriteStreamOpen</code> 函数返回<code>TRUE</code> 表明打开流的过程已经开始，来避免阻塞。为了检查打开的装填，可以调用<code>CFReadStreamGetStatus</code> 和<code>CFWriteStreamGetStatus</code>函数，如果仍处于打开过程则返回``kCFStreamStatusOpening<code>，如果已经打开则返回</code>kCFStreamStatusOpen<code> ，如果已经打开但失败了则返回</code>kCFStreamStatusErrorOccurred<code>。在大多数情况下，打开是否完成无关紧要，因为</code>CFStream`函数的读写将会阻塞直到打开流。</p>\n<p>###从读取流中读取信息<br>从读取流中读取信息，调用函数<code>CFReadStreamRead</code>，这个函数类似于<code>UNIX read()</code> 系统调用。两者都采用缓存区和缓存区长度作为参数。两者都返回读取的字节数，在流或文件末尾则返回0，错误发生则返回-1.两者都阻塞直到可以读取一个字节并继续读取。列表2-3是从读取流中读取信息的例子。</p>\n<p>列表2-3 从读取流（blocking）中读取信息</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">CFIndex numBytesRead;\ndo &#123;   \n   UInt8 buf[myReadBufferSize]; \n    &#x2F;&#x2F; define myReadBufferSize as desired  \n    numBytesRead &#x3D; CFReadStreamRead(myReadStream, buf, sizeof(buf)); \n\n    if( numBytesRead &gt; 0 ) &#123;     \n      handleBytes(buf, numBytesRead);  \n    &#125; else if( numBytesRead &lt; 0 ) &#123;  \n      CFStreamError error &#x3D; CFReadStreamGetError(myReadStream);       \n           reportError(error);    \n    &#125;\n\n&#125; while( numBytesRead &gt; 0 );\n</code></pre>\n\n\n<p>###释放读取流<br>当所有数据都被读取，你可以调用CFReadStreamClose 函数关闭流，从而释放有关系统资源。然后通过调用<a href=\"https://developer.apple.com/library/ios/documentation/CoreFoundation/Reference/CFTypeRef/index.html#//apple_ref/doc/c_ref/CFRelease\">CFRelease</a>函数释放流引用。你可以设置引用为NULL使其无效。如列表2-4的例子。</p>\n<p>列表2-4 释放读取流</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">CFReadStreamClose(myReadStream);\nCFRelease(myReadStream);\nmyReadStream &#x3D; NULL;</code></pre>\n\n\n<p>##使用写入流<br>使用写入流类似于使用读取流。一个主要的区别是<a href=\"https://developer.apple.com/library/ios/documentation/CoreFoundation/Reference/CFWriteStreamRef/index.html#//apple_ref/doc/c_ref/CFWriteStreamWrite\">CFWriteStreamWrite</a> 函数并不能保证接收你传递给它的所有字节。相反，CFWriteStreamWrite 返回它接收的字节数。你会看到列表2-5中的实例代码，如果写入的字节数与需要写入的总字节数不一致，缓存区会调整并适应这一点。</p>\n<p>列表2-5 创建、打开、写入并释放写入流</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">CFWriteStreamRef myWriteStream &#x3D;\n        CFWriteStreamCreateWithFile(kCFAllocatorDefault, fileURL);\nif (!CFWriteStreamOpen(myWriteStream)) &#123;\n    CFStreamError myErr &#x3D; CFWriteStreamGetError(myWriteStream);\n    &#x2F;&#x2F; An error has occurred.\n    if (myErr.domain &#x3D;&#x3D; kCFStreamErrorDomainPOSIX) &#123;\n    &#x2F;&#x2F; Interpret myErr.error as a UNIX errno.\n    &#125; else if (myErr.domain &#x3D;&#x3D; kCFStreamErrorDomainMacOSStatus) &#123;\n        &#x2F;&#x2F; Interpret myErr.error as a MacOS error code.\n        OSStatus macError &#x3D; (OSStatus)myErr.error;\n        &#x2F;&#x2F; Check other error domains.\n    &#125;\n&#125;\nUInt8 buf[] &#x3D; “Hello, world”;\nCFIndex bufLen &#x3D; (CFIndex)strlen(buf);\n \nwhile (!done) &#123;\n    CFIndex bytesWritten &#x3D; CFWriteStreamWrite(myWriteStream, buf, (CFIndex)bufLen);\n    if (bytesWritten &lt; 0) &#123;\n        CFStreamError error &#x3D; CFWriteStreamGetError(myWriteStream);\n        reportError(error);\n    &#125; else if (bytesWritten &#x3D;&#x3D; 0) &#123;\n        if (CFWriteStreamGetStatus(myWriteStream) &#x3D;&#x3D; kCFStreamStatusAtEnd) &#123;\n            done &#x3D; TRUE;\n        &#125;\n    &#125; else if (bytesWritten !&#x3D; bufLen) &#123;\n        &#x2F;&#x2F; Determine how much has been written and adjust the buffer\n        bufLen &#x3D; bufLen - bytesWritten;\n        memmove(buf, buf + bytesWritten, bufLen);\n \n        &#x2F;&#x2F; Figure out what went wrong with the write stream\n        CFStreamError error &#x3D; CFWriteStreamGetError(myWriteStream);\n        reportError(error);\n \n    &#125;\n&#125;\nCFWriteStreamClose(myWriteStream);\nCFRelease(myWriteStream);\nmyWriteStream &#x3D; NULL;\n</code></pre>\n\n<p>##使用流时防止阻塞</p>\n<p>当使用流来通信时，特别是基于套接字的流，数据传输可能需要很长时间。如果你同步执行你的流，你的整个应用将被迫等待数据传输。因此，强烈建议你的代码使用替代方法来防止阻塞。</p>\n<p>当读取或写入一个CFStream对象时，有两种方法可以防止阻塞：</p>\n<ul>\n<li><p>使用一个运行循环——注册账户接收stream-related 事件并安排流到一个运行循环上。当stream-related 事件发生时，调用你的回调函数（注册调用时指定）。</p>\n</li>\n<li><p>轮询——对于读取流，在读取流之前找出是否有需要读取的字节。对于写入流，在写入流之前找出流是否可以无阻塞的写入。</p>\n</li>\n</ul>\n<p>将在以下章节中讨论这些方法。</p>\n<p>###使用运行循环防止阻塞<br>使用流的首选方法是运行循环。运行循环在你的主线程上执行。等待事件发生，然后调用与给定事件相关的函数。</p>\n<p>在网络传输的情况下，当你的注册事件发生时，你的回调函数被运行循环执行。这样你可以不必轮询你的套接字流，可以减缓线程。</p>\n<p>关于运行循环的更多信息，参阅线程编程指南（<a href=\"https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/Multithreading/Introduction/Introduction.html#//apple_ref/doc/uid/10000057i\">Threading Programming Guide</a>）。</p>\n<p>这个例子首先创建一个套接字读取流：</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">CFStreamCreatePairWithSocketToCFHost(kCFAllocatorDefault, host,port,\n                                  &amp;myReadStream, NULL);</code></pre>\n\n\n<p>CFHost对象引用、host指定远程主机为读取流的主机，port 参数指定主机使用的端口号。CFStreamCreatePairWithSocketToCFHost 函数返回新的读取流引用myReadStream。最后一个参数NULL表明调用者不希望创建写入流。如果你想创建一个写入流，最后一个参数为&amp;myWriteStream。</p>\n<p>在打开套接字读取流之前，创建一个内容，这样当你注册接收 stream-related事件时可以使用。</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">CFStreamClientContext myContext &#x3D; &#123;0, myPtr, myRetain, myRelease, myCopyDesc&#125;;</code></pre>\n\n\n<p>第一个参数是<code>0</code>指定版本号。<code>info</code> 参数<code>myPtr</code>是你想要传递给回调函数的数据指针。通常，<code>myPtr</code>是一个指向结构体的指针，在结构体中你定义了包含有关流的信息。参数<code>retain</code> 是一个指向函数的指针，可以保留参数<code>info</code> 。所以在函数中设置为<code>myRetain</code>，在上面的代码中，<code>CFStream</code> 将调用<code>myRetain(myPtr)</code>来保留<code>info</code> 指针。同样，<code>release</code> 参数<code>myRelease</code>是一个指向函数的指针，释放参数info 。当流与内容分离，<code>CFStream</code>将调用 <code>myRelease(myPtr)</code>。最后，<code>copyDescription</code> 是函数的一个参数，该函数提供流的描述。例如，如果你是调用上文所示的CFCopyDesc(myReadStream) ，<code>CFStream</code>将调用<code>myCopyDesc(myPtr)</code>。</p>\n<p>客户端环境允许你设置<code>retain</code>, <code>release</code>和<code>copyDescription</code> 参数为<code>NULL</code>。如果你设置<code>retain</code> 和参数<code>release </code>为<code>NULL</code>，系统将认为<code>info</code> 指针指向的内存一直存在直到流本身被销毁。如果你将<code>copyDescription</code> 参数设置为NULL，如果有要求，系统将提供<code>info </code>指针所指向内存的基本信息。</p>\n<p>设置好客户端环境后，调用函数<code>CFReadStreamSetClient</code> 注册接收有关流事件。<code>CFReadStreamSetClient</code> 要求你指定回调函数和你想接收的事件。列表2-6中的例子指定回调函数和接收的<code>kCFStreamEventHasBytesAvailable</code>,<code>kCFStreamEventErrorOccurred</code>和<code>kCFStreamEventEndEncountered</code> 事件。然后调用<a href=\"https://developer.apple.com/library/ios/documentation/CoreFoundation/Reference/CFReadStreamRef/index.html#//apple_ref/doc/c_ref/CFReadStreamScheduleWithRunLoop\">CFReadStreamScheduleWithRunLoop</a>函数安排流到一个运行循环上。例子见列表2-6.</p>\n<p>列表2-6 安排流到运行循环上</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">CFOptionFlags registeredEvents &#x3D; kCFStreamEventHasBytesAvailable |\n        kCFStreamEventErrorOccurred | kCFStreamEventEndEncountered;\nif (CFReadStreamSetClient(myReadStream, registeredEvents, myCallBack, &amp;myContext))\n&#123;\n    CFReadStreamScheduleWithRunLoop(myReadStream, CFRunLoopGetCurrent(),\n                                    kCFRunLoopCommonModes);\n&#125;</code></pre>\n\n<p>流安排到运行循环上后，你可以准备打开流，如列表2-7所示。</p>\n<p>列表2-7 打开非阻塞读取流</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">if (!CFReadStreamOpen(myReadStream)) &#123;\n    CFStreamError myErr &#x3D; CFReadStreamGetError(myReadStream);\n    if (myErr.error !&#x3D; 0) &#123;\n    &#x2F;&#x2F; An error has occurred.\n        if (myErr.domain &#x3D;&#x3D; kCFStreamErrorDomainPOSIX) &#123;\n        &#x2F;&#x2F; Interpret myErr.error as a UNIX errno.\n            strerror(myErr.error);\n        &#125; else if (myErr.domain &#x3D;&#x3D; kCFStreamErrorDomainMacOSStatus) &#123;\n            OSStatus macError &#x3D; (OSStatus)myErr.error;\n            &#125;\n        &#x2F;&#x2F; Check other domains.\n    &#125; else\n        &#x2F;&#x2F; start the run loop\n        CFRunLoopRun();\n&#125;\n</code></pre>\n\n<p>现在，等待你的回调函数执行。在你的回调函数中，检查事件代码并采取适当的行动。见列表2-8.</p>\n<p>列表2-8 网络事件回调函数</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">void myCallBack (CFReadStreamRef stream, CFStreamEventType event, void *myPtr) &#123;\n    switch(event) &#123;\n        case kCFStreamEventHasBytesAvailable:\n            &#x2F;&#x2F; It is safe to call CFReadStreamRead; it won’t block because bytes\n            &#x2F;&#x2F; are available.\n            UInt8 buf[BUFSIZE];\n            CFIndex bytesRead &#x3D; CFReadStreamRead(stream, buf, BUFSIZE);\n            if (bytesRead &gt; 0) &#123;\n                handleBytes(buf, bytesRead);\n            &#125;\n            &#x2F;&#x2F; It is safe to ignore a value of bytesRead that is less than or\n            &#x2F;&#x2F; equal to zero because these cases will generate other events.\n            break;\n        case kCFStreamEventErrorOccurred:\n            CFStreamError error &#x3D; CFReadStreamGetError(stream);\n            reportError(error);\n            CFReadStreamUnscheduleFromRunLoop(stream, CFRunLoopGetCurrent(),\n                                              kCFRunLoopCommonModes);\n            CFReadStreamClose(stream);\n            CFRelease(stream);\n            break;\n        case kCFStreamEventEndEncountered:\n            reportCompletion();\n            CFReadStreamUnscheduleFromRunLoop(stream, CFRunLoopGetCurrent(),\n                                              kCFRunLoopCommonModes);\n            CFReadStreamClose(stream);\n            CFRelease(stream);\n            break;\n    &#125;\n&#125;\n\n</code></pre>\n\n<p>当回调函数接收<code>kCFStreamEventHasBytesAvailabl</code>e <code>事件代码，它会调用</code>CFReadStreamRead` 来读取数据。</p>\n<p>当回调函数接收<code>kCFStreamEventErrorOccurred</code> 事件代码，它会调用<code>CFReadStreamGetError</code> 来获取错误和自己的错误函数 (reportError)来处理错误。</p>\n<p>当回调函数接收<code>kCFStreamEventEndEncountered </code>事件代码，它调用自己的函数 (<code>reportCompletion</code>)来处理最终的数据然后调用<code>CFReadStreamUnscheduleFromRunLoop</code> 函数从指定运行循环上移除流。然后运行<code>CFReadStreamClose </code>函数来关闭流，<code>CFRelease</code> 来释放流引用。</p>\n<p>###轮询网络流<br>一般来说，轮询网络流是不明智的。然而，在某些罕见的情况下，它非常有用。为了轮询流，你首先检查流是否可以读取或写入，然后在流上执行一个读取或写入的操作。</p>\n<p>当写入到一个写入流中，你通过调用<code>CFWriteStreamCanAcceptBytes</code>可以决定流是否接受数据。如果返回TRUE，那么你可以确定随后调用的<code>CFWriteStreamWrite</code> 函数将立即发送数据而没有阻塞。</p>\n<p>同样，对于读取流，在调用CFReadStreamRead之前，调用CFReadStreamHasBytesAvailable函数。</p>\n<p>列表2-9 是一个轮询读取流的例子</p>\n<p>列表2-9 轮询读取流</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">while (!done) &#123;\n    if (CFReadStreamHasBytesAvailable(myReadStream)) &#123;\n        UInt8 buf[BUFSIZE];\n        CFIndex bytesRead &#x3D; CFReadStreamRead(myReadStream, buf, BUFSIZE);\n        if (bytesRead &lt; 0) &#123;\n            CFStreamError error &#x3D; CFReadStreamGetError(myReadStream);\n            reportError(error);\n        &#125; else if (bytesRead &#x3D;&#x3D; 0) &#123;\n            if (CFReadStreamGetStatus(myReadStream) &#x3D;&#x3D; kCFStreamStatusAtEnd) &#123;\n                done &#x3D; TRUE;\n            &#125;\n        &#125; else &#123;\n            handleBytes(buf, bytesRead);\n        &#125;\n    &#125; else &#123;\n        &#x2F;&#x2F; ...do something else while you wait...\n    &#125;\n&#125;\n</code></pre>\n\n<p>列表2-10 轮询写入流的例子</p>\n<p>列表2-10 轮询写入流</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">UInt8 buf[] &#x3D; “Hello, world”;\nUInt32 bufLen &#x3D; strlen(buf);\n \nwhile (!done) &#123;\n    if (CFWriteStreamCanAcceptBytes(myWriteStream)) &#123;\n        int bytesWritten &#x3D; CFWriteStreamWrite(myWriteStream, buf, strlen(buf));\n        if (bytesWritten &lt; 0) &#123;\n            CFStreamError error &#x3D; CFWriteStreamGetError(myWriteStream);\n            reportError(error);\n        &#125; else if (bytesWritten &#x3D;&#x3D; 0) &#123;\n            if (CFWriteStreamGetStatus(myWriteStream) &#x3D;&#x3D; kCFStreamStatusAtEnd)\n            &#123;\n                done &#x3D; TRUE;\n            &#125;\n        &#125; else if (bytesWritten !&#x3D; strlen(buf)) &#123;\n            &#x2F;&#x2F; Determine how much has been written and adjust the buffer\n            bufLen &#x3D; bufLen - bytesWritten;\n            memmove(buf, buf + bytesWritten, bufLen);\n \n            &#x2F;&#x2F; Figure out what went wrong with the write stream\n            CFStreamError error &#x3D; CFWriteStreamGetError(myWriteStream);\n            reportError(error);\n        &#125;\n    &#125; else &#123;\n        &#x2F;&#x2F; ...do something else while you wait...\n    &#125;\n&#125;\n</code></pre>\n\n<p>##导航防火墙<br>有两种方式设置流的防火墙。对于大多数流，你可以使用SCDynamicStoreCopyProxies 函数来检索代理设置，然后设置kCFStreamHTTPProxy （或kCFStreamFTPProxy）属性将结果应用于流。SCDynamicStoreCopyProxies 函数是系统配置框架的一部分，因此你需要在你的项目中使用该函数时需导入<code>&lt;SystemConfiguration/SystemConfiguration.h&gt;</code>。然后当你完成后，释放代理字典引用。整个过程如列表2-11所示。</p>\n<p>列表2-11 通过代理服务器导航一个流</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">CFDictionaryRef proxyDict &#x3D; SCDynamicStoreCopyProxies(NULL);\nCFReadStreamSetProperty(readStream, kCFStreamPropertyHTTPProxy, proxyDict);</code></pre>\n<p>然而，如果你经常需要使用代理设置多个流，这将变得更加复杂。在这种情况下，检索用户机器防火墙设置需要五个步骤：</p>\n<ul>\n<li><p>为动态存储会话SCDynamicStoreRef，创建一个持久的句柄。</p>\n</li>\n<li><p>将句柄添加到运行循环中的动态存储会话上，这样可以收到代理更改的通知。</p>\n</li>\n<li><p>使用SCDynamicStoreCopyProxies 检索最新的代理设置。</p>\n</li>\n<li><p>当被告知变更，更新你的代理。</p>\n</li>\n<li><p>当通过后，清理SCDynamicStoreRef。</p>\n</li>\n</ul>\n<p>为动态存储会话创建句柄，使用SCDynamicStoreCreate 函数并传递一个分配器，一个名字来描述你的过程，一个回调函数和一个动态存储环境SCDynamicStoreContext。当初始化应用时运行。代码如列表2-12所示.</p>\n<p>列表2-12 为动态存储会话创建一个句柄</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">SCDynamicStoreContext context &#x3D; &#123;0, self, NULL, NULL, NULL&#125;;\nsystemDynamicStore &#x3D; SCDynamicStoreCreate(NULL,\n                                          CFSTR(&quot;SampleApp&quot;),\n                \t                      proxyHasChanged,\n           \t\t\t\t\t\t\t\t  &amp;context);</code></pre>\n<p>创建动态存储引用后，你需要将其添加到运行循环上。首先，采用动态存储引用 对 代理的任何更改 设置监控。使用SCDynamicStoreKeyCreateProxies 和SCDynamicStoreSetNotificationKeys函数可完成该功能。然后，你可以调用SCDynamicStoreCreateRunLoopSource 和CFRunLoopAddSource函数添加动态存储引用到运行循环上。代码如列表2-13所示。</p>\n<p>列表2-13 添加一个动态存储引用到运行循环</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">&#x2F;&#x2F; Set up the store to monitor any changes to the proxies\nCFStringRef proxiesKey &#x3D; SCDynamicStoreKeyCreateProxies(NULL);\nCFArrayRef keyArray &#x3D; CFArrayCreate(NULL,\n                                    (const void **)(&amp;proxiesKey),\n                                    1,\n                                    &amp;kCFTypeArrayCallBacks);\nSCDynamicStoreSetNotificationKeys(systemDynamicStore, keyArray, NULL);\nCFRelease(keyArray);\nCFRelease(proxiesKey);\n \n&#x2F;&#x2F; Add the dynamic store to the run loop\nCFRunLoopSourceRef storeRLSource &#x3D;\n    SCDynamicStoreCreateRunLoopSource(NULL, systemDynamicStore, 0);\nCFRunLoopAddSource(CFRunLoopGetCurrent(), storeRLSource, kCFRunLoopCommonModes);\nCFRelease(storeRLSource);</code></pre>\n\n<p>一旦动态存储引用添加到运行循环上，调用SCDynamicStoreCopyProxies函数，用它来预加载代理字典当前代理设置。如列表2-14所示</p>\n<p>列表2-14 加载代理字典</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">gProxyDict &#x3D; SCDynamicStoreCopyProxies(systemDynamicStore);</code></pre>\n\n\n<p>由于动态存储引用添加到运行循环上，每次代理改变，你的回调函数会运行。释放当前代理字典并使用新的代理设置重新加载。回调函数示例代码如列表2-15所示。</p>\n<p>列表2-15 代理回调函数</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">void proxyHasChanged() &#123;\nCFRelease(gProxyDict);\n   gProxyDict &#x3D; SCDynamicStoreCopyProxies(systemDynamicStore);\n&#125;</code></pre>\n<p>因为所有代理信息是最新的。创建读取或写入流后，通过调用CFReadStreamSetProperty 和CFWriteStreamSetProperty函数，设置kCFStreamPropertyHTTPProxy 代理。如果流是叫做的readStream读取流，函数调用如列表2-16所示。</p>\n<p>列表2-16 添加代理信息到流</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">CFReadStreamSetProperty(readStream, kCFStreamPropertyHTTPProxy, gProxyDict);</code></pre>\n\n\n<p>当代理设置完成，确保释放字典和动态存储引用并从运行循环上删除动态存储引用。见列表2-17.</p>\n<p>列表2-17 清理代理信息</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">if (gProxyDict) &#123;\nCFRelease(gProxyDict);&#125;\n&#x2F;&#x2F; Invalidate the dynamic store&#39;s run loop source\n&#x2F;&#x2F; to get the store out of the run loop\nCFRunLoopSourceRef rls &#x3D; SCDynamicStoreCreateRunLoopSource(NULL, systemDynamicStore, 0);\nCFRunLoopSourceInvalidate(rls);\nCFRelease(rls);\nCFRelease(systemDynamicStore);</code></pre>\n<p>官方原文地址：<br><a href=\"https://developer.apple.com/library/ios/documentation/Networking/Conceptual/CFNetwork/CFStreamTasks/CFStreamTasks.html#//apple_ref/doc/uid/TP30001132-CH6-SW1\">CFNetwork Programming Guide</a></p>\n","text":"#Working with Streams 本文讨论如何创建、打开和检查读写流错误。它还描述了如何从读取流读取信息，如何从写入信息到写入流，如何在读取或写入流时防止阻塞以及如何通过代理服务器导航到流。 ##使用读取流核心基础流可用于读取或写入文件或使用网络套接字。除了创建这些流过...","link":"","photos":[],"count_time":{"symbolsCount":"15k","symbolsTime":"13 mins."},"categories":[{"name":"iOS网络编程","slug":"iOS网络编程","count":9,"path":"api/categories/iOS网络编程.json"}],"tags":[{"name":"CFNetwork","slug":"CFNetwork","count":7,"path":"api/tags/CFNetwork.json"}],"toc":"","author":{"name":"William Xie","slug":"blog-author","avatar":"/img/author.png","link":"/","description":"","socials":{"github":"https://github.com/williamxiewz","twitter":"https://twitter.com/williamxie_wz","stackoverflow":"http://stackoverflow.com/users/4078104/goingxiebin-jobs","wechat":"","qq":"","weibo":"https://weibo.com/u/2281381063","zhihu":"https://www.zhihu.com/people/williamxiewz","csdn":"https://blog.csdn.net/u014222645","juejin":"https://juejin.cn/user/3280598430133277","customs":{}}},"mapped":true,"prev_post":{"title":"CFNetwork 编程指南之四: 与HTTP服务器通信(Communicating with HTTP Servers)","uid":"07ef757033d0429be6d914103f281624","slug":"CFNetwork-编程指南之四-与HTTP服务器通信-Communicating-with-HTTP-Servers","date":"2016-08-10T03:57:31.000Z","updated":"2016-08-19T11:46:50.000Z","comments":true,"path":"api/articles/CFNetwork-编程指南之四-与HTTP服务器通信-Communicating-with-HTTP-Servers.json","keywords":null,"cover":null,"text":"#与HTTP服务器通信 本文解释了如何创建、发送和接收HTTP请求和响应。 ##创建一个CFHTTP请求HTTP请求是一个消息，这个消息由远程服务器执行的方法，操作的对象（URL），消息头和消息体。方法通常是下面之一：GET, HEAD, PUT, POST, DELETE, T...","link":"","photos":[],"count_time":{"symbolsCount":"6.4k","symbolsTime":"6 mins."},"categories":[{"name":"iOS网络编程","slug":"iOS网络编程","count":9,"path":"api/categories/iOS网络编程.json"}],"tags":[{"name":"CFNetwork","slug":"CFNetwork","count":7,"path":"api/tags/CFNetwork.json"}],"author":{"name":"William Xie","slug":"blog-author","avatar":"/img/author.png","link":"/","description":"","socials":{"github":"https://github.com/williamxiewz","twitter":"https://twitter.com/williamxie_wz","stackoverflow":"http://stackoverflow.com/users/4078104/goingxiebin-jobs","wechat":"","qq":"","weibo":"https://weibo.com/u/2281381063","zhihu":"https://www.zhihu.com/people/williamxiewz","csdn":"https://blog.csdn.net/u014222645","juejin":"https://juejin.cn/user/3280598430133277","customs":{}}}},"next_post":{"title":"CFNetwork 编程指南之二: CFNetwork概念（CFNetwork Concepts)","uid":"a332cbc6e65f305f252e6ab66fc98405","slug":"CFNetwork-编程指南之二-CFNetwork概念（CFNetwork-Concepts","date":"2016-08-10T03:56:29.000Z","updated":"2016-08-19T11:44:53.000Z","comments":true,"path":"api/articles/CFNetwork-编程指南之二-CFNetwork概念（CFNetwork-Concepts.json","keywords":null,"cover":[],"text":"#CFNetwork概念 CFNetwork是一个低级别高性能的框架，使你能够精细的控制协议栈。它是BSD套接字的扩展，标准套接字抽象API提供对象来简化任务，例如与FTP和HTTP服务器通信或解析DNS主机。CFNetwork物理上和理论上都基于BSD套接字。 正如CFNetw...","link":"","photos":[],"count_time":{"symbolsCount":"5.5k","symbolsTime":"5 mins."},"categories":[{"name":"iOS网络编程","slug":"iOS网络编程","count":9,"path":"api/categories/iOS网络编程.json"}],"tags":[{"name":"CFNetwork","slug":"CFNetwork","count":7,"path":"api/tags/CFNetwork.json"}],"author":{"name":"William Xie","slug":"blog-author","avatar":"/img/author.png","link":"/","description":"","socials":{"github":"https://github.com/williamxiewz","twitter":"https://twitter.com/williamxie_wz","stackoverflow":"http://stackoverflow.com/users/4078104/goingxiebin-jobs","wechat":"","qq":"","weibo":"https://weibo.com/u/2281381063","zhihu":"https://www.zhihu.com/people/williamxiewz","csdn":"https://blog.csdn.net/u014222645","juejin":"https://juejin.cn/user/3280598430133277","customs":{}}}}}