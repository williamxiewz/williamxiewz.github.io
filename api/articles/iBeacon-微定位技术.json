{"title":"iBeacon 微定位技术","uid":"00d58d9a73e1bc4a1c001712fc4a5ff9","slug":"iBeacon-微定位技术","date":"2016-08-10T11:01:39.000Z","updated":"2019-05-14T04:53:35.000Z","comments":true,"path":"api/articles/iBeacon-微定位技术.json","keywords":null,"cover":[],"content":"<p>在一家大型商场,医院或是大楼里,你是否会曾经有过找不到想要去的地方的经历呢?<br>这种情况下采用上面介绍的传统定位方式,就有些”力不从心”了,首先不能采用GPS定位,而WiFi 和蜂窝式移动电话基站定位误差比较大,这种情况下的定位就是 “微定位”技术了</p>\n<p>#地理围栏</p>\n<p>微定位技术中一个比较重要的概念—地理围栏. 地理围栏(Geo-fencing)是LBS的一种新应用,就是用一个虚拟的栅栏围出一个虚拟地理边界. 当手机进入,离开某个特定地理区域,或在该区域活动时,手机可以可以接受自动通知和警告.有了地理围栏技术,位置社交网站就可以帮助用户进入某一个地区时自动登记.</p>\n<p>地理围栏可以采用传统定位或微定位实现,当然微定位更加有现实意义,建立地理围栏技术往往是处于电子商务,店内导航和设计活动等目的. 定位环境比较复杂,定位要求比较精确.</p>\n<span id=\"more\"></span>\n<p>#iBeacon 技术</p>\n<p>苹果公司在iOS 7 之后 支持iBeacon技术,iBeacon技术是苹果公司研发的,它使用低功率蓝牙技术,通过多个iBeacon 基站创建一个信号区域(地理围栏),当设备进去该区域时,相应的应用便会提示用户进入这个地理围栏.</p>\n<p>iBeacon 是苹果公司推出的一项室内定位技术，通过软件和硬件的结合，从而大大提高室内精度，从原来的几百米，几十米，提高到一米以内的定位精度。有了这么高精度的定位能力，许多原来只能想一想的事情，现在可以做到了：当你走到某个商品前，手机应用自动跳出商品的介绍，让你的购物体验感，大大增强。下图是一个典型的应用场景：</p>\n<p><img src=\"https://github.com/williamxiewz/williamxie-github-io/raw/master/appledevelopdingweijishuibeacon1.jpg\"></p>\n<p>当用户(安装了特定应用的iOS用户)进入一家大型商场,在门口会有一个iBeacon 基站,它会提示用户是否需要接入这个信号网络。如果用户选择了”是”，他就可以享受到很多服务，iBeacon基站可以核对用户的 Passbook中是否具有本店的某种商品的优惠券或打折卡，当然也可以为用户发放电子优惠<br>打折卡（即pass)，然后存人到passbook中。<br>也可以为用户提供商场的室内导航。最后要结账的时候，iBeacon可以提供零接触支付。</p>\n<p>此外，每个iBeacon基站内置ARM架构cpu、蓝牙模块和闪存，以及加速度计、陀螺仪 寺传愁器。由于采用低功耗蓝牙技术通信，iBeacon基站更加省电，一个小纽扣电池使能为 一个iBeacon基站提供长达两年的续航时间。</p>\n<p>#iBeacon技术实现微定位</p>\n<p>iBeacon技术通信的核心是低功耗蓝牙通信，iBeacon基站就是一个外设，它只是负责广<br>播数据，而中心是用户iOS设备上的应用。我们在开发阶段可以使用一个ios设备，在上<br>面安装一个特定应用使其作为iBeacon基站角色。如果不考虑成本，我们可以使用iOS设<br>备作为iBeacon基站，但事实上这样一个方案过于奢侈了，现在已经有一些公司开发出了功<br>能完善的iBeacon技术的基站，它只需要很低的费用就可以构建iBeacon地理围栏。 </p>\n<p>##iBeacon 基站服务端</p>\n<pre class=\"line-numbers language-swift\" data-language=\"swift\"><code class=\"language-swift\">import UIKit\nimport CoreBluetooth\nimport CoreLocation\n&#x2F;&#x2F; iBeacon UUID\nlet kUUID &#x3D; &quot;88936DF5-E10B-4382-89D6-8AE0D80373F8&quot;\n&#x2F;&#x2F; 地理围栏区域\nlet kID &#x3D; &quot;com.williamxie.AirLocate&quot;\n&#x2F;&#x2F; 蓝牙强度\nlet kPower &#x3D; -59\n\nclass ViewController: UIViewController , CBPeripheralManagerDelegate &#123;\n    &#x2F;&#x2F;蓝牙低功耗外设管理者\n    var peripheralManager : CBPeripheralManager!\n    \n    override func viewDidLoad() &#123;\n        super.viewDidLoad()\n        \n        self.peripheralManager &#x3D; CBPeripheralManager(delegate: self, queue: nil)\n        \n    &#125;\n    \n    &#x2F;&#x2F;广播数据开关\n    @IBAction func valueChanged(sender: AnyObject) &#123;\n        \n        let swc &#x3D; sender as! UISwitch\n        if swc.on &#123;\n            \n            let uuid &#x3D; NSUUID(UUIDString: kUUID)\n            &#x2F;&#x2F;CLBeaconRegion 对象 描述了 基于蓝牙低功耗Beacon 的地理围栏区域\n            &#x2F;&#x2F; 创建iBeancon 基站 定位标示符 和 地理围栏表示\n            let region &#x3D; CLBeaconRegion(proximityUUID: uuid!, identifier: kID)\n            &#x2F;&#x2F;获取iBeacon 基站广播所需数据\n            let peripheralData &#x3D; region.peripheralDataWithMeasuredPower(kPower)\n            let dict:NSDictionary &#x3D; peripheralData\n            &#x2F;&#x2F;进行广播\n            self.peripheralManager.startAdvertising(dict as! [String : AnyObject] )\n            \n        &#125; else &#123;\n        \t&#x2F;&#x2F;定制广播\n            self.peripheralManager.stopAdvertising()\n        &#125;\n    &#125;\n    \n    &#x2F;&#x2F;MARK: --实现CBPeripheralManagerDelegate协议\n    func peripheralManagerDidUpdateState(peripheral: CBPeripheralManager) &#123;\n        print(&quot;外设状态变化&quot;)\n    &#125;\n&#125;\n</code></pre>\n\n<p>##iBeacon 客户端</p>\n<p><code>ViewController.swift</code></p>\n<pre class=\"line-numbers language-swift\" data-language=\"swift\"><code class=\"language-swift\">\nimport UIKit\nimport CoreBluetooth\nimport CoreLocation\n&#x2F;&#x2F;表示iBeacon 基站\nlet kUUID &#x3D; &quot;88936DF5-E10B-4382-89D6-8AE0D80373F8&quot;\n&#x2F;&#x2F;表示 地理围栏\nlet kID &#x3D; &quot;com.williamxie.AirLocate&quot;\n&#x2F;&#x2F;蓝牙强度\nlet kPower &#x3D; -59\n\nclass ViewController: UIViewController, CLLocationManagerDelegate &#123;\n    \n    @IBOutlet weak var lblRanging: UILabel!\n    \n    var locationManager : CLLocationManager!\n    &#x2F;&#x2F;地理围栏区域\n    var region : CLBeaconRegion!\n    \n    override func viewDidLoad() &#123;\n        super.viewDidLoad()\n        self.locationManager &#x3D; CLLocationManager()\n        self.locationManager.delegate &#x3D; self\n        \n        let uuid &#x3D; NSUUID(UUIDString: kUUID)\n        self.region &#x3D; CLBeaconRegion(proximityUUID: uuid!, identifier: kID)\n        \n        self.locationManager.requestAlwaysAuthorization()\n    &#125;\n    &#x2F;&#x2F;view 销毁的时候停止监听和距离检测\n    override func viewDidDisappear(animated: Bool) &#123;\n        super.viewDidDisappear(false)\n        self.locationManager.stopMonitoringForRegion(self.region)\n        self.locationManager.stopRangingBeaconsInRegion(self.region)\n    &#125;\n    \n    @IBAction func rangValue(sender: AnyObject) &#123;\n        let swc &#x3D; sender as! UISwitch\n        if swc.on &#123;\n            &#x2F;&#x2F;开始检测距离\n            self.locationManager.startRangingBeaconsInRegion(self.region)\n        &#125; else &#123;\n            &#x2F;&#x2F;停止检测距离\n            self.locationManager.stopRangingBeaconsInRegion(self.region)\n        &#125;\n    &#125;\n    \n    \n    @IBAction func onClickMonitoring(sender: AnyObject) &#123;\n        &#x2F;&#x2F;开始检测范围\n        self.locationManager.startMonitoringForRegion(self.region)\n    &#125;\n    \n    &#x2F;&#x2F;MARK: --实现CLLocationManagerDelegate委托协议\n    &#x2F;&#x2F;范围状态变化时候调用\n    func locationManager(manager: CLLocationManager, didDetermineState state: CLRegionState, forRegion region: CLRegion) &#123;\n        let notification &#x3D; UILocalNotification()\n        &#x2F;&#x2F;判断是在围栏外还是围栏内\n        if state &#x3D;&#x3D; .Inside &#123;\n            notification.alertBody &#x3D; &quot;你在围栏内&quot;\n        &#125; else if state &#x3D;&#x3D; .Outside &#123;\n            notification.alertBody &#x3D; &quot;你在围栏外&quot;\n        &#125; else &#123;\n            return\n        &#125;\n        &#x2F;&#x2F;发送本地通知\n        UIApplication.sharedApplication().presentLocalNotificationNow(notification)\n     &#125;\n    &#x2F;&#x2F;在设备将要进入到指定的地理围栏内时候调用\n    func locationManager(manager: CLLocationManager, didEnterRegion region: CLRegion) &#123;\n        let notification &#x3D; UILocalNotification()\n        notification.alertBody &#x3D; &quot;你进入围栏&quot;\n        UIApplication.sharedApplication().presentLocalNotificationNow(notification)\n    &#125;\n    &#x2F;&#x2F;在设备将要退出到指定的地理围栏内时候调用\n    func locationManager(manager: CLLocationManager, didExitRegion region: CLRegion) &#123;\n        let notification &#x3D; UILocalNotification()\n        notification.alertBody &#x3D; &quot;你退出围栏&quot;\n        UIApplication.sharedApplication().presentLocalNotificationNow(notification)\n    &#125;\n    &#x2F;&#x2F;在指定的围栏中Beacon设备位置变化时调用, beacons是多个beacon设备的数组\n    func locationManager(manager: CLLocationManager, didRangeBeacons beacons: [CLBeacon], inRegion region: CLBeaconRegion) &#123;\n       \n        let aryBeacons &#x3D; beacons as NSArray\n        &#x2F;&#x2F;逻辑查询条件对象,用来在内存中过滤集合对象,通过格式化Predicate字符串创建NSPredicate\n        var predicate &#x3D; NSPredicate(format: &quot;proximity &#x3D; %d&quot;, CLProximity.Unknown.rawValue)\n        let unknownBeacons &#x3D; aryBeacons.filteredArrayUsingPredicate(predicate)\n        if unknownBeacons.count &gt; 0 &#123;\n            self.lblRanging.text &#x3D; &quot;未检测到&quot;\n        &#125;\n        \n        predicate &#x3D; NSPredicate(format: &quot;proximity &#x3D; %d&quot;, CLProximity.Immediate.rawValue)\n        let immediateBeacons &#x3D; aryBeacons.filteredArrayUsingPredicate(predicate)\n        if immediateBeacons.count &gt; 0 &#123;\n            self.lblRanging.text &#x3D; &quot;最接近&quot;\n        &#125;\n        \n        predicate &#x3D; NSPredicate(format: &quot;proximity &#x3D; %d&quot;, CLProximity.Near.rawValue)\n        let nearBeacons &#x3D; aryBeacons.filteredArrayUsingPredicate(predicate)\n        if nearBeacons.count &gt; 0 &#123;\n            self.lblRanging.text &#x3D; &quot;近距离&quot;\n        &#125;\n        \n        predicate &#x3D; NSPredicate(format: &quot;proximity &#x3D; %d&quot;, CLProximity.Far.rawValue)\n        let farBeacons &#x3D; aryBeacons.filteredArrayUsingPredicate(predicate)\n        if farBeacons.count &gt; 0 &#123;\n            self.lblRanging.text &#x3D; &quot;远距离&quot;\n        &#125;\n        \n    &#125;\n&#125;\n\n要用到通知,所以配置通知的环境 在Info.plist 添加字段\n\n&#96;AppDelegate.swift&#96;\n&#96;&#96;&#96;swift\n    func application(application: UIApplication, didFinishLaunchingWithOptions launchOptions: [NSObject: AnyObject]?) -&gt; Bool &#123;\n        \n        let setting &#x3D; UIUserNotificationSettings(forTypes: [.Alert, .Badge, .Sound], categories: nil)\n        UIApplication.sharedApplication().registerUserNotificationSettings(setting)\n        \n        return true\n    &#125;</code></pre>\n\n\n\n\n\n<p>参考:</p>\n<p><code>CLBeaconRegion</code> 类</p>\n<pre class=\"line-numbers language-swift\" data-language=\"swift\"><code class=\"language-swift\">public class CLBeaconRegion : CLRegion &#123;\n\t&#x2F;&#x2F;identifier 是用来表示地理围栏的\n    public init(proximityUUID: NSUUID, identifier: String)\n    \n    public init(proximityUUID: NSUUID, major: CLBeaconMajorValue, identifier: String)\n    \n    public init(proximityUUID: NSUUID, major: CLBeaconMajorValue, minor: CLBeaconMinorValue, identifier: String)\n\n    public func peripheralDataWithMeasuredPower(measuredPower: NSNumber?) -&gt; NSMutableDictionary\n\n  \t&#x2F;&#x2F;&#x2F; 接近UUID 一个128的唯一表示,表示一个或多个iBeacon基站 \n    public var proximityUUID: NSUUID &#123; get &#125;\n    &#x2F;&#x2F; 主值 它是一个16位的无符号整数，用于区分有相同的接近UUID的 iBeacon基站\n    public var major: NSNumber? &#123; get &#125;\n    &#x2F;&#x2F; 副值  它是一个16位的无符号整数，用于区分有相同的接近UUID和的主值的iBeacon基站 \n    public var minor: NSNumber? &#123; get &#125;\n    &#x2F;&#x2F;\n    public var notifyEntryStateOnDisplay: Bool\n&#125;</code></pre>\n","text":"在一家大型商场,医院或是大楼里,你是否会曾经有过找不到想要去的地方的经历呢?这种情况下采用上面介绍的传统定位方式,就有些”力不从心”了,首先不能采用GPS定位,而WiFi 和蜂窝式移动电话基站定位误差比较大,这种情况下的定位就是 “微定位”技术了 #地理围栏 微定位技术中一个比较...","link":"","photos":[],"count_time":{"symbolsCount":"9k","symbolsTime":"8 mins."},"categories":[{"name":"iOS SDK","slug":"iOS-SDK","count":18,"path":"api/categories/iOS-SDK.json"}],"tags":[{"name":"iBeacon","slug":"iBeacon","count":1,"path":"api/tags/iBeacon.json"}],"toc":"","author":{"name":"William Xie","slug":"blog-author","avatar":"/img/author.png","link":"/","description":"","socials":{"github":"https://github.com/williamxiewz","twitter":"https://twitter.com/williamxie_wz","stackoverflow":"http://stackoverflow.com/users/4078104/goingxiebin-jobs","wechat":"","qq":"","weibo":"https://weibo.com/u/2281381063","zhihu":"https://www.zhihu.com/people/williamxiewz","csdn":"https://blog.csdn.net/u014222645","juejin":"https://juejin.cn/user/3280598430133277","customs":{}}},"mapped":true,"prev_post":{"title":"Wallet 开发","uid":"9f6ced9582899d9cc298fd7b7b36a194","slug":"Wallet开发","date":"2016-08-10T11:08:30.000Z","updated":"2016-08-22T15:37:25.000Z","comments":true,"path":"api/articles/Wallet开发.json","keywords":null,"cover":null,"text":"2012年WWDC上iOS6发布了一个全新的应用–Passbook，管理电子票券，包括登机牌，电影票，优惠卡，购物卡等。2015年苹果全球开发者大会(WWDC 2015)在美国旧金山正式开幕本届主题为“the epicenter of change.（变革的中心）”。苹果在会上宣...","link":"","photos":[],"count_time":{"symbolsCount":242,"symbolsTime":"1 mins."},"categories":[{"name":"iOS SDK","slug":"iOS-SDK","count":18,"path":"api/categories/iOS-SDK.json"}],"tags":[{"name":"Wallet","slug":"Wallet","count":1,"path":"api/tags/Wallet.json"}],"author":{"name":"William Xie","slug":"blog-author","avatar":"/img/author.png","link":"/","description":"","socials":{"github":"https://github.com/williamxiewz","twitter":"https://twitter.com/williamxie_wz","stackoverflow":"http://stackoverflow.com/users/4078104/goingxiebin-jobs","wechat":"","qq":"","weibo":"https://weibo.com/u/2281381063","zhihu":"https://www.zhihu.com/people/williamxiewz","csdn":"https://blog.csdn.net/u014222645","juejin":"https://juejin.cn/user/3280598430133277","customs":{}}}},"next_post":{"title":"Multipeer connectivity 对等结构网络编程","uid":"89f1cad59352c7f82ca21656f76e183c","slug":"Multipeer-connectivity-对等结构网络编程","date":"2016-08-10T10:58:32.000Z","updated":"2016-08-22T15:37:47.000Z","comments":true,"path":"api/articles/Multipeer-connectivity-对等结构网络编程.json","keywords":null,"cover":null,"text":"#对等结构网络 对等结构网络是苹果的Ad Hoc网络的一种,是在小空间里构建无限网络的解决方案。苹果公司的GameKit或Multipeer Connectivity(多点连接）框架中提供了开发这种网络的APi. 在iOS7中，引入了一个全新的框架——Multipeer Conn...","link":"","photos":[],"count_time":{"symbolsCount":"8.7k","symbolsTime":"8 mins."},"categories":[{"name":"iOS网络编程","slug":"iOS网络编程","count":9,"path":"api/categories/iOS网络编程.json"}],"tags":[{"name":"Multipeer connectivity","slug":"Multipeer-connectivity","count":1,"path":"api/tags/Multipeer-connectivity.json"}],"author":{"name":"William Xie","slug":"blog-author","avatar":"/img/author.png","link":"/","description":"","socials":{"github":"https://github.com/williamxiewz","twitter":"https://twitter.com/williamxie_wz","stackoverflow":"http://stackoverflow.com/users/4078104/goingxiebin-jobs","wechat":"","qq":"","weibo":"https://weibo.com/u/2281381063","zhihu":"https://www.zhihu.com/people/williamxiewz","csdn":"https://blog.csdn.net/u014222645","juejin":"https://juejin.cn/user/3280598430133277","customs":{}}}}}