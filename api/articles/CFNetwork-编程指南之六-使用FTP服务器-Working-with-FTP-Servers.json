{"title":"CFNetwork 编程指南之六: 使用FTP服务器(Working with FTP Servers)","uid":"4fe0927b9d7f454761510969d0dea921","slug":"CFNetwork-编程指南之六-使用FTP服务器-Working-with-FTP-Servers","date":"2016-08-10T03:58:41.000Z","updated":"2016-08-19T11:45:52.000Z","comments":true,"path":"api/articles/CFNetwork-编程指南之六-使用FTP服务器-Working-with-FTP-Servers.json","keywords":null,"cover":null,"content":"<p>#使用FTP服务器</p>\n<p>本文揭示了如何使用CFFTP API的一些基本特性。管理FTP事务是异步执行的，而管理文件传输是同步实现的。</p>\n<p>##下载文件<br>使用CFFTP类似于CFHTTP ，因为它们都是基于CFStream。与其他任何异步使用CFStream的API一样，使用CFFTP下载一个文件要求你为文件创建一个读取流和一个回调函数。当读取流接收数据时，回调函数将运行，你需要适当的下载字节。这个过程通常执行两个函数：一个用来设置流，另一个充当回调函数。</p>\n<p>###设置FTP流<br>首先使用<a href=\"https://developer.apple.com/library/ios/documentation/CoreFoundation/Reference/CFFTPStreamRef/index.html#//apple_ref/doc/c_ref/CFReadStreamCreateWithFTPURL\">CFReadStreamCreateWithFTPURL</a> 函数创建一个读取流并传入要下载远程服务器上文件的URL字符串。URL字符串的例子<code>ftp://ftp.example.com/file.txt</code>。注意：字符串包含服务器名称、路径和文件。接下来，在文件下载的位置创建一个本地写入流。这个过程使用<a href=\"https://developer.apple.com/library/ios/documentation/CoreFoundation/Reference/CFWriteStreamRef/index.html#//apple_ref/doc/c_ref/CFWriteStreamCreateWithFile\">CFWriteStreamCreateWithFile</a> 函数完成，传入要下载文件的路径。</p>\n<span id=\"more\"></span>\n\n<p>由于读写流必须保持同步，创建一个包含所有共同信息，例如代理字典、文件大小、写入字节数、剩余字节数和缓存区的结构。结构如列表5-1所示</p>\n<p>列表5-1 流结构</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\"><span class=\"token keyword\">typedef</span> <span class=\"token keyword\">struct</span> <span class=\"token class-name\">MyStreamInfo</span> <span class=\"token punctuation\">&#123;</span>\n\nCFWriteStreamRef  writeStream<span class=\"token punctuation\">;</span>\nCFReadStreamRef  readStream<span class=\"token punctuation\">;</span>\nCFDictionaryRef  proxyDict<span class=\"token punctuation\">;</span>\nSInt64            fileSize<span class=\"token punctuation\">;</span>\nUInt32            totalBytesWritten<span class=\"token punctuation\">;</span>\nUInt32            leftOverByteCount<span class=\"token punctuation\">;</span>\nUInt8            buffer<span class=\"token punctuation\">[</span>kMyBufferSize<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span> MyStreamInfo<span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>为你刚刚创建的读写流初始化结构。可以定义流客户端内容(<code>CFStreamClientContext</code>)的info字段执行结构。这在以后非常有用。</p>\n<p>用<a href=\"https://developer.apple.com/library/ios/documentation/CoreFoundation/Reference/CFWriteStreamRef/index.html#//apple_ref/c/func/CFWriteStreamOpen\">CFWriteStreamOpen</a> 函数打开你的写入流，这样你可以开始写入本地文件。确保流正常打开，调用<a href=\"https://developer.apple.com/library/ios/documentation/CoreFoundation/Reference/CFWriteStreamRef/index.html#//apple_ref/doc/c_ref/CFWriteStreamGetStatus\">CFWriteStreamGetStatus</a> 函数检查返回<code>kCFStreamStatusOpen</code> 或<code>kCFStreamStatusOpening</code>。</p>\n<p>写入流打开后，将回调函数与读取流结合。调用<a href=\"https://developer.apple.com/library/ios/documentation/CoreFoundation/Reference/CFReadStreamRef/index.html#//apple_ref/c/func/CFReadStreamSetClient\">CFReadStreamSetClient</a> 函数并传递读取流，你的回调函数要接收的网络事件，回调函数名称和<code>CFStreamClientContext</code> 对象。在之前设置客户端环境流中的info 字段，在运行时结构将发送到回调函数。</p>\n<p>一些FTP服务可能需要用户名，其他可能还需要密码。如果访问的服务器需要用户名进行验证，调用<a href=\"https://developer.apple.com/library/ios/documentation/CoreFoundation/Reference/CFReadStreamRef/index.html#//apple_ref/c/func/CFReadStreamSetProperty\">CFReadStreamSetProperty</a> 函数并传递读取流，<a href=\"\">kCFStreamPropertyFTPUserName</a> 属性和包含用户名的CFString 对象的引用。此外，如果需要设置密码，设置kCFStreamPropertyFTPPassword 属性。</p>\n<p>一些网络配置也可以使用FTP代理。获取代理信息的方式取决于你的代码是运行在OS X 还是iOS上。</p>\n<ul>\n<li><p>在OS X 中，可以调用SCDynamicStoreCopyProxies 函数在字典中检索代理设置并传递NULL。</p>\n</li>\n<li><p>在iOS中，可以调用<a href=\"https://developer.apple.com/library/ios/documentation/CoreFoundation/Reference/CFProxySupport/index.html#//apple_ref/c/func/CFNetworkCopyProxiesForURL\">CFNetworkCopyProxiesForURL</a>来检索代理设置。</p>\n</li>\n</ul>\n<p>这些函数返回一个动态存储引用。可以使用这个值来设置读取流的kCFStreamPropertyFTPProxy 属性。设置代理服务器，指定端口并返回一个布尔值，该值表明FTP流是否执行被动模式。</p>\n<p>除了提到的属性，还有一些其他的属性用于FTP流。完整的列表如下。</p>\n<ul>\n<li><p><code>kCFStreamPropertyFTPUserName</code> ——使用用户名登陆（可设置并可检索；匿名FTP连接不要设置）</p>\n</li>\n<li><p><code>kCFStreamPropertyFTPPassword</code> ——使用密码登陆（可设置并可检索；匿名FTP连接不要设置）</p>\n</li>\n<li><p><code>kCFStreamPropertyFTPUsePassiveMode</code> ——是否采用被动模式（可设置并可检索）</p>\n</li>\n<li><p><code>kCFStreamPropertyFTPResourceSize</code> ——下载项目的预期大小，如果可用（可检索；只有FTP读取流可用）</p>\n</li>\n<li><p><code>kCFStreamPropertyFTPFetchResourceInfo</code> ——是否要求资源信息，例如大小，开始下载前是否需要该信息（可设置并可检索）；设置这个属性可能会影响性能</p>\n</li>\n<li><p><code>kCFStreamPropertyFTPFileTransferOffset</code> ——开始转移的文件偏移量（可设置并可检索）</p>\n</li>\n<li><p><code>kCFStreamPropertyFTPAttemptPersistentConnection</code> ——是否尝试重用连接（可设置并可检索）</p>\n</li>\n<li><p><code>kCFStreamPropertyFTPProxy</code> ——包含代理字典的键值对（可设置并可检索）的CFDictionary 类型</p>\n</li>\n<li><p><code>kCFStreamPropertyFTPProxyHost</code> ——FTP代理主机名称（可设置并可检索）</p>\n</li>\n<li><p><code>kCFStreamPropertyFTPProxyPort</code> ——FTP代理主机端口号（可设置并可检索）</p>\n</li>\n</ul>\n<p>读取流分配正确的属性后，使用CFReadStreamOpen 函数打开流。假设并不返回一个错误，所有的流都正确设置。</p>\n<p>###实现回调函数<br>回调函数将接收三个参数：读取流，事件类型和MyStreamInfo 结构。事件的类型决定了采取什么行动。</p>\n<p>最常见的事件是kCFStreamEventHasBytesAvailable，当读取流从服务器接收到字节时，将发送该事件。首先，调用<a href=\"https://developer.apple.com/library/ios/documentation/CoreFoundation/Reference/CFReadStreamRef/index.html#//apple_ref/doc/c_ref/CFReadStreamOpen\">CFReadStreamRead </a>函数检查读取了多少字节。确保返回值不小于0（错误）或者等于0（已经下载完）。如果返回值为正，然后你可以开始将读取流中的数据写入到磁盘中。</p>\n<p>调用<a href=\"https://developer.apple.com/library/ios/documentation/CoreFoundation/Reference/CFWriteStreamRef/index.html#//apple_ref/doc/c_ref/CFWriteStreamWrite\">CFWriteStreamWrite</a> 函数写入数据到写入流。有时候在没有写入所有读取流中的数据是，<a href=\"https://developer.apple.com/library/ios/documentation/CoreFoundation/Reference/CFWriteStreamRef/index.html#//apple_ref/doc/c_ref/CFWriteStreamWrite\">CFWriteStreamWrite</a> 可以返回。出于这个原因，只要还在写入数据，设置一个运行循环。代码见列表5-2，其中的info 是设置流（<a href=\"https://developer.apple.com/library/ios/documentation/Networking/Conceptual/CFNetwork/CFFTPTasks/CFFTPTasks.html#//apple_ref/doc/uid/TP30001132-CH9-SW2\">Setting up the Streams</a>）中的MyStreamInfo 结构。写入到写入流的方法使用阻塞流。通过写入流事件驱动可以实现更好的性能，但代码比较复杂。</p>\n<p>列表5-2 将数据从读取流中写入到写入流</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">bytesRead <span class=\"token operator\">=</span> <span class=\"token function\">CFReadStreamRead</span><span class=\"token punctuation\">(</span>info<span class=\"token operator\">-></span>readStream<span class=\"token punctuation\">,</span>   \ninfo<span class=\"token operator\">-></span>buffer<span class=\"token punctuation\">,</span> kMyBufferSize<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">//...make sure bytesRead > 0 ...</span>\nbytesWritten <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> \n<span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>bytesWritten <span class=\"token operator\">&lt;</span> bytesRead<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span> \n\nCFIndex result<span class=\"token punctuation\">;</span>\n\nresult <span class=\"token operator\">=</span> <span class=\"token function\">CFWriteStreamWrite</span><span class=\"token punctuation\">(</span>info<span class=\"token operator\">-></span>writeStream<span class=\"token punctuation\">,</span>\ninfo<span class=\"token operator\">-></span>buffer <span class=\"token operator\">+</span> bytesWritten<span class=\"token punctuation\">,</span> bytesRead <span class=\"token operator\">-</span> bytesWritten<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> \n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>result <span class=\"token operator\">&lt;=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token function\">fprintf</span><span class=\"token punctuation\">(</span><span class=\"token constant\">stderr</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"CFWriteStreamWrite returned %ld\\n\"</span><span class=\"token punctuation\">,</span> result<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">goto</span> exit<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span>\nbytesWritten <span class=\"token operator\">+=</span> result<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span>info<span class=\"token operator\">-></span>totalBytesWritten <span class=\"token operator\">+=</span> bytesWritten<span class=\"token punctuation\">;</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>只要在读取流中有可用的直接，重复整个过程。</p>\n<p>要当心其他两个事件<code>kCFStreamEventErrorOccurred</code> 和<code>kCFStreamEventEndEncountered</code>。如果出现错误，使用<a href=\"https://developer.apple.com/library/ios/documentation/CoreFoundation/Reference/CFReadStreamRef/index.html#//apple_ref/doc/c_ref/CFReadStreamGetError\">CFReadStreamGetError</a> 检索错误然后退出。如果在文件末尾发生错误，下载已经完成可以退出。</p>\n<p>确保一切完成并且没有其他过程使用流后删除所有流。首先，关闭写入流并设置客户端为NULL。然后从运行循环上取消流并释放。当完成后，从运行循环上删除流。</p>\n<p>##上传文件<br>上传文件类似下载文件。正如下载文件一样，你需要一个读取流和一个写入流。然而，当上传文件，读取流为本地文件而写入流为远程文件。按照设置流（<a href=\"https://developer.apple.com/library/ios/documentation/Networking/Conceptual/CFNetwork/CFFTPTasks/CFFTPTasks.html#//apple_ref/doc/uid/TP30001132-CH9-SW2\">Setting up the Streams</a>）中的说明，但无论在任何地方引用读取流，将代码应用到写入流，反之亦然。</p>\n<p>在回调函数中查找<code>kCFStreamEventCanAcceptBytes</code>事件，而不是查找<code>kCFStreamEventHasBytesAvailable</code> 事件。首先，使用读取流并将数据放到MyStreamInfo中缓冲区，从文件中读取字节。然后，运行<a href=\"https://developer.apple.com/library/ios/documentation/CoreFoundation/Reference/CFWriteStreamRef/index.html#//apple_ref/doc/c_ref/CFWriteStreamWrite\">CFWriteStreamWrite</a> 函数将字节从缓冲区写入到写入流。<a href=\"https://developer.apple.com/library/ios/documentation/CoreFoundation/Reference/CFWriteStreamRef/index.html#//apple_ref/doc/c_ref/CFWriteStreamWrite\">CFWriteStreamWrite</a> 返回写入流的字节数。如果写入的字节数少于从文件读取的数目，计算出剩余的字节并将它们存储到缓冲区。在接下来的写入周期，如果有剩余的直接，将它们写入到写入流而不是从读取流中加载新数据。只要写入流可以接受字节（<a href=\"https://developer.apple.com/library/ios/documentation/CoreFoundation/Reference/CFWriteStreamRef/index.html#//apple_ref/doc/c_ref/CFWriteStreamCanAcceptBytes\">CFWriteStreamCanAcceptBytes</a>），重复整个过程。循环代码见列表5-3.</p>\n<p>列表5-3 写入数据到写入流</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\"><span class=\"token keyword\">do</span> <span class=\"token punctuation\">&#123;</span> \n\n<span class=\"token comment\">// Check for leftover data</span>\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>info<span class=\"token operator\">-></span>leftOverByteCount <span class=\"token operator\">></span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n    bytesRead <span class=\"token operator\">=</span> info<span class=\"token operator\">-></span>leftOverByteCount<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token comment\">// Make sure there is no error reading from the file</span>\n    bytesRead <span class=\"token operator\">=</span> <span class=\"token function\">CFReadStreamRead</span><span class=\"token punctuation\">(</span>info<span class=\"token operator\">-></span>readStream<span class=\"token punctuation\">,</span> info<span class=\"token operator\">-></span>buffer<span class=\"token punctuation\">,</span>\n                                kMyBufferSize<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>bytesRead <span class=\"token operator\">&lt;</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token function\">fprintf</span><span class=\"token punctuation\">(</span><span class=\"token constant\">stderr</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"CFReadStreamRead returned %ld\\n\"</span><span class=\"token punctuation\">,</span> bytesRead<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">goto</span> exit<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n    totalBytesRead <span class=\"token operator\">+=</span> bytesRead<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span>\n\n<span class=\"token comment\">// Write the data to the write stream</span>\nbytesWritten <span class=\"token operator\">=</span> <span class=\"token function\">CFWriteStreamWrite</span><span class=\"token punctuation\">(</span>info<span class=\"token operator\">-></span>writeStream<span class=\"token punctuation\">,</span>\ninfo<span class=\"token operator\">-></span>buffer<span class=\"token punctuation\">,</span> bytesRead<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> \n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>bytesWritten <span class=\"token operator\">></span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n\n    info<span class=\"token operator\">-></span>totalBytesWritten <span class=\"token operator\">+=</span> bytesWritten<span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\">// Store leftover data until kCFStreamEventCanAcceptBytes event occurs again</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>bytesWritten <span class=\"token operator\">&lt;</span> bytesRead<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        info<span class=\"token operator\">-></span>leftOverByteCount <span class=\"token operator\">=</span> bytesRead <span class=\"token operator\">-</span> bytesWritten<span class=\"token punctuation\">;</span>\n        <span class=\"token function\">memmove</span><span class=\"token punctuation\">(</span>info<span class=\"token operator\">-></span>buffer<span class=\"token punctuation\">,</span> info<span class=\"token operator\">-></span>buffer <span class=\"token operator\">+</span> bytesWritten<span class=\"token punctuation\">,</span>\n                info<span class=\"token operator\">-></span>leftOverByteCount<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">&#123;</span>\n        info<span class=\"token operator\">-></span>leftOverByteCount <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>bytesWritten <span class=\"token operator\">&lt;</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n        <span class=\"token function\">fprintf</span><span class=\"token punctuation\">(</span><span class=\"token constant\">stderr</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"CFWriteStreamWrite returned %ld\\n\"</span><span class=\"token punctuation\">,</span>\nbytesWritten<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> \n    <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span> <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span><span class=\"token function\">CFWriteStreamCanAcceptBytes</span><span class=\"token punctuation\">(</span>info<span class=\"token operator\">-></span>writeStream<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n\n<p>就像下载文件时，会有<code>kCFStreamEventErrorOccurred</code> 和<code>kCFStreamEventEndEncountered</code> 事件。</p>\n<p>##创建远程目录<br>在远程服务器上创建目录，设置一个写入流正如你要上传文件。然而，提供一个目录路径而非文件，CFURL 对象传递到<a href=\"https://developer.apple.com/library/ios/documentation/CoreFoundation/Reference/CFFTPStreamRef/index.html#//apple_ref/doc/c_ref/CFWriteStreamCreateWithFTPURL\">CFWriteStreamCreateWithFTPURL</a> 函数。用斜杠’/’结束路径。例如，一个适当的目录路径为<code>ftp://ftp.example.com/newDirectory/</code>，而非 <code>ftp://ftp.example.com/newDirectory/newFile.txt</code>。当运行循环执行回调函数，将发送<code>kCFStreamEventEndEncountered</code>事件，这表明已经创建了目录（或者<code>kCFStreamEventErrorOccurred</code>，表明发生错误）</p>\n<p>每次调用<a href=\"https://developer.apple.com/library/ios/documentation/CoreFoundation/Reference/CFFTPStreamRef/index.html#//apple_ref/doc/c_ref/CFWriteStreamCreateWithFTPURL\">CFWriteStreamCreateWithFTPURL</a>只可以创建一个目录级别。只有你有正确的服务器权限，才能创建目录。</p>\n<p>##下载目录列表<br>通过FTP下载目录列表与下载或上传文件略有不同。这是由于传入的数据必须被解析。首先，建立一个读取流来获取目录列表。对于下载文件这个必须完成：创建流，注册回调函数，运行循环上安排流（如果有必要，设置用户名、密码和代理信息），最后打开流。在接下来的例子中，当检索目录列表时，你不需要读取和写入流，因为传入的数据将要显示到屏幕上而非文件中。</p>\n<p>在回调函数中，当心<code>kCFStreamEventHasBytesAvailable</code> 事件。从读取流中加载数据前，确保上次回调函数运行后的流中没有剩余数据。从<code>MyStreamInfo</code> 结构的<code>leftOverByteCount</code>字段加载偏移。然后，从流中读取数据，考虑你计算的偏移。缓冲区大小和读取的字节数也需要计算。如列表5-4所示。</p>\n<p>列表5-4 加载目录列表数据</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\"><span class=\"token comment\">// If previous call had unloaded data</span>\n<span class=\"token keyword\">int</span> offset <span class=\"token operator\">=</span> info<span class=\"token operator\">-></span>leftOverByteCount<span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// Load data from the read stream, accounting for the offset</span>\nbytesRead <span class=\"token operator\">=</span> <span class=\"token function\">CFReadStreamRead</span><span class=\"token punctuation\">(</span>info<span class=\"token operator\">-></span>readStream<span class=\"token punctuation\">,</span> info<span class=\"token operator\">-></span>buffer <span class=\"token operator\">+</span> offset<span class=\"token punctuation\">,</span>\nkMyBufferSize <span class=\"token operator\">-</span> offset<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>bytesRead <span class=\"token operator\">&lt;</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n\n<span class=\"token function\">fprintf</span><span class=\"token punctuation\">(</span><span class=\"token constant\">stderr</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"CFReadStreamRead returned %ld\\n\"</span><span class=\"token punctuation\">,</span> bytesRead<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span> <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>bytesRead <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n<span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token punctuation\">&#125;</span>\n\nbufSize <span class=\"token operator\">=</span> bytesRead <span class=\"token operator\">+</span> offset<span class=\"token punctuation\">;</span>\ntotalBytesRead <span class=\"token operator\">+=</span> bufSize<span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>数据被读取到缓冲区后，设置一个循环来解析数据。解析的数据不一定是整个目录列表；它可以（可能）是大块的列表。使用<a href=\"https://developer.apple.com/library/ios/documentation/CoreFoundation/Reference/CFFTPStreamRef/index.html#//apple_ref/doc/c_ref/CFFTPCreateParsedResourceListing\">CFFTPCreateParsedResourceListing</a>函数创建解析数据的循环，需传入缓冲区数据，缓冲区大小和字典引用。它返回解析的字节数。只要这个值大于0，继续循环。<a href=\"https://developer.apple.com/library/ios/documentation/CoreFoundation/Reference/CFFTPStreamRef/index.html#//apple_ref/doc/c_ref/CFFTPCreateParsedResourceListing\">CFFTPCreateParsedResourceListing</a> 字典创建包含所有目录列表信息；关于更多可用键参阅设置流（ <a href=\"https://developer.apple.com/library/ios/documentation/Networking/Conceptual/CFNetwork/CFFTPTasks/CFFTPTasks.html#//apple_ref/doc/uid/TP30001132-CH9-SW2\">Setting up the Streams</a>）。</p>\n<p><code>CFFTPCreateParsedResourceListing</code> 有可能返回一个正数，而不是创建一个解析字典。例如，如果在列表的末尾包含的信息不能被解析，<code>CFFTPCreateParsedResourceListing</code> 将返回一个正数告诉调用者数据已经消耗。然而，<code>CFFTPCreateParsedResourceListing</code> 不创建一个解析字典，因为它无法理解数据。</p>\n<p>如果创建一个解析字典，重新计算读取的字节数和缓存区大小，如列表5-5所示。</p>\n<p>列表5-5 加载目录列表并解析</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\"><span class=\"token keyword\">do</span><span class=\"token punctuation\">&#123;</span> \n\nbufRemaining <span class=\"token operator\">=</span> info<span class=\"token operator\">-></span>buffer <span class=\"token operator\">+</span> totalBytesConsumed<span class=\"token punctuation\">;</span>\n\nbytesConsumed <span class=\"token operator\">=</span> <span class=\"token function\">CFFTPCreateParsedResourceListing</span><span class=\"token punctuation\">(</span><span class=\"token constant\">NULL</span><span class=\"token punctuation\">,</span> bufRemaining<span class=\"token punctuation\">,</span>\n                                                bufSize<span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>parsedDict<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>bytesConsumed <span class=\"token operator\">></span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n\n    <span class=\"token comment\">// Make sure CFFTPCreateParsedResourceListing was able to properly</span>\n    <span class=\"token comment\">// parse the incoming data</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>parsedDict <span class=\"token operator\">!=</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token comment\">// ...Print out data from parsedDict...</span>\n        <span class=\"token function\">CFRelease</span><span class=\"token punctuation\">(</span>parsedDict<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n\n    totalBytesConsumed <span class=\"token operator\">+=</span> bytesConsumed<span class=\"token punctuation\">;</span>\n    bufSize <span class=\"token operator\">-=</span> bytesConsumed<span class=\"token punctuation\">;</span>\n    info<span class=\"token operator\">-></span>leftOverByteCount <span class=\"token operator\">=</span> bufSize<span class=\"token punctuation\">;</span>\n\n<span class=\"token punctuation\">&#125;</span> <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>bytesConsumed <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n\n    <span class=\"token comment\">// This is just in case. It should never happen due to the large buffer size</span>\n    info<span class=\"token operator\">-></span>leftOverByteCount <span class=\"token operator\">=</span> bufSize<span class=\"token punctuation\">;</span>\n    totalBytesRead <span class=\"token operator\">-=</span> info<span class=\"token operator\">-></span>leftOverByteCount<span class=\"token punctuation\">;</span>\n    <span class=\"token function\">memmove</span><span class=\"token punctuation\">(</span>info<span class=\"token operator\">-></span>buffer<span class=\"token punctuation\">,</span> bufRemaining<span class=\"token punctuation\">,</span> info<span class=\"token operator\">-></span>leftOverByteCount<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token punctuation\">&#125;</span> <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>bytesConsumed <span class=\"token operator\">==</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token function\">fprintf</span><span class=\"token punctuation\">(</span><span class=\"token constant\">stderr</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"CFFTPCreateParsedResourceListing parse failure\\n\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">// ...Break loop and cleanup...</span>\n<span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span> <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>bytesConsumed <span class=\"token operator\">></span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>当流没有更多的可用字节，清理所有流并从运行循环删除它们。</p>\n<p>官方原文地址：<br><a href=\"https://developer.apple.com/library/ios/documentation/Networking/Conceptual/CFNetwork/CFFTPTasks/CFFTPTasks.html\">CFNetwork Programming Guide</a></p>\n","text":"#使用FTP服务器 本文揭示了如何使用CFFTP API的一些基本特性。管理FTP事务是异步执行的，而管理文件传输是同步实现的。 ##下载文件使用CFFTP类似于CFHTTP ，因为它们都是基于CFStream。与其他任何异步使用CFStream的API一样，使用CFFTP下载一...","link":"","photos":[],"count_time":{"symbolsCount":"8k","symbolsTime":"7 mins."},"categories":[{"name":"iOS网络编程","slug":"iOS网络编程","count":9,"path":"api/categories/iOS网络编程.json"}],"tags":[{"name":"CFNetwork","slug":"CFNetwork","count":7,"path":"api/tags/CFNetwork.json"}],"toc":"","author":{"name":"William Xie","slug":"blog-author","avatar":"/img/author.png","link":"/","description":"","socials":{"github":"https://github.com/williamxiewz","twitter":"https://twitter.com/williamxie_wz","stackoverflow":"http://stackoverflow.com/users/4078104/goingxiebin-jobs","wechat":"","qq":"","weibo":"https://weibo.com/u/2281381063","zhihu":"https://www.zhihu.com/people/williamxiewz","csdn":"https://blog.csdn.net/u014222645","juejin":"https://juejin.cn/user/3280598430133277","customs":{}}},"mapped":true,"prev_post":{"title":"CFNetwork 编程指南之七: 使用网络诊断(Using Network Diagnostics)","uid":"a234db355cc14ca7a21f932753cfdf5a","slug":"CFNetwork-编程指南之七-使用网络诊断-Using-Network-Diagnostics","date":"2016-08-10T03:59:13.000Z","updated":"2016-08-19T11:43:58.000Z","comments":true,"path":"api/articles/CFNetwork-编程指南之七-使用网络诊断-Using-Network-Diagnostics.json","keywords":null,"cover":null,"text":"#使用网络诊断 在许多基于网络的应用中，会发生基于网络的错误，这些错误与你的应用无关。然而，大多数用户可能不知道为什么应用失败。CFNetDiagnostics API为你提供一种快速而简单的方法来帮助用户解决网络问题。 如果你的应用使用一个CFStream 对象，然后调用CFN...","link":"","photos":[],"count_time":{"symbolsCount":"1.1k","symbolsTime":"1 mins."},"categories":[{"name":"iOS网络编程","slug":"iOS网络编程","count":9,"path":"api/categories/iOS网络编程.json"}],"tags":[{"name":"CFNetwork","slug":"CFNetwork","count":7,"path":"api/tags/CFNetwork.json"}],"author":{"name":"William Xie","slug":"blog-author","avatar":"/img/author.png","link":"/","description":"","socials":{"github":"https://github.com/williamxiewz","twitter":"https://twitter.com/williamxie_wz","stackoverflow":"http://stackoverflow.com/users/4078104/goingxiebin-jobs","wechat":"","qq":"","weibo":"https://weibo.com/u/2281381063","zhihu":"https://www.zhihu.com/people/williamxiewz","csdn":"https://blog.csdn.net/u014222645","juejin":"https://juejin.cn/user/3280598430133277","customs":{}}}},"next_post":{"title":"CFNetwork 编程指南之五: 与身份验证HTTP服务器通信(Communicating with Authenticating HTTP Servers)","uid":"e4b9eca156b9b591c912ba6382a5ef7f","slug":"CFNetwork-编程指南之五-与身份验证HTTP服务器通信-Communicating-with-Authenticating-HTTP-Servers","date":"2016-08-10T03:58:03.000Z","updated":"2016-08-19T11:45:25.000Z","comments":true,"path":"api/articles/CFNetwork-编程指南之五-与身份验证HTTP服务器通信-Communicating-with-Authenticating-HTTP-Servers.json","keywords":null,"cover":[],"text":"#与身份验证HTTP服务器通信 本文描述了如何利用CFHTTPAuthentication API与需要身份验证的HTTP服务器通信。它解释了如何找到匹配的验证对象和证书，并将它们应用到HTTP请求，然后存储以供以后使用。 一般来说，如果一个HTTP服务器返回一个401或407响...","link":"","photos":[],"count_time":{"symbolsCount":"11k","symbolsTime":"10 mins."},"categories":[{"name":"iOS网络编程","slug":"iOS网络编程","count":9,"path":"api/categories/iOS网络编程.json"}],"tags":[{"name":"CFNetwork","slug":"CFNetwork","count":7,"path":"api/tags/CFNetwork.json"}],"author":{"name":"William Xie","slug":"blog-author","avatar":"/img/author.png","link":"/","description":"","socials":{"github":"https://github.com/williamxiewz","twitter":"https://twitter.com/williamxie_wz","stackoverflow":"http://stackoverflow.com/users/4078104/goingxiebin-jobs","wechat":"","qq":"","weibo":"https://weibo.com/u/2281381063","zhihu":"https://www.zhihu.com/people/williamxiewz","csdn":"https://blog.csdn.net/u014222645","juejin":"https://juejin.cn/user/3280598430133277","customs":{}}}}}